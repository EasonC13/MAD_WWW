{
    "xfantv": "// Decompiled by SuiGPT\nmodule 0xda12d621169da92ed8af5f6b332b7bec64c840bb49bb3d4206d6739cd76bad14::xfantv {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::coin;\n    use sui::tx_context;\n    use std::option;\n    use sui::url;\n    use sui::token;\n    use sui::transfer;\n    use std::vector;\n    use sui::event;\n\n    // ----- Structs -----\n\n    struct AdminAdded has copy, drop {\n        admin: address,\n    }\n\n    struct AdminCap has key {\n        id: object::UID,\n        admins: vector<address>,\n    }\n\n    struct AdminRemoved has copy, drop {\n        admin: address,\n    }\n\n    struct CoinStore has key {\n        id: object::UID,\n        coin_treasury: coin::TreasuryCap<XFANTV>,\n    }\n\n    struct MaxCredit has store, key {\n        id: object::UID,\n        amount: u64,\n    }\n\n    struct SpendCoin has drop {\n        dummy_field: bool,\n    }\n\n    struct SuperAdminCap has key {\n        id: object::UID,\n    }\n\n    struct TokenCredited has copy, drop {\n        beneficiary: address,\n        amount: u64,\n    }\n\n    struct TokenDebited has copy, drop {\n        spender: address,\n        amount: u64,\n    }\n\n    struct TokenMinted has copy, drop {\n        beneficiary: address,\n        amount: u64,\n    }\n\n    struct Wallet has store, key {\n        id: object::UID,\n        beneficiary: address,\n        amount: u64,\n    }\n\n    struct WalletCap has key {\n        id: object::UID,\n    }\n\n    struct WalletCapGranted has copy, drop {\n        to_address: address,\n    }\n\n    struct XFANTV has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    fun init(\n        xfantv: XFANTV,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let (coin_treasury, coin_metadata) = coin::create_currency<XFANTV>(\n            xfantv,\n            9,\n            b\"$FAN\",\n            b\"xFanTV\",\n            b\"xFanTV represents the platform token linked to FanTV, offering ownership in the platform\",\n            option::some(url::new_unsafe_from_bytes(b\"https://assets.artistfirst.in/uploads/1715789262935-FanTV.png\")),\n            ctx\n        );\n\n        let (token_policy, token_policy_cap) = token::new_policy<XFANTV>(&coin_treasury, ctx);\n\n        token::add_rule_for_action<XFANTV, SpendCoin>(\n            &mut token_policy,\n            &token_policy_cap,\n            token::spend_action(),\n            ctx\n        );\n\n        token::share_policy<XFANTV>(token_policy);\n        transfer::public_transfer(token_policy_cap, tx_context::sender(ctx));\n        transfer::public_transfer(coin_metadata, tx_context::sender(ctx));\n\n        let super_admin_cap = SuperAdminCap { id: object::new(ctx) };\n        transfer::transfer(super_admin_cap, tx_context::sender(ctx));\n\n        let wallet_cap = WalletCap { id: object::new(ctx) };\n        transfer::transfer(wallet_cap, tx_context::sender(ctx));\n\n        let admins = vector::empty<address>();\n        vector::push_back(&mut admins, tx_context::sender(ctx));\n\n        let admin_cap = AdminCap {\n            id: object::new(ctx),\n            admins,\n        };\n\n        let max_credit = MaxCredit {\n            id: object::new(ctx),\n            amount: 0,\n        };\n\n        transfer::share_object(admin_cap);\n        transfer::share_object(max_credit);\n\n        let coin_store = CoinStore {\n            id: object::new(ctx),\n            coin_treasury,\n        };\n\n        transfer::share_object(coin_store);\n    }\n\n    fun is_admin(\n        admin_cap: &AdminCap,\n        addr: address\n    ): bool {\n        let (is_found, _) = vector::index_of<address>(&admin_cap.admins, &addr);\n        is_found\n    }\n\n    public fun init_wallet(\n        wallet_cap: &WalletCap,\n        beneficiary: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let wallet = Wallet {\n            id: object::new(ctx),\n            beneficiary,\n            amount: 0,\n        };\n        transfer::share_object(wallet);\n    }\n\n    public fun grant_wallet_cap(\n        super_admin_cap: &SuperAdminCap,\n        recipient: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let wallet_cap = WalletCap { id: object::new(ctx) };\n        transfer::transfer(wallet_cap, recipient);\n        event::emit(WalletCapGranted { to_address: recipient });\n    }\n\n    public fun mint_and_transfer(\n        super_admin_cap: &SuperAdminCap,\n        coin_store: &mut CoinStore,\n        amount: u64,\n        beneficiary: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        // Fixing the \"as\" statements and separating the function calls to avoid mutating and accessing the same variable within the same semicolon.\n        let minted_coin = token::mint<XFANTV>(&mut coin_store.coin_treasury, amount, ctx);\n        let transferred_coin = token::transfer<XFANTV>(minted_coin, beneficiary, ctx);\n        let confirmation = token::confirm_with_treasury_cap<XFANTV>(&mut coin_store.coin_treasury, transferred_coin, ctx);\n\n        let token_minted_event = TokenMinted {\n            beneficiary,\n            amount,\n        };\n        event::emit<TokenMinted>(token_minted_event);\n    }\n\n    public fun ern_xft(\n        admin_cap: &AdminCap,\n        max_credit: &MaxCredit,\n        wallet: &mut Wallet,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(is_admin(admin_cap, tx_context::sender(ctx)), 2);\n        assert!(amount < max_credit.amount, 1);\n        wallet.amount = wallet.amount + amount;\n        let event = TokenCredited {\n            beneficiary: wallet.beneficiary,\n            amount,\n        };\n        event::emit<TokenCredited>(event);\n    }\n\n    public fun spnd_xft(\n        token: token::Token<XFANTV>,\n        coin_store: &mut CoinStore,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let token_debited_event = TokenDebited {\n            spender: tx_context::sender(ctx),\n            amount: token::value(&token),\n        };\n        event::emit(token_debited_event);\n\n        let spent_token = token::spend(token, ctx);\n        let spend_coin = SpendCoin { dummy_field: false };\n\n        token::add_approval(spend_coin, &mut spent_token, ctx);\n        let (_, _, _, _) = token::confirm_with_treasury_cap(&mut coin_store.coin_treasury, spent_token, ctx);\n    }\n\n    public fun claim_token(\n        wallet: &mut Wallet,\n        coin_store: &mut CoinStore,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(wallet.amount > 0, 0);\n\n        let token_minted_event = TokenMinted {\n            beneficiary: wallet.beneficiary,\n            amount: wallet.amount,\n        };\n        event::emit(token_minted_event);\n\n        wallet.amount = 0;\n\n        // Fixing the \"as\" statements by wrapping them in parentheses\n        let mint_amount = wallet.amount;\n        let treasury_cap = &mut coin_store.coin_treasury;\n        let minted_token = token::mint<XFANTV>(treasury_cap, mint_amount, ctx);\n        let transferred_token = token::transfer<XFANTV>(minted_token, wallet.beneficiary, ctx);\n\n        // Fixing the mutation issue by assigning variables to each parameter\n        token::confirm_with_treasury_cap<XFANTV>(\n            treasury_cap,\n            transferred_token,\n            ctx\n        );\n    }\n\n    public fun update_max_credit(\n        _super_admin_cap: &SuperAdminCap,\n        new_amount: u64,\n        max_credit: &mut MaxCredit\n    ) {\n        max_credit.amount = new_amount;\n    }\n\n    public fun add_admin(\n        admin_cap: &mut AdminCap,\n        new_admin: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(is_admin(admin_cap, tx_context::sender(ctx)), 2);\n        vector::push_back(&mut admin_cap.admins, new_admin);\n        event::emit(AdminAdded { admin: new_admin });\n    }\n\n    public fun remove_admin(\n        admin_cap: &mut AdminCap,\n        admin_to_remove: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(is_admin(admin_cap, tx_context::sender(ctx)), 2);\n        assert!(is_admin(admin_cap, admin_to_remove), 2);\n        \n        let (_, index) = vector::index_of<address>(&admin_cap.admins, &admin_to_remove);\n        vector::remove<address>(&mut admin_cap.admins, index);\n        \n        event::emit<AdminRemoved>(AdminRemoved {\n            admin: admin_to_remove\n        });\n    }\n}"
}