{
    "vault": "// Decompiled by SuiGPT\nmodule 0x62285e6bf9ce841f9bf98b7e3a8e4478e02219135cf2bc1ccaf409ec5883f7b6::vault {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::coin;\n    use sui::tx_context;\n    use sui::transfer;\n    use std::vector;\n    use sui::event;\n\n    // ----- Structs -----\n\n    struct AdminCap has store, key {\n        id: object::UID,\n        vault_id: object::ID,\n    }\n\n    struct FlashLoanEvent<phantom T0> has copy, drop {\n        loan_amount: u64,\n        repay_amount: u64,\n        repay_actual: u64,\n    }\n\n    struct Receipt<phantom T0> {\n        vault_id: object::ID,\n        loan_amount: u64,\n        repay_amount: u64,\n    }\n\n    struct Vault<phantom T0> has key {\n        id: object::UID,\n        to_lend: balance::Balance<T0>,\n        fee_fix: u64,\n        fee_bps: u64,\n    }\n\n    // ----- Functions -----\n\n    fun check_admin<T>(vault: &Vault<T>, admin_cap: &AdminCap) {\n        assert!(\n            object::borrow_id(vault) == &admin_cap.vault_id,\n            3\n        );\n    }\n\n    public entry fun create<T>(\n        coin: coin::Coin<T>,\n        param1: u64,\n        param2: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let admin_cap = new<T>(\n            coin::into_balance(coin),\n            param1,\n            param2,\n            ctx\n        );\n        transfer::public_transfer<AdminCap>(admin_cap, tx_context::sender(ctx));\n    }\n\n    public entry fun create_<T>(\n        param1: u64,\n        param2: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let admin_cap = new<T>(\n            balance::zero<T>(),\n            param1,\n            param2,\n            ctx\n        );\n        transfer::public_transfer<AdminCap>(admin_cap, tx_context::sender(ctx));\n    }\n\n    public entry fun deposit<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        coin: coin::Coin<T>\n    ) {\n        check_admin(vault, admin_cap);\n        coin::put(&mut vault.to_lend, coin);\n    }\n\n    public entry fun deposit_<T>(\n        vault: &mut Vault<T>,\n        coin: coin::Coin<T>\n    ) {\n        coin::put(&mut vault.to_lend, coin);\n    }\n\n    public entry fun sends<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        recipients: vector<address>,\n        amounts: vector<u64>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        check_admin(vault, admin_cap);\n        let num_recipients = vector::length(&recipients);\n        let i = 0;\n        assert!(vector::length(&amounts) == num_recipients, 9);\n        let to_lend_balance = &mut vault.to_lend;\n\n        while (i < num_recipients) {\n            let amount = vector::pop_back(&mut amounts);\n            assert!(balance::value(to_lend_balance) >= amount, 4);\n            transfer::public_transfer(\n                coin::take(to_lend_balance, amount, ctx),\n                vector::pop_back(&mut recipients)\n            );\n            i = i + 1;\n        };\n    }\n\n    public entry fun update_fee<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        new_fee_fix: u64,\n        new_fee_bps: u64\n    ) {\n        check_admin(vault, admin_cap);\n        vault.fee_fix = new_fee_fix;\n        vault.fee_bps = new_fee_bps;\n    }\n\n    public entry fun ww<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let coin = withdraw<T>(vault, admin_cap, amount, ctx);\n        transfer::public_transfer(coin, tx_context::sender(ctx));\n    }\n\n    public fun new<T>(\n        to_lend: balance::Balance<T>,\n        fee_fix: u64,\n        fee_bps: u64,\n        ctx: &mut tx_context::TxContext\n    ): AdminCap {\n        assert!(fee_bps >= 0 && fee_bps < 10000, 5);\n\n        let vault_id = object::new(ctx);\n        let vault = Vault<T> {\n            id: vault_id,\n            to_lend,\n            fee_fix,\n            fee_bps,\n        };\n\n        transfer::share_object(vault);\n\n        AdminCap {\n            id: object::new(ctx),\n            vault_id: object::uid_to_inner(&vault_id),\n        }\n    }\n\n    public fun loan<T>(\n        vault: &mut Vault<T>,\n        loan_amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): (coin::Coin<T>, Receipt<T>) {\n        let to_lend = &mut vault.to_lend;\n        assert!(balance::value(to_lend) >= loan_amount, 0);\n\n        let receipt = Receipt<T> {\n            vault_id: object::id(vault),\n            loan_amount,\n            repay_amount: loan_amount + (loan_amount / 10000 * vault.fee_bps) + vault.fee_fix,\n        };\n\n        (coin::take(to_lend, loan_amount, ctx), receipt)\n    }\n\n    public fun loan_<T>(\n        vault: &mut Vault<T>,\n        loan_amount: u64\n    ): (balance::Balance<T>, Receipt<T>) {\n        let to_lend = &mut vault.to_lend;\n        assert!(balance::value(to_lend) >= loan_amount, 0);\n\n        let receipt = Receipt<T> {\n            vault_id: object::id(vault),\n            loan_amount,\n            repay_amount: loan_amount + (loan_amount / 10000 * vault.fee_bps) + vault.fee_fix,\n        };\n\n        (balance::split(to_lend, loan_amount), receipt)\n    }\n\n    public fun repay<T>(\n        vault: &mut Vault<T>,\n        repayment_coin: coin::Coin<T>,\n        receipt: Receipt<T>\n    ) {\n        let Receipt {\n            vault_id,\n            loan_amount,\n            repay_amount,\n        } = receipt;\n\n        assert!(object::id(vault) == vault_id, 2);\n\n        let actual_repay_amount = coin::value(&repayment_coin);\n        assert!(actual_repay_amount >= repay_amount, 1);\n\n        coin::put(&mut vault.to_lend, repayment_coin);\n\n        let event = FlashLoanEvent<T> {\n            loan_amount,\n            repay_amount,\n            repay_actual: actual_repay_amount,\n        };\n\n        event::emit(event);\n    }\n\n    public fun repay_<T>(\n        vault: &mut Vault<T>,\n        repay_balance: balance::Balance<T>,\n        receipt: Receipt<T>\n    ) {\n        let Receipt {\n            vault_id,\n            loan_amount,\n            repay_amount,\n        } = receipt;\n\n        assert!(object::id(vault) == vault_id, 2);\n\n        let repay_actual = balance::value(&repay_balance);\n        assert!(repay_actual >= repay_amount, 1);\n\n        balance::join(&mut vault.to_lend, repay_balance);\n\n        event::emit(FlashLoanEvent<T> {\n            loan_amount,\n            repay_amount,\n            repay_actual,\n        });\n    }\n\n    public fun withdraw<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        check_admin(vault, admin_cap);\n        let to_lend_balance = &mut vault.to_lend;\n        assert!(balance::value(to_lend_balance) >= amount, 4);\n        coin::take(to_lend_balance, amount, ctx)\n    }\n\n    public fun fee<T>(vault: &Vault<T>): (u64, u64) {\n        (vault.fee_fix, vault.fee_bps)\n    }\n\n    public fun max_loan<T>(vault: &Vault<T>): u64 {\n        balance::value(&vault.to_lend)\n    }\n\n    public fun repay_amount<T>(receipt: &Receipt<T>): u64 {\n        receipt.repay_amount\n    }\n\n    public fun loan_amount<T>(receipt: &Receipt<T>): u64 {\n        receipt.loan_amount\n    }\n\n    public fun vault_id<T>(receipt: &Receipt<T>): object::ID {\n        receipt.vault_id\n    }\n\n    public fun limit_tansfer_coin<T>(\n        coin: coin::Coin<T>,\n        min_value: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(coin::value(&coin) >= min_value, 10);\n        transfer::public_transfer(coin, tx_context::sender(ctx));\n    }\n}"
}