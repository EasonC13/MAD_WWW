{
    "referral_vault": "// Decompiled by SuiGPT\nmodule 0xc66fabf1a9253e43c70f1cc02d40a1d18db183140ecaae2a3f58fa6b66c55acf::referral_vault {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::table;\n    use sui::bag;\n    use sui::tx_context;\n    use sui::transfer;\n    use std::type_name;\n    use sui::balance;\n    use sui::coin;\n    use std::option;\n\n    // ----- Structs -----\n\n    struct ReferralVault has key {\n        id: object::UID,\n        version: u64,\n        referrer_addresses: table::Table<address, address>,\n        rebates: table::Table<address, bag::Bag>,\n    }\n\n    // ----- Functions -----\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let referral_vault = ReferralVault {\n            id: object::new(ctx),\n            version: 1,\n            referrer_addresses: table::new<address, address>(ctx),\n            rebates: table::new<address, bag::Bag>(ctx),\n        };\n        transfer::share_object(referral_vault);\n    }\n\n    public fun has_referrer(\n        referral_vault: &ReferralVault,\n        address: address\n    ): bool {\n        table::contains<address, address>(&referral_vault.referrer_addresses, address)\n    }\n\n    public fun referrer_for(\n        vault: &ReferralVault,\n        user: address\n    ): option::Option<address> {\n        if (has_referrer(vault, user)) {\n            option::some(\n                *table::borrow<address, address>(&vault.referrer_addresses, user)\n            )\n        } else {\n            option::none<address>()\n        }\n    }\n\n    public fun referrer_has_rebate(\n        referral_vault: &ReferralVault,\n        referrer: address\n    ): bool {\n        table::contains<address, bag::Bag>(&referral_vault.rebates, referrer)\n    }\n\n    public fun referrer_has_rebate_with_type<T>(\n        vault: &ReferralVault,\n        referrer: address\n    ): bool {\n        referrer_has_rebate(vault, referrer) && \n        bag::contains<type_name::TypeName>(\n            table::borrow<address, bag::Bag>(&vault.rebates, referrer),\n            type_name::get<T>()\n        )\n    }\n\n    public fun balance_of<T>(\n        vault: &ReferralVault,\n        referrer: address\n    ): u64 {\n        let type_name = type_name::get<T>();\n        \n        if (!referrer_has_rebate(vault, referrer)) {\n            return 0;\n        };\n\n        let rebates_bag = table::borrow<address, bag::Bag>(&vault.rebates, referrer);\n        \n        if (!bag::contains<type_name::TypeName>(rebates_bag, type_name)) {\n            return 0;\n        };\n\n        balance::value<T>(\n            bag::borrow<type_name::TypeName, balance::Balance<T>>(rebates_bag, type_name)\n        )\n    }\n\n    public fun update_referrer_address(\n        vault: &mut ReferralVault,\n        new_referrer: address,\n        ctx: &tx_context::TxContext\n    ) {\n        assert_version(vault);\n        let sender = tx_context::sender(ctx);\n        assert!(sender != new_referrer, 2);\n\n        if (!has_referrer(vault, sender)) {\n            table::add(&mut vault.referrer_addresses, sender, new_referrer);\n        } else {\n            let current_referrer = *table::borrow(&vault.referrer_addresses, sender);\n            if (current_referrer != new_referrer) {\n                *table::borrow_mut(&mut vault.referrer_addresses, sender) = new_referrer;\n            };\n        };\n    }\n\n    public fun deposit_rebate<T>(\n        vault: &mut ReferralVault,\n        rebate_coin: coin::Coin<T>,\n        referrer: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert_version(vault);\n        let coin_type = type_name::get<T>();\n\n        if (!referrer_has_rebate(vault, referrer)) {\n            table::add<address, bag::Bag>(&mut vault.rebates, referrer, bag::new(ctx));\n        };\n\n        let rebate_bag = table::borrow_mut<address, bag::Bag>(&mut vault.rebates, referrer);\n\n        if (!bag::contains<type_name::TypeName>(rebate_bag, coin_type)) {\n            bag::add<type_name::TypeName, balance::Balance<T>>(\n                rebate_bag,\n                coin_type,\n                coin::into_balance(rebate_coin)\n            );\n        } else {\n            balance::join<T>(\n                bag::borrow_mut<type_name::TypeName, balance::Balance<T>>(rebate_bag, coin_type),\n                coin::into_balance(rebate_coin)\n            );\n        };\n    }\n\n    public fun withdraw_rebate<T>(\n        vault: &mut ReferralVault,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        assert_version(vault);\n        let sender = tx_context::sender(ctx);\n        assert!(referrer_has_rebate_with_type<T>(vault, sender), 1);\n        let rebate_bag = table::borrow_mut<address, bag::Bag>(&mut vault.rebates, sender);\n        let rebate_balance = bag::remove<type_name::TypeName, balance::Balance<T>>(rebate_bag, type_name::get<T>());\n        coin::from_balance(rebate_balance, ctx)\n    }\n\n    public fun withdraw_and_transfer<T>(\n        vault: &mut ReferralVault,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let rebate = withdraw_rebate<T>(vault, ctx);\n        transfer::public_transfer(rebate, tx_context::sender(ctx));\n    }\n\n    public fun assert_version(vault: &ReferralVault) {\n        assert!(vault.version == 1, 0);\n    }\n}"
}