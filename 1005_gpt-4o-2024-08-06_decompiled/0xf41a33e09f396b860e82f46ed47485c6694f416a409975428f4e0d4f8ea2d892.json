{
    "coin_flip": "// Decompiled by MAD\nmodule 0xf41a33e09f396b860e82f46ed47485c6694f416a409975428f4e0d4f8ea2d892::coin_flip {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::table;\n    use sui::tx_context;\n    use sui::transfer;\n    use sui::package;\n    use std::vector;\n    use sui::dynamic_field;\n    use sui::bls12381;\n    use sui::hash;\n    use sui::coin;\n    use sui::event;\n    use sui::clock;\n\n    // ----- Structs -----\n\n    struct AdminCap has store, key {\n        id: object::UID,\n    }\n\n    struct COIN_FLIP has drop {\n        dummy_field: bool,\n    }\n\n    struct Game<phantom T0> has store, key {\n        id: object::UID,\n        player: address,\n        total_stake: balance::Balance<T0>,\n        guess: u8,\n        seed: vector<u8>,\n        timestamp: u64,\n    }\n\n    struct GameStarted<phantom T0> has copy, drop {\n        game_id: object::ID,\n        player: address,\n        guess: u8,\n        seed: vector<u8>,\n        stake_amount: u64,\n    }\n\n    struct House<phantom T0> has store, key {\n        id: object::UID,\n        verifier: vector<u8>,\n        multiplier: u64,\n        stake_amount_options: table::Table<u64, bool>,\n        balance: balance::Balance<T0>,\n    }\n\n    struct OutCome<phantom T0> has copy, drop {\n        game_id: object::ID,\n        player: address,\n        result: u8,\n        player_won: bool,\n        reward: u64,\n    }\n\n    // ----- Functions -----\n\n    fun compute_house_stake_amount(\n        stake_amount: u64,\n        fee_rate: u64\n    ): u64 {\n        (((stake_amount as u128) * ((fee_rate - 1000000) as u128) / (1000000 as u128)) as u64)\n    }\n\n    fun init(\n        coin_flip: COIN_FLIP,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        transfer::public_transfer(\n            package::claim<COIN_FLIP>(coin_flip, ctx),\n            sender\n        );\n        let admin_cap = AdminCap { id: object::new(ctx) };\n        transfer::transfer(admin_cap, sender);\n    }\n\n    fun new_game<T>(\n        player: address,\n        total_stake: balance::Balance<T>,\n        guess: u8,\n        seed: vector<u8>,\n        timestamp: u64,\n        ctx: &mut tx_context::TxContext\n    ): Game<T> {\n        Game<T> {\n            id: object::new(ctx),\n            player,\n            total_stake,\n            guess,\n            seed,\n            timestamp,\n        }\n    }\n\n    fun new_house<T>(\n        verifier: vector<u8>,\n        multiplier: u64,\n        stake_amount_options: vector<u64>,\n        ctx: &mut tx_context::TxContext\n    ): House<T> {\n        assert!(multiplier >= 1000000, 6);\n\n        let house = House<T> {\n            id: object::new(ctx),\n            verifier,\n            multiplier,\n            stake_amount_options: table::new<u64, bool>(ctx),\n            balance: balance::zero<T>(),\n        };\n\n        let i = 0;\n        while (i < vector::length(&stake_amount_options)) {\n            table::add(\n                &mut house.stake_amount_options,\n                *vector::borrow(&stake_amount_options, i),\n                true\n            );\n            i = i + 1;\n        };\n\n        house\n    }\n\n    public entry fun create_house<T>(\n        admin_cap: &AdminCap,\n        house_name: vector<u8>,\n        fee_rate: u64,\n        game_types: vector<u64>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let house = new_house<T>(house_name, fee_rate, game_types, ctx);\n        transfer::share_object(house);\n    }\n\n    public entry fun finish_game<T>(\n        house: &mut House<T>,\n        game_id: object::ID,\n        signature: vector<u8>,\n        ctx: &mut tx_context::TxContext\n    ): bool {\n        assert_game_exists<T>(house, game_id);\n\n        let Game {\n            id,\n            player,\n            total_stake,\n            guess,\n            seed,\n            timestamp: _,\n        } = dynamic_field::remove<object::ID, Game<T>>(&mut house.id, game_id);\n\n        let stake_value = total_stake;\n        let game_uid = id;\n        let game_uid_bytes = object::uid_to_bytes(&game_uid);\n        vector::append(&mut game_uid_bytes, seed);\n\n        assert!(\n            bls12381::bls12381_min_pk_verify(&signature, &house.verifier, &game_uid_bytes),\n            3\n        );\n\n        object::delete(game_uid);\n\n        let hash = hash::blake2b256(&signature);\n        let result = *vector::borrow(&hash, 0) % 2;\n\n        let reward = if (guess == result) {\n            transfer::public_transfer(\n                coin::from_balance(stake_value, ctx),\n                player\n            );\n            balance::value(&stake_value)\n        } else {\n            balance::join(&mut house.balance, stake_value);\n            0\n        };\n\n        let outcome = OutCome<T> {\n            game_id,\n            player,\n            result,\n            player_won: (guess == result),\n            reward,\n        };\n\n        event::emit(outcome);\n\n        (guess == result)\n    }\n\n    public entry fun remove_stake_amount_option<T>(\n        _admin_cap: &AdminCap,\n        house: &mut House<T>,\n        stake_amount: u64\n    ) {\n        table::remove<u64, bool>(&mut house.stake_amount_options, stake_amount);\n    }\n\n    public entry fun set_multiplier<T>(\n        admin_cap: &AdminCap,\n        house: &mut House<T>,\n        multiplier: u64\n    ) {\n        assert!(multiplier >= 1000000, 6);\n        house.multiplier = multiplier;\n    }\n\n    public entry fun set_stake_amount_option<T>(\n        _admin_cap: &AdminCap,\n        house: &mut House<T>,\n        stake_amount: u64\n    ) {\n        table::add<u64, bool>(&mut house.stake_amount_options, stake_amount, true);\n    }\n\n    public entry fun set_verifier<T>(\n        _admin_cap: &AdminCap,\n        house: &mut House<T>,\n        verifier: vector<u8>\n    ) {\n        house.verifier = verifier;\n    }\n\n    public entry fun start_game<T>(\n        house: &mut House<T>,\n        player_stake: coin::Coin<T>,\n        seed: vector<u8>,\n        guess: u8,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(guess == 0 || guess == 1, 5);\n        assert!(vector::length(&seed) == 1024, 1);\n\n        let player_stake_value = coin::value(&player_stake);\n        assert!(table::contains(&house.stake_amount_options, player_stake_value), 4);\n\n        let house_stake_amount = compute_house_stake_amount(player_stake_value, house.multiplier);\n        assert!(balance::value(&house.balance) >= house_stake_amount, 0);\n\n        let player = tx_context::sender(ctx);\n        let player_stake_balance = coin::into_balance(player_stake);\n\n        balance::join(\n            &mut player_stake_balance,\n            balance::split(&mut house.balance, house_stake_amount)\n        );\n\n        let game = new_game(\n            player,\n            player_stake_balance,\n            guess,\n            seed,\n            clock::timestamp_ms(clock),\n            ctx\n        );\n\n        let game_id = object::id(&game);\n\n        event::emit(GameStarted {\n            game_id,\n            player,\n            guess,\n            seed,\n            stake_amount: player_stake_value,\n        });\n\n        dynamic_field::add(&mut house.id, game_id, game);\n    }\n\n    public entry fun top_up<T>(\n        _admin_cap: &AdminCap,\n        house: &mut House<T>,\n        coin: coin::Coin<T>\n    ) {\n        balance::join(&mut house.balance, coin::into_balance(coin));\n    }\n\n    public entry fun withdraw<T>(\n        admin_cap: &AdminCap,\n        house: &mut House<T>,\n        amount: u64,\n        recipient: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(balance::value(&house.balance) >= amount, 0);\n        let split_balance = balance::split(&mut house.balance, amount);\n        let coin = coin::from_balance(split_balance, ctx);\n        transfer::public_transfer(coin, recipient);\n    }\n\n    public fun borrow_game<T>(\n        house: &House<T>,\n        game_id: object::ID\n    ): &Game<T> {\n        dynamic_field::borrow<object::ID, Game<T>>(&house.id, game_id)\n    }\n\n    public fun player<T>(game: &Game<T>): address {\n        game.player\n    }\n\n    public fun game_guess<T>(game: &Game<T>): u8 {\n        game.guess\n    }\n\n    public fun game_stake_amount<T>(game: &Game<T>): u64 {\n        balance::value(&game.total_stake)\n    }\n\n    public fun game_seed<T>(game: &Game<T>): vector<u8> {\n        game.seed\n    }\n\n    public fun game_exists<T>(\n        house: &House<T>,\n        game_id: object::ID\n    ): bool {\n        dynamic_field::exists_<object::ID>(&house.id, game_id)\n    }\n\n    public fun assert_game_exists<T>(\n        house: &House<T>,\n        game_id: object::ID\n    ) {\n        assert!(game_exists<T>(house, game_id), 2);\n    }\n\n    public fun house_balance<T>(house: &House<T>): u64 {\n        balance::value(&house.balance)\n    }\n}"
}