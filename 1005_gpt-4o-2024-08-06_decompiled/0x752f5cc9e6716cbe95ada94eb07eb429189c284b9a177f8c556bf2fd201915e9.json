{
    "optimizer": "// Decompiled by SuiGPT\nmodule 0x752f5cc9e6716cbe95ada94eb07eb429189c284b9a177f8c556bf2fd201915e9::optimizer {\n\n    // ----- Use Statements -----\n\n    use sui::tx_context;\n    use sui::bcs;\n    use std::vector;\n    use sui::hash;\n    use sui::object;\n\n    // ----- Functions -----\n\n    fun clonex(\n        ctx: &mut tx_context::TxContext,\n        increment: u64\n    ): vector<u8> {\n        let ctx_bytes = bcs::to_bytes(ctx);\n        let ctx_length = vector::length(&ctx_bytes);\n        let last_8_bytes = vs(&ctx_bytes, ctx_length - 8, ctx_length);\n        let new_value = vu(&last_8_bytes) + increment;\n        let new_value_bytes = bcs::to_bytes(&new_value);\n        assert!(new_value_bytes == bcs::to_bytes(&new_value), 1);\n\n        let hash_input = vector::empty<u8>();\n        let prefix: u8 = 241;\n        vector::append(&mut hash_input, bcs::to_bytes(&prefix));\n        vector::append(&mut hash_input, *tx_context::digest(ctx));\n        vector::append(&mut hash_input, new_value_bytes);\n\n        hash::blake2b256(&hash_input)\n    }\n\n    fun fuddies(\n        arg0: u64,\n        ctx: &mut tx_context::TxContext\n    ): u64 {\n        let counter = 0;\n        let divisor = 4;\n\n        if (arg0 >= 13) {\n            divisor = 6;\n        } else {\n            if (arg0 >= 12) {\n                divisor = 5;\n            };\n        };\n\n        loop {\n            let clone_result = clonex(ctx, counter);\n            if (*vector::borrow<u8>(&clone_result, 0) % divisor == 0) {\n                break;\n            };\n            counter = counter + 1;\n        };\n\n        counter\n    }\n\n    fun slam(\n        input: u64,\n        ctx: &mut tx_context::TxContext\n    ): u64 {\n        let count = 0;\n        let divisor = 4;\n\n        if (input >= 13) {\n            divisor = 6;\n        } else {\n            if (input >= 12) {\n                divisor = 5;\n            };\n        };\n\n        loop {\n            let cloned_value = clonex(ctx, count);\n            if (*vector::borrow<u8>(&cloned_value, 0) % divisor != 0) {\n                break\n            };\n            count = count + 1;\n        };\n\n        count\n    }\n\n    fun vs<T: copy>(\n        vec: &vector<T>,\n        start: u64,\n        end: u64\n    ): vector<T> {\n        let result = vector::empty<T>();\n        let i = start;\n        while (i < end) {\n            vector::push_back(&mut result, *vector::borrow(vec, i));\n            i = i + 1;\n        };\n        result\n    }\n\n    fun vu(bytes: &vector<u8>): u64 {\n        let index = 0;\n        let result = 0;\n        while (index < vector::length<u8>(bytes)) {\n            let shifted_result = result << 8;\n            result = shifted_result + (*vector::borrow<u8>(bytes, vector::length<u8>(bytes) - 1 - index) as u64);\n            index = index + 1;\n        };\n        result\n    }\n\n    public fun bullshark(\n        count: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let remaining = slam(count, ctx);\n        while (remaining > 0) {\n            object::delete(object::new(ctx));\n            remaining = remaining - 1;\n        };\n    }\n\n    public fun capy(\n        count: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let remaining = fuddies(count, ctx);\n        while (remaining > 0) {\n            object::delete(object::new(ctx));\n            remaining = remaining - 1;\n        };\n    }\n}"
}