{
    "oracle": "// Decompiled by MAD\nmodule 0xca441b44943c16be0e6e23c5a955bb971537ea3289ae8016fbf33fffe1fd210f::oracle {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::table;\n    use sui::tx_context;\n    use sui::transfer;\n    use sui::clock;\n    use std::vector;\n\n    // ----- Structs -----\n\n    struct OracleAdminCap has store, key {\n        id: object::UID,\n    }\n\n    struct OracleFeederCap has store, key {\n        id: object::UID,\n    }\n\n    struct Price has store {\n        value: u256,\n        decimal: u8,\n        timestamp: u64,\n    }\n\n    struct PriceOracle has key {\n        id: object::UID,\n        version: u64,\n        update_interval: u64,\n        price_oracles: table::Table<u8, Price>,\n    }\n\n    // ----- Functions -----\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let oracle_admin_cap = OracleAdminCap { id: object::new(ctx) };\n        transfer::public_transfer(oracle_admin_cap, tx_context::sender(ctx));\n\n        let oracle_feeder_cap = OracleFeederCap { id: object::new(ctx) };\n        transfer::public_transfer(oracle_feeder_cap, tx_context::sender(ctx));\n\n        let price_oracle = PriceOracle {\n            id: object::new(ctx),\n            version: 1,\n            update_interval: 30000,\n            price_oracles: table::new<u8, Price>(ctx),\n        };\n        transfer::share_object(price_oracle);\n    }\n\n    fun version_verification(oracle: &PriceOracle) {\n        assert!(oracle.version == 1, 50000);\n    }\n\n    public entry fun register_token_price(\n        admin_cap: &OracleAdminCap,\n        clock: &clock::Clock,\n        oracle: &mut PriceOracle,\n        token_id: u8,\n        price_value: u256,\n        decimal: u8\n    ) {\n        version_verification(oracle);\n        let price_oracles = &mut oracle.price_oracles;\n        assert!(!table::contains<u8, Price>(price_oracles, token_id), 50004);\n        let price = Price {\n            value: price_value,\n            decimal,\n            timestamp: clock::timestamp_ms(clock),\n        };\n        table::add<u8, Price>(price_oracles, token_id, price);\n    }\n\n    public entry fun set_update_interval(\n        admin_cap: &OracleAdminCap,\n        price_oracle: &mut PriceOracle,\n        new_interval: u64\n    ) {\n        version_verification(price_oracle);\n        price_oracle.update_interval = new_interval;\n    }\n\n    public entry fun update_token_price(\n        feeder_cap: &OracleFeederCap,\n        clock: &clock::Clock,\n        price_oracle: &mut PriceOracle,\n        token_id: u8,\n        new_price: u256\n    ) {\n        version_verification(price_oracle);\n        let price_oracles = &mut price_oracle.price_oracles;\n        assert!(table::contains<u8, Price>(price_oracles, token_id), 50003);\n        let price_entry = table::borrow_mut<u8, Price>(price_oracles, token_id);\n        price_entry.value = new_price;\n        price_entry.timestamp = clock::timestamp_ms(clock);\n    }\n\n    public entry fun update_token_price_batch(\n        feeder_cap: &OracleFeederCap,\n        clock: &clock::Clock,\n        price_oracle: &mut PriceOracle,\n        token_ids: vector<u8>,\n        prices: vector<u256>\n    ) {\n        version_verification(price_oracle);\n        let length = vector::length(&token_ids);\n        assert!(length == vector::length(&prices), 50002);\n\n        let i = 0;\n        while (i < length) {\n            update_token_price(\n                feeder_cap,\n                clock,\n                price_oracle,\n                *vector::borrow(&token_ids, i),\n                *vector::borrow(&prices, i)\n            );\n            i = i + 1;\n        };\n    }\n\n    public fun get_token_price(\n        clock: &clock::Clock,\n        oracle: &PriceOracle,\n        token_id: u8\n    ): (bool, u256, u8) {\n        version_verification(oracle);\n        let price_oracles = &oracle.price_oracles;\n        assert!(table::contains<u8, Price>(price_oracles, token_id), 50003);\n        let price = table::borrow<u8, Price>(price_oracles, token_id);\n        let is_valid = false;\n        if (price.value > 0 && clock::timestamp_ms(clock) - price.timestamp <= oracle.update_interval) {\n            is_valid = true;\n        };\n        (is_valid, price.value, price.decimal)\n    }\n}"
}