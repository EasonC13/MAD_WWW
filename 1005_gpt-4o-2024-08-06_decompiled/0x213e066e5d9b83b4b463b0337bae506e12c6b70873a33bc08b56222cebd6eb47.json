{
    "collectible": "// Decompiled by MAD\nmodule 0x213e066e5d9b83b4b463b0337bae506e12c6b70873a33bc08b56222cebd6eb47::collectible {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use std::string;\n    use sui::transfer_policy;\n    use sui::dynamic_field;\n    use sui::tx_context;\n    use sui::package;\n    use sui::event;\n    use sui::kiosk;\n\n    // ----- Structs -----\n\n    struct COLLECTIBLE has drop {\n        dummy_field: bool,\n    }\n\n    struct CollectibleMinted has copy, drop {\n        id: object::ID,\n        receiver: address,\n    }\n\n    struct LockProof {\n        id: object::ID,\n    }\n\n    struct MintConfig has store {\n        backend_address: address,\n        max_epoch: u64,\n    }\n\n    struct RedBullCollectible has store, key {\n        id: object::UID,\n        name: string::String,\n        description: string::String,\n        collection: string::String,\n        tier: string::String,\n        timestamp: string::String,\n        lap_time: string::String,\n        image_url: string::String,\n    }\n\n    // ----- Functions -----\n\n    fun get_config(\n        policy: &transfer_policy::TransferPolicy<RedBullCollectible>\n    ): &MintConfig {\n        dynamic_field::borrow<string::String, MintConfig>(\n            transfer_policy::uid<RedBullCollectible>(policy),\n            string::utf8(b\"MINT_CONFIG\")\n        )\n    }\n\n    fun init(\n        collectible: COLLECTIBLE,\n        ctx: &mut tx_context::TxContext\n    ) {\n        package::claim_and_keep<COLLECTIBLE>(collectible, ctx);\n    }\n\n    public fun mint_collectible(\n        transfer_policy: &transfer_policy::TransferPolicy<RedBullCollectible>,\n        name: string::String,\n        description: string::String,\n        collection: string::String,\n        tier: string::String,\n        timestamp: string::String,\n        lap_time: string::String,\n        image_url: string::String,\n        receiver: address,\n        ctx: &mut tx_context::TxContext\n    ): (RedBullCollectible, LockProof) {\n        let config = get_config(transfer_policy);\n        assert!(config.backend_address == tx_context::sender(ctx), 1);\n        assert!(tx_context::epoch(ctx) <= config.max_epoch, 2);\n\n        let collectible_id = object::new(ctx);\n        event::emit<CollectibleMinted>(CollectibleMinted {\n            id: object::uid_to_inner(&collectible_id),\n            receiver\n        });\n\n        let collectible = RedBullCollectible {\n            id: collectible_id,\n            name,\n            description,\n            collection,\n            tier,\n            timestamp,\n            lap_time,\n            image_url\n        };\n\n        let lock_proof = LockProof {\n            id: object::uid_to_inner(&collectible_id)\n        };\n\n        (collectible, lock_proof)\n    }\n\n    public fun prove_locked(\n        proof: LockProof,\n        kiosk: &kiosk::Kiosk\n    ) {\n        let LockProof { id } = proof;\n        assert!(kiosk::is_locked(kiosk, id), 3);\n    }\n\n    public fun install(\n        policy: &mut transfer_policy::TransferPolicy<RedBullCollectible>,\n        policy_cap: &transfer_policy::TransferPolicyCap<RedBullCollectible>,\n        backend_address: address,\n        max_epoch: u64\n    ) {\n        let config = MintConfig {\n            backend_address,\n            max_epoch,\n        };\n        dynamic_field::add<string::String, MintConfig>(\n            transfer_policy::uid_mut_as_owner<RedBullCollectible>(policy, policy_cap),\n            string::utf8(b\"MINT_CONFIG\"),\n            config\n        );\n    }\n}",
    "permanent_lock": "// Decompiled by MAD\nmodule 0x213e066e5d9b83b4b463b0337bae506e12c6b70873a33bc08b56222cebd6eb47::permanent_lock {\n\n    // ----- Use Statements -----\n\n    use sui::transfer_policy;\n\n    // ----- Structs -----\n\n    struct PermanentLock has drop {\n        dummy_field: bool,\n    }\n\n    struct PermanentLockConfig has drop, store {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    public fun add<T>(\n        policy: &mut transfer_policy::TransferPolicy<T>,\n        cap: &transfer_policy::TransferPolicyCap<T>\n    ) {\n        let lock = PermanentLock { dummy_field: false };\n        let config = PermanentLockConfig { dummy_field: false };\n        transfer_policy::add_rule<T, PermanentLock, PermanentLockConfig>(lock, policy, cap, config);\n    }\n}"
}