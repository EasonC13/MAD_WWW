{
    "SupraSValueFeed": "// Decompiled by MAD\nmodule 0x5d8fbbf6f908a4af8c6d072669a462d53e03eb3c1d863bd0359dc818c69ea706::SupraSValueFeed {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::table;\n    use std::vector;\n    use sui::tx_context;\n    use sui::transfer;\n    use sui::hash;\n    use sui::bcs;\n    use sui::bls12381;\n\n    // ----- Structs -----\n\n    struct CoherentCluster has copy, drop {\n        data_hash: vector<u8>,\n        pair: vector<u32>,\n        prices: vector<u128>,\n        timestamp: vector<u128>,\n        decimals: vector<u16>,\n    }\n\n    struct DkgState has store, key {\n        id: object::UID,\n        public_key: vector<u8>,\n    }\n\n    struct Entry has copy, drop, store {\n        value: u128,\n        decimal: u16,\n        timestamp: u128,\n        round: u64,\n    }\n\n    struct MinBatch has drop {\n        protocol: vector<u8>,\n        txn_hashes: vector<vector<u8>>,\n    }\n\n    struct MinBlock has drop {\n        round: vector<u8>,\n        timestamp: vector<u8>,\n        author: vector<u8>,\n        qc_hash: vector<u8>,\n        batch_hashes: vector<vector<u8>>,\n    }\n\n    struct MinTxn has drop {\n        cluster_hashes: vector<vector<u8>>,\n        sender: vector<u8>,\n        protocol: vector<u8>,\n        tx_sub_type: u8,\n    }\n\n    struct OracleHolder has store, key {\n        id: object::UID,\n        version: u64,\n        owner: object::ID,\n        feeds: table::Table<u32, Entry>,\n    }\n\n    struct Origin has drop {\n        id: vector<u8>,\n        member_index: u64,\n        committee_index: u64,\n    }\n\n    struct OwnerCap has key {\n        id: object::UID,\n    }\n\n    struct Price has drop {\n        pair: u32,\n        value: u128,\n        decimal: u16,\n        timestamp: u128,\n        round: u64,\n    }\n\n    struct SCCProcessedEvent has copy, drop {\n        hash: vector<u8>,\n    }\n\n    struct SignedCoherentCluster has drop {\n        cc: CoherentCluster,\n        qc: vector<u8>,\n        round: u64,\n        origin: Origin,\n    }\n\n    struct Vote has drop {\n        smr_block: MinBlock,\n        round: u64,\n    }\n\n    // ----- Functions -----\n\n    fun batch_verification(\n        min_batch: &MinBatch,\n        batch_hashes: &vector<vector<u8>>,\n        index: u64\n    ): bool {\n        let min_batch_hash = hash_min_batch(min_batch);\n        *vector::borrow(batch_hashes, index) == min_batch_hash\n    }\n\n    fun create_dkg_state(\n        public_key: vector<u8>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let dkg_state = DkgState {\n            id: object::new(ctx),\n            public_key,\n        };\n        transfer::freeze_object(dkg_state);\n    }\n\n    fun create_oracle_holder(\n        ctx: &mut tx_context::TxContext,\n        owner_cap: &OwnerCap\n    ) {\n        let oracle_holder = OracleHolder {\n            id: object::new(ctx),\n            version: 1,\n            owner: object::id(owner_cap),\n            feeds: table::new<u32, Entry>(ctx),\n        };\n        transfer::share_object(oracle_holder);\n    }\n\n    fun create_owner(\n        owner_cap: OwnerCap,\n        ctx: &mut tx_context::TxContext\n    ) {\n        transfer::transfer(owner_cap, tx_context::sender(ctx));\n    }\n\n    fun hash_min_batch(min_batch: &MinBatch): vector<u8> {\n        let data = b\"\";\n        vector_flatten_concate(&mut data, min_batch.txn_hashes);\n        let protocol = min_batch.protocol;\n        vector::append(&mut protocol, hash::keccak256(&data));\n        hash::keccak256(&protocol)\n    }\n\n    fun hash_min_txn(min_txn: &MinTxn): vector<u8> {\n        let data = b\"\";\n        vector_flatten_concate(&mut data, min_txn.cluster_hashes);\n        vector::append(&mut data, min_txn.sender);\n        vector::append(&mut data, min_txn.protocol);\n        \n        let tx_sub_type_vec = vector::empty<u8>();\n        vector::push_back(&mut tx_sub_type_vec, min_txn.tx_sub_type);\n        vector::append(&mut data, tx_sub_type_vec);\n        \n        hash::keccak256(&data)\n    }\n\n    fun hash_scc(scc: &SignedCoherentCluster): vector<u8> {\n        let scc_bytes = bcs::to_bytes<SignedCoherentCluster>(scc);\n        hash::keccak256(&scc_bytes)\n    }\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let owner_cap = OwnerCap { id: object::new(ctx) };\n        create_oracle_holder(ctx, &owner_cap);\n        create_owner(owner_cap, ctx);\n    }\n\n    fun new_min_batch(\n        protocol: vector<u8>,\n        txn_hashes: vector<vector<u8>>\n    ): MinBatch {\n        MinBatch {\n            protocol,\n            txn_hashes,\n        }\n    }\n\n    fun new_min_txn(\n        cluster_hashes: vector<vector<u8>>,\n        sender: vector<u8>,\n        protocol: vector<u8>,\n        tx_sub_type: u8\n    ): MinTxn {\n        MinTxn {\n            cluster_hashes,\n            sender,\n            protocol,\n            tx_sub_type\n        }\n    }\n\n    fun new_scc(\n        data_hash: vector<u8>,\n        pair: vector<u32>,\n        prices: vector<u128>,\n        timestamp: vector<u128>,\n        decimals: vector<u16>,\n        qc: vector<u8>,\n        round: u64,\n        origin_id: vector<u8>,\n        member_index: u64,\n        committee_index: u64\n    ): SignedCoherentCluster {\n        let cc = CoherentCluster {\n            data_hash,\n            pair,\n            prices,\n            timestamp,\n            decimals,\n        };\n        let origin = Origin {\n            id: origin_id,\n            member_index,\n            committee_index,\n        };\n        SignedCoherentCluster {\n            cc,\n            qc,\n            round,\n            origin,\n        }\n    }\n\n    fun new_vote(\n        round: vector<u8>,\n        timestamp: vector<u8>,\n        author: vector<u8>,\n        qc_hash: vector<u8>,\n        batch_hashes: vector<vector<u8>>,\n        vote_round: u64\n    ): Vote {\n        let smr_block = MinBlock {\n            round,\n            timestamp,\n            author,\n            qc_hash,\n            batch_hashes,\n        };\n        Vote {\n            smr_block,\n            round: vote_round,\n        }\n    }\n\n    fun scc_verification(\n        scc: &SignedCoherentCluster,\n        scc_hashes: &vector<vector<u8>>,\n        index: u64\n    ): bool {\n        let scc_hash = hash_scc(scc);\n        vector::borrow(scc_hashes, index) == &scc_hash\n    }\n\n    fun smr_hash_vote(vote: &Vote): vector<u8> {\n        let data = b\"\";\n        vector_flatten_concate(&mut data, vote.smr_block.batch_hashes);\n\n        let smr_block_data = vote.smr_block.round;\n        vector::append(&mut smr_block_data, vote.smr_block.timestamp);\n        vector::append(&mut smr_block_data, vote.smr_block.author);\n        vector::append(&mut smr_block_data, vote.smr_block.qc_hash);\n        vector::append(&mut smr_block_data, hash::keccak256(&mut data));\n\n        let hash = hash::keccak256(&smr_block_data);\n        vector::append(&mut hash, bcs::to_bytes(&vote.round));\n\n        hash::keccak256(&hash)\n    }\n\n    fun transaction_verification(\n        txn: &MinTxn,\n        signatures: &vector<vector<u8>>,\n        index: u64\n    ): bool {\n        let txn_hash = hash_min_txn(txn);\n        vector::borrow(signatures, index) == &txn_hash\n    }\n\n    fun update_price(\n        oracle_holder: &mut OracleHolder,\n        signed_cluster: SignedCoherentCluster\n    ) {\n        let cluster = signed_cluster.cc;\n        let index = 0;\n        while (index < vector::length<u32>(&cluster.pair)) {\n            let pair_id = *vector::borrow<u32>(&cluster.pair, index);\n            let timestamp = *vector::borrow<u128>(&cluster.timestamp, index);\n            let entry = Entry {\n                value: *vector::borrow<u128>(&cluster.prices, index),\n                decimal: *vector::borrow<u16>(&cluster.decimals, index),\n                timestamp,\n                round: signed_cluster.round,\n            };\n            if (table::contains<u32, Entry>(&oracle_holder.feeds, pair_id)) {\n                let existing_entry = table::borrow_mut<u32, Entry>(&mut oracle_holder.feeds, pair_id);\n                if (existing_entry.timestamp < timestamp) {\n                    *existing_entry = entry;\n                };\n            } else {\n                table::add<u32, Entry>(&mut oracle_holder.feeds, pair_id, entry);\n            };\n            index = index + 1;\n        };\n    }\n\n    fun vector_flatten_concate<T: copy + drop>(\n        target: &mut vector<T>,\n        source: vector<vector<T>>\n    ) {\n        let index = 0;\n        while (index < vector::length(&source)) {\n            vector::append(target, *vector::borrow(&source, index));\n            index = index + 1;\n        };\n    }\n\n    fun verify_signature(\n        message: vector<u8>,\n        public_key: vector<u8>,\n        signature: vector<u8>\n    ): bool {\n        bls12381::bls12381_min_sig_verify(&signature, &message, &public_key)\n    }\n\n    fun vote_verification(\n        signature: vector<u8>,\n        vote: &Vote,\n        public_key: vector<u8>\n    ): bool {\n        verify_signature(signature, smr_hash_vote(vote), public_key)\n    }\n\n    public fun get_price(\n        oracle_holder: &OracleHolder,\n        feed_id: u32\n    ): (u128, u16, u128, u64) {\n        assert!(oracle_holder.version == 1, 21);\n        if (!table::contains<u32, Entry>(&oracle_holder.feeds, feed_id)) {\n            abort 11;\n        };\n        let entry = table::borrow<u32, Entry>(&oracle_holder.feeds, feed_id);\n        (entry.value, entry.decimal, entry.timestamp, entry.round)\n    }\n\n    public fun get_prices(\n        oracle_holder: &OracleHolder,\n        pairs: vector<u32>\n    ): vector<Price> {\n        assert!(oracle_holder.version == 1, 21);\n        let index = 0;\n        let prices = vector::empty<Price>();\n\n        while (index < vector::length(&pairs)) {\n            let pair = *vector::borrow(&pairs, index);\n            index = index + 1;\n\n            if (!table::contains<u32, Entry>(&oracle_holder.feeds, pair)) {\n                continue;\n            };\n\n            let entry = table::borrow<u32, Entry>(&oracle_holder.feeds, pair);\n            let price = Price {\n                pair,\n                value: entry.value,\n                decimal: entry.decimal,\n                timestamp: entry.timestamp,\n                round: entry.round,\n            };\n\n            vector::push_back(&mut prices, price);\n        };\n\n        prices\n    }\n\n    public fun extract_price(price: &Price): (u32, u128, u16, u128, u64) {\n        (price.pair, price.value, price.decimal, price.timestamp, price.round)\n    }\n}"
}