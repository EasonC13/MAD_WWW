{
    "account_graph": "// Decompiled by SuiGPT\nmodule 0x2461e4bcbc7f92d4d838cc6628afd8361d7ebb80eb11d1d4f249134db27a7756::account_graph {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use std::string;\n    use std::option;\n    use sui::table;\n    use sui::vec_set;\n    use sui::tx_context;\n    use sui::event;\n    use sui::vec_map;\n    use std::vector;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct AccountGraph<phantom T0: copy + drop + store, phantom T1: copy + drop + store> has store, key {\n        id: object::UID,\n        description: string::String,\n        max_out_degree: option::Option<u32>,\n        relationships: table::Table<address, vec_set::VecSet<address>>,\n        account_props: table::Table<address, T0>,\n        relationship_props: table::Table<RelationshipKey, T1>,\n    }\n\n    struct AccountPropsSet<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        node: address,\n        props: T0,\n    }\n\n    struct AccountPropsUnset<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        node: address,\n        props: T0,\n    }\n\n    struct EmptyProp has copy, drop, store {\n        dummy_field: bool,\n    }\n\n    struct GraphCreated has copy, drop {\n        graph_id: object::ID,\n    }\n\n    struct RelationshipAdded has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n    }\n\n    struct RelationshipKey has copy, drop, store {\n        source: address,\n        target: address,\n    }\n\n    struct RelationshipPropsSet<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n        props: T0,\n    }\n\n    struct RelationshipPropsUnset<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n        props: T0,\n    }\n\n    struct RelationshipRemoved has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n    }\n\n    // ----- Functions -----\n\n    fun new<T0: copy + drop + store, T1: copy + drop + store>(\n        description: string::String,\n        max_out_degree: option::Option<u32>,\n        ctx: &mut tx_context::TxContext\n    ): AccountGraph<T0, T1> {\n        let is_valid = if (option::is_none(&max_out_degree)) {\n            true\n        } else {\n            let zero = 0;\n            !option::contains(&max_out_degree, &zero)\n        };\n        assert!(is_valid, 1);\n        AccountGraph<T0, T1> {\n            id: object::new(ctx),\n            description,\n            max_out_degree,\n            relationships: table::new<address, vec_set::VecSet<address>>(ctx),\n            account_props: table::new<address, T0>(ctx),\n            relationship_props: table::new<RelationshipKey, T1>(ctx),\n        }\n    }\n\n    fun relationship_exists<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &AccountGraph<T0, T1>,\n        addr1: address,\n        addr2: address\n    ): bool {\n        table::contains<address, vec_set::VecSet<address>>(&graph.relationships, addr1) &&\n        vec_set::contains<address>(\n            table::borrow<address, vec_set::VecSet<address>>(&graph.relationships, addr1),\n            &addr2\n        )\n    }\n\n    public fun create<T0: copy + drop + store, T1: copy + drop + store>(\n        name: string::String,\n        option: option::Option<u32>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let graph = new<T0, T1>(name, option, ctx);\n        transfer::share_object<AccountGraph<T0, T1>>(graph);\n        let event = GraphCreated {\n            graph_id: object::id(&graph)\n        };\n        event::emit<GraphCreated>(event);\n    }\n\n    public fun add_relationship<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        target: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let relationships = &mut graph.relationships;\n\n        if (table::contains<address, vec_set::VecSet<address>>(relationships, sender)) {\n            let vec_set = table::borrow_mut<address, vec_set::VecSet<address>>(relationships, sender);\n            assert!(\n                option::is_none(&graph.max_out_degree) || \n                vec_set::size(vec_set) < (*option::borrow(&graph.max_out_degree) as u64),\n                0\n            );\n            vec_set::insert(vec_set, target);\n        } else {\n            table::add(relationships, sender, vec_set::singleton(target));\n        };\n\n        event::emit<RelationshipAdded>(RelationshipAdded {\n            graph_id: object::id(graph),\n            source: sender,\n            target,\n        });\n    }\n\n    public fun remove_relationship<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        target: address,\n        ctx: &mut tx_context::TxContext\n    ): (address, option::Option<T1>) {\n        let sender = tx_context::sender(ctx);\n        let relationships = table::borrow_mut<address, vec_set::VecSet<address>>(&mut graph.relationships, sender);\n        vec_set::remove(relationships, &target);\n\n        if (vec_set::size(relationships) == 0) {\n            table::remove<address, vec_set::VecSet<address>>(&mut graph.relationships, sender);\n        };\n\n        event::emit(RelationshipRemoved {\n            graph_id: object::id(graph),\n            source: sender,\n            target,\n        });\n\n        (target, unset_relationship_props(graph, target, ctx))\n    }\n\n    public fun clear_relationships<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        ctx: &mut tx_context::TxContext\n    ): vec_map::VecMap<address, option::Option<T1>> {\n        let sender = tx_context::sender(ctx);\n        let relationships = &mut graph.relationships;\n        let cleared_relationships = vec_map::empty<address, option::Option<T1>>();\n\n        if (!table::contains<address, vec_set::VecSet<address>>(relationships, sender)) {\n            return cleared_relationships;\n        };\n\n        let relationship_set = table::remove<address, vec_set::VecSet<address>>(relationships, sender);\n        let relationship_keys = vec_set::keys(&relationship_set);\n        let index = 0;\n\n        while (index < vector::length(&relationship_keys)) {\n            let target = *vector::borrow(&relationship_keys, index);\n            vec_map::insert(\n                &mut cleared_relationships,\n                target,\n                unset_relationship_props(graph, target, ctx)\n            );\n\n            event::emit(RelationshipRemoved {\n                graph_id: object::id(graph),\n                source: sender,\n                target,\n            });\n\n            index = index + 1;\n        };\n\n        cleared_relationships\n    }\n\n    public fun set_account_props<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        props: T0,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T0> {\n        let sender = tx_context::sender(ctx);\n        let account_props = &mut graph.account_props;\n        let result = if (table::contains<address, T0>(account_props, sender)) {\n            let existing_props = table::borrow_mut<address, T0>(account_props, sender);\n            *existing_props = props;\n            option::some(*existing_props)\n        } else {\n            table::add<address, T0>(account_props, sender, props);\n            option::none<T0>()\n        };\n        event::emit<AccountPropsSet<T0>>(AccountPropsSet {\n            graph_id: object::id(graph),\n            node: sender,\n            props,\n        });\n        result\n    }\n\n    public fun unset_account_props<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T0> {\n        let sender = tx_context::sender(ctx);\n        let account_props = &mut graph.account_props;\n\n        if (table::contains<address, T0>(account_props, sender)) {\n            let props = table::remove<address, T0>(account_props, sender);\n            event::emit<AccountPropsUnset<T0>>(AccountPropsUnset<T0> {\n                graph_id: object::id(graph),\n                node: sender,\n                props,\n            });\n            option::some<T0>(props)\n        } else {\n            option::none<T0>()\n        }\n    }\n\n    public fun set_relationship_props<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        target: address,\n        props: T1,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T1> {\n        let sender = tx_context::sender(ctx);\n        assert!(relationship_exists<T0, T1>(graph, sender, target), 2);\n        let relationship_props = &mut graph.relationship_props;\n        let relationship_key = RelationshipKey {\n            source: sender,\n            target,\n        };\n        let result = if (table::contains<RelationshipKey, T1>(relationship_props, relationship_key)) {\n            let existing_props = table::borrow_mut<RelationshipKey, T1>(relationship_props, relationship_key);\n            *existing_props = props;\n            option::some(*existing_props)\n        } else {\n            table::add<RelationshipKey, T1>(relationship_props, relationship_key, props);\n            option::none<T1>()\n        };\n        event::emit<RelationshipPropsSet<T1>>(RelationshipPropsSet {\n            graph_id: object::id(graph),\n            source: sender,\n            target,\n            props,\n        });\n        result\n    }\n\n    public fun unset_relationship_props<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        target: address,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T1> {\n        let sender = tx_context::sender(ctx);\n        let relationship_props = &mut graph.relationship_props;\n        let relationship_key = RelationshipKey {\n            source: sender,\n            target,\n        };\n\n        if (table::contains<RelationshipKey, T1>(relationship_props, relationship_key)) {\n            let props = table::remove<RelationshipKey, T1>(relationship_props, relationship_key);\n            event::emit<RelationshipPropsUnset<T1>>(RelationshipPropsUnset {\n                graph_id: object::id(graph),\n                source: sender,\n                target,\n                props,\n            });\n            option::some(props)\n        } else {\n            option::none()\n        }\n    }\n}"
}