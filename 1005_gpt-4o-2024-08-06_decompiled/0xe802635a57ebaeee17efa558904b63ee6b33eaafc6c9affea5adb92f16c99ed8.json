{
    "game": "// Decompiled by MAD\nmodule 0xe802635a57ebaeee17efa558904b63ee6b33eaafc6c9affea5adb92f16c99ed8::game {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use std::option;\n    use sui::balance;\n    use sui::sui;\n    use sui::table;\n    use sui::package;\n    use sui::tx_context;\n    use std::string;\n    use sui::zklogin_verified_issuer;\n    use sui::event;\n    use sui::pay;\n    use sui::coin;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct GAME has drop {\n        dummy_field: bool,\n    }\n\n    struct Game has key {\n        id: object::UID,\n        active: bool,\n        prize: option::Option<balance::Balance<sui::SUI>>,\n        taps: u64,\n        taps_per_address: table::Table<address, u64>,\n        winner: option::Option<address>,\n        initial_prize: u64,\n        initial_taps: u64,\n    }\n\n    struct GameCancelled has copy, drop {\n        game: object::ID,\n    }\n\n    struct GameCreated has copy, drop {\n        game: object::ID,\n    }\n\n    struct GameEnded has copy, drop {\n        game: object::ID,\n        winner: address,\n    }\n\n    struct Tapped has copy, drop {\n        game: object::ID,\n        address: address,\n    }\n\n    // ----- Functions -----\n\n    fun assert_admin(publisher: &package::Publisher) {\n        assert!(package::from_module<GAME>(publisher), 0);\n    }\n\n    fun assert_game_is_active(game: &Game) {\n        assert!(game.active, 1);\n    }\n\n    fun assert_sender_zklogin(\n        issuer_id: u256,\n        ctx: &tx_context::TxContext\n    ) {\n        let data = string::utf8(b\"https://accounts.google.com\");\n        assert!(\n            zklogin_verified_issuer::check_zklogin_issuer(\n                tx_context::sender(ctx),\n                issuer_id,\n                &data\n            ),\n            4\n        );\n    }\n\n    fun end(\n        game: &mut Game,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let game_ended_event = GameEnded {\n            game: object::id(game),\n            winner: sender,\n        };\n        event::emit(game_ended_event);\n        game.active = false;\n        game.winner = option::some(sender);\n        pay::keep(\n            coin::from_balance(option::extract(&mut game.prize), ctx),\n            ctx\n        );\n    }\n\n    fun init(\n        game: GAME,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let publisher = package::claim<GAME>(game, ctx);\n        transfer::public_transfer(publisher, tx_context::sender(ctx));\n    }\n\n    fun update_taps_per_address(\n        game: &mut Game,\n        ctx: &tx_context::TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let taps_table = &mut game.taps_per_address;\n\n        if (!table::contains<address, u64>(taps_table, sender)) {\n            table::add<address, u64>(taps_table, sender, 0);\n        };\n\n        let taps_count = table::borrow_mut<address, u64>(taps_table, sender);\n        *taps_count = *taps_count + 1;\n    }\n\n    public fun new(\n        publisher: &package::Publisher,\n        taps: u64,\n        prize_coin: coin::Coin<sui::SUI>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert_admin(publisher);\n        assert!(taps > 0, 3);\n\n        let prize_balance = coin::into_balance(prize_coin);\n        let prize_value = balance::value(&prize_balance);\n        assert!(prize_value > 0, 2);\n\n        let game = Game {\n            id: object::new(ctx),\n            active: true,\n            prize: option::some(prize_balance),\n            taps,\n            taps_per_address: table::new<address, u64>(ctx),\n            winner: option::none(),\n            initial_prize: prize_value,\n            initial_taps: taps,\n        };\n\n        let game_created_event = GameCreated {\n            game: object::id(&game),\n        };\n\n        event::emit(game_created_event);\n        transfer::share_object(game);\n    }\n\n    public fun cancel(\n        publisher: &package::Publisher,\n        game: &mut Game,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert_admin(publisher);\n        assert_game_is_active(game);\n        let game_cancelled_event = GameCancelled {\n            game: object::id(game)\n        };\n        event::emit(game_cancelled_event);\n        end(game, ctx);\n    }\n\n    public fun tap(\n        game: &mut Game,\n        zklogin_address: u256,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert_game_is_active(game);\n        assert_sender_zklogin(zklogin_address, ctx);\n\n        let tapped_event = Tapped {\n            game: object::id(game),\n            address: tx_context::sender(ctx),\n        };\n        event::emit(tapped_event);\n\n        game.taps = game.taps - 1;\n        update_taps_per_address(game, ctx);\n\n        if (game.taps == 0) {\n            end(game, ctx);\n        };\n    }\n\n    public fun get_address_taps(\n        game: &Game,\n        addr: address\n    ): u64 {\n        *table::borrow<address, u64>(&game.taps_per_address, addr)\n    }\n}"
}