{
    "wave_staking": "// Decompiled by MAD\nmodule 0x8d0b43b4adcce0f87c05b86d0059ad07774ebfbb0108396b18fb7aeb6848e672::wave_staking {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::math;\n    use sui::tx_context;\n    use sui::transfer;\n    use sui::clock;\n    use std::string;\n    use sui::bcs;\n    use std::vector;\n    use sui::ed25519;\n    use sui::event;\n    use sui::dynamic_field;\n    use sui::coin;\n\n    // ----- Structs -----\n\n    struct OwnerCap has key {\n        id: object::UID,\n    }\n\n    struct Pool<phantom T0> has store, key {\n        id: object::UID,\n        version: u8,\n        start_at: u64,\n        end_at: u64,\n        lock_duration: u64,\n        total_staked_balance: balance::Balance<T0>,\n        apy: u32,\n        operator_pk: vector<u8>,\n        is_paused: bool,\n    }\n\n    struct PoolCreated has copy, drop {\n        pool_id: object::ID,\n    }\n\n    struct RewardClaimed has copy, drop {\n        pool_id: object::ID,\n        user: address,\n        amount: u64,\n        timestamp_ms: u64,\n    }\n\n    struct Staked has copy, drop {\n        pool_id: object::ID,\n        user: address,\n        amount: u64,\n        timestamp_ms: u64,\n    }\n\n    struct UserInfo has store {\n        stake_amount: u64,\n        pending_reward: u64,\n        lock_at: u64,\n        apy: u32,\n    }\n\n    struct Withdrawn has copy, drop {\n        pool_id: object::ID,\n        user: address,\n        amount: u64,\n        timestamp_ms: u64,\n    }\n\n    // ----- Functions -----\n\n    fun cal_pending_reward(\n        reward_per_second: u64,\n        multiplier: u32,\n        last_reward_time: u64,\n        current_time: u64,\n        end_time: u64,\n        start_time: u64\n    ): u64 {\n        if (start_time != 0 && last_reward_time >= start_time) {\n            return 0;\n        };\n        let start_time_u256 = (start_time as u256);\n        let min_time_u256 = (math::min(last_reward_time + current_time, end_time) as u256);\n        let adjusted_time_u256 = min_time_u256;\n        if (start_time_u256 != 0 && min_time_u256 > start_time_u256) {\n            adjusted_time_u256 = start_time_u256;\n        };\n        (((adjusted_time_u256 - (last_reward_time as u256)) * (reward_per_second as u256) * (multiplier as u256) / 10000 / 31536000000) as u64)\n    }\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let owner_cap = OwnerCap { id: object::new(ctx) };\n        transfer::transfer(owner_cap, tx_context::sender(ctx));\n    }\n\n    fun validate_signature<T>(\n        pool: &Pool<T>,\n        sender: address,\n        amount: u64,\n        expiry: u64,\n        signature: vector<u8>,\n        clock: &clock::Clock\n    ) {\n        let data_prefix_0 = string::utf8(b\"WAVE_STAKING:\");\n        let message = bcs::to_bytes(&data_prefix_0);\n        vector::append(&mut message, bcs::to_bytes(&sender));\n        let data_prefix_1 = string::utf8(b\"-\");\n        vector::append(&mut message, bcs::to_bytes(&data_prefix_1));\n        vector::append(&mut message, bcs::to_bytes(&amount));\n        let data_prefix_2 = string::utf8(b\"-\");\n        vector::append(&mut message, bcs::to_bytes(&data_prefix_2));\n        vector::append(&mut message, bcs::to_bytes(&expiry));\n        assert!(ed25519::ed25519_verify(&signature, &pool.operator_pk, &message) == true, 10);\n        assert!(clock::timestamp_ms(clock) < expiry, 11);\n    }\n\n    public entry fun create_pool<T>(\n        owner_cap: &OwnerCap,\n        start_at: u64,\n        end_at: u64,\n        lock_duration: u64,\n        apy: u32,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let pool_id = object::new(ctx);\n        let operator_address = @0xfdefe17a05a90060ef50ef578992df05f55ee11d31877d0c3010cbe36781f1b0;\n        let pool = Pool<T>{\n            id: pool_id,\n            version: 1,\n            start_at,\n            end_at,\n            lock_duration,\n            total_staked_balance: balance::zero<T>(),\n            apy,\n            operator_pk: bcs::to_bytes(&operator_address),\n            is_paused: false,\n        };\n        transfer::share_object(pool);\n        let pool_created_event = PoolCreated{pool_id: object::uid_to_inner(&pool_id)};\n        event::emit<PoolCreated>(pool_created_event);\n    }\n\n    public entry fun restake<T>(\n        pool: &mut Pool<T>,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(pool.version <= 1, 5);\n        assert!(!pool.is_paused, 9);\n        let sender = tx_context::sender(ctx);\n        assert!(dynamic_field::exists_with_type<address, UserInfo>(&pool.id, sender), 4);\n        let user_info = dynamic_field::borrow_mut<address, UserInfo>(&mut pool.id, sender);\n        let current_timestamp = clock::timestamp_ms(clock);\n        assert!(pool.end_at == 0 || pool.end_at > current_timestamp, 7);\n        assert!(user_info.lock_at + pool.lock_duration <= current_timestamp, 6);\n        user_info.lock_at = current_timestamp;\n        user_info.pending_reward = 0;\n        user_info.apy = pool.apy;\n        let reward_amount = user_info.pending_reward + cal_pending_reward(\n            user_info.stake_amount,\n            user_info.apy,\n            user_info.lock_at,\n            pool.lock_duration,\n            current_timestamp,\n            pool.end_at\n        );\n        let reward_claimed_event = RewardClaimed {\n            pool_id: object::id(pool),\n            user: sender,\n            amount: reward_amount,\n            timestamp_ms: current_timestamp,\n        };\n        event::emit<RewardClaimed>(reward_claimed_event);\n    }\n\n    public entry fun stake<T>(\n        pool: &mut Pool<T>,\n        token: coin::Coin<T>,\n        signature_nonce: u64,\n        signature: vector<u8>,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(pool.version <= 1, 5);\n        assert!(!pool.is_paused, 9);\n        let current_timestamp = clock::timestamp_ms(clock);\n        assert!(pool.end_at == 0 || pool.end_at > current_timestamp, 7);\n        assert!(pool.start_at != 0 && pool.start_at < current_timestamp, 2);\n        let token_value = coin::value(&token);\n        assert!(token_value > 0, 1);\n        let sender = tx_context::sender(ctx);\n        validate_signature<T>(pool, sender, token_value, signature_nonce, signature, clock);\n        if (!dynamic_field::exists_with_type<address, UserInfo>(&pool.id, sender)) {\n            let user_info = UserInfo {\n                stake_amount: 0,\n                pending_reward: 0,\n                lock_at: 0,\n                apy: pool.apy,\n            };\n            dynamic_field::add(&mut pool.id, sender, user_info);\n        };\n        let user_info_mut = dynamic_field::borrow_mut<address, UserInfo>(&mut pool.id, sender);\n        if (user_info_mut.stake_amount > 0) {\n            user_info_mut.pending_reward = user_info_mut.pending_reward + \n                cal_pending_reward(user_info_mut.stake_amount, user_info_mut.apy, user_info_mut.lock_at, pool.lock_duration, current_timestamp, pool.end_at);\n        };\n        user_info_mut.lock_at = current_timestamp;\n        user_info_mut.stake_amount = user_info_mut.stake_amount + token_value;\n        user_info_mut.apy = pool.apy;\n        balance::join(&mut pool.total_staked_balance, coin::into_balance(token));\n        let staked_event = Staked {\n            pool_id: object::id(pool),\n            user: sender,\n            amount: token_value,\n            timestamp_ms: current_timestamp,\n        };\n        event::emit<Staked>(staked_event);\n    }\n\n    public entry fun update_pool_info<T>(\n        owner_cap: &OwnerCap,\n        pool: &mut Pool<T>,\n        start_at: u64,\n        end_at: u64,\n        lock_duration: u64,\n        apy: u32,\n        is_paused: bool,\n    ) {\n        pool.start_at = start_at;\n        pool.end_at = end_at;\n        pool.lock_duration = lock_duration;\n        pool.is_paused = is_paused;\n        pool.apy = apy;\n    }\n\n    public entry fun withdraw<T>(\n        pool: &mut Pool<T>,\n        amount: u64,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(pool.version <= 1, 5);\n        assert!(!pool.is_paused, 9);\n        let sender = tx_context::sender(ctx);\n        assert!(dynamic_field::exists_with_type<address, UserInfo>(&pool.id, sender), 4);\n        let user_info = dynamic_field::borrow_mut<address, UserInfo>(&mut pool.id, sender);\n        let current_timestamp = clock::timestamp_ms(clock);\n        let effective_end_timestamp = if (pool.end_at != 0 && pool.end_at < current_timestamp) {\n            pool.end_at\n        } else {\n            current_timestamp\n        };\n        assert!(user_info.lock_at + pool.lock_duration <= effective_end_timestamp, 6);\n        assert!(amount > 0, 1);\n        assert!(user_info.stake_amount >= amount, 3);\n        let zero_coin = coin::zero<T>(ctx);\n        user_info.stake_amount = user_info.stake_amount - amount;\n        balance::join<T>(\n            coin::balance_mut<T>(&mut zero_coin),\n            balance::split<T>(&mut pool.total_staked_balance, amount)\n        );\n        transfer::public_transfer(zero_coin, sender);\n        user_info.pending_reward = 0;\n        let pool_id = object::id<Pool<T>>(pool);\n        let reward_claimed = RewardClaimed {\n            pool_id,\n            user: sender,\n            amount: user_info.pending_reward + cal_pending_reward(\n                user_info.stake_amount,\n                user_info.apy,\n                user_info.lock_at,\n                pool.lock_duration,\n                current_timestamp,\n                pool.end_at\n            ),\n            timestamp_ms: current_timestamp,\n        };\n        event::emit<RewardClaimed>(reward_claimed);\n        let withdrawn = Withdrawn {\n            pool_id,\n            user: sender,\n            amount,\n            timestamp_ms: current_timestamp,\n        };\n        event::emit<Withdrawn>(withdrawn);\n    }\n\n    entry fun update_operator<T>(\n        owner_cap: &OwnerCap,\n        pool: &mut Pool<T>,\n        operator_pk: vector<u8>,\n    ) {\n        pool.operator_pk = operator_pk;\n    }\n\n    entry fun migrate<T>(\n        owner_cap: &OwnerCap,\n        pool: &mut Pool<T>\n    ) {\n        assert!(pool.version < 1, 8);\n        pool.version = 1;\n    }\n}",
    "wave_staking_nft": "// Decompiled by MAD\nmodule 0x8d0b43b4adcce0f87c05b86d0059ad07774ebfbb0108396b18fb7aeb6848e672::wave_staking_nft {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::math;\n    use sui::tx_context;\n    use sui::transfer;\n    use sui::clock;\n    use std::string;\n    use sui::bcs;\n    use std::vector;\n    use sui::ed25519;\n    use sui::event;\n    use sui::dynamic_field;\n    use sui::dynamic_object_field;\n\n    // ----- Structs -----\n\n    struct NftStaked has copy, drop {\n        pool_id: object::ID,\n        nft_id: object::ID,\n        user: address,\n        timestamp_ms: u64,\n    }\n\n    struct NftWithdrawn has copy, drop {\n        pool_id: object::ID,\n        nft_id: object::ID,\n        user: address,\n        timestamp_ms: u64,\n    }\n\n    struct OwnerCap has key {\n        id: object::UID,\n    }\n\n    struct Pool<phantom T0> has store, key {\n        id: object::UID,\n        version: u8,\n        start_at: u64,\n        end_at: u64,\n        total_staked_nft: u64,\n        lock_duration: u64,\n        operator_pk: vector<u8>,\n        is_paused: bool,\n    }\n\n    struct PoolCreated has copy, drop {\n        pool_id: object::ID,\n    }\n\n    struct RewardClaimed has copy, drop {\n        pool_id: object::ID,\n        user: address,\n        number_nft_staked: u64,\n        reward_from: u64,\n        reward_to: u64,\n        timestamp_ms: u64,\n    }\n\n    struct UserInfo has store {\n        number_nft_staked: u64,\n        nft_ids: vector<object::ID>,\n        lock_at: u64,\n    }\n\n    // ----- Functions -----\n\n    fun get_reward_to(\n        current: u64,\n        reward: u64,\n        max: u64,\n        target: u64\n    ): u64 {\n        if (target != 0 && current >= target) {\n            return current;\n        };\n        let min_reward = math::min(current + reward, max);\n        let adjusted_reward = min_reward;\n        if (target != 0 && min_reward > target) {\n            adjusted_reward = target;\n        };\n        adjusted_reward\n    }\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let owner_cap = OwnerCap { id: object::new(ctx) };\n        transfer::transfer(owner_cap, tx_context::sender(ctx));\n    }\n\n    fun validate_signature<T>(\n        pool: &Pool<T>,\n        sender: address,\n        object_id: object::ID,\n        expiry: u64,\n        signature: vector<u8>,\n        clock: &clock::Clock\n    ) {\n        let data_prefix_0 = string::utf8(b\"WAVE_STAKING_NFT:\");\n        let message = bcs::to_bytes(&data_prefix_0);\n        vector::append(&mut message, bcs::to_bytes(&sender));\n        let data_prefix_1 = string::utf8(b\"-\");\n        vector::append(&mut message, bcs::to_bytes(&data_prefix_1));\n        vector::append(&mut message, object::id_to_bytes(&object_id));\n        let data_prefix_2 = string::utf8(b\"-\");\n        vector::append(&mut message, bcs::to_bytes(&data_prefix_2));\n        vector::append(&mut message, bcs::to_bytes(&expiry));\n        assert!(ed25519::ed25519_verify(&signature, &pool.operator_pk, &message) == true, 10);\n        assert!(clock::timestamp_ms(clock) < expiry, 11);\n    }\n\n    public entry fun create_pool<T>(\n        owner_cap: &OwnerCap,\n        start_at: u64,\n        end_at: u64,\n        lock_duration: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let pool_id = object::new(ctx);\n        let operator_address = @0xfdefe17a05a90060ef50ef578992df05f55ee11d31877d0c3010cbe36781f1b0;\n        let pool = Pool<T>{\n            id: pool_id,\n            version: 1,\n            start_at,\n            end_at,\n            total_staked_nft: 0,\n            lock_duration,\n            operator_pk: bcs::to_bytes(&operator_address),\n            is_paused: false,\n        };\n        transfer::share_object(pool);\n        let pool_created_event = PoolCreated{pool_id: object::uid_to_inner(&pool_id)};\n        event::emit<PoolCreated>(pool_created_event);\n    }\n\n    public entry fun restake<T: store + key>(\n        pool: &mut Pool<T>,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(pool.version <= 1, 5);\n        assert!(!pool.is_paused, 9);\n        let sender = tx_context::sender(ctx);\n        assert!(dynamic_field::exists_with_type<address, UserInfo>(&pool.id, sender), 4);\n        let current_timestamp = clock::timestamp_ms(clock);\n        let user_info = dynamic_field::borrow_mut<address, UserInfo>(&mut pool.id, sender);\n        assert!(pool.end_at == 0 || pool.end_at > current_timestamp, 7);\n        assert!(user_info.lock_at + pool.lock_duration <= current_timestamp, 6);\n        assert!(user_info.number_nft_staked > 0, 12);\n        let previous_lock_at = user_info.lock_at;\n        user_info.lock_at = current_timestamp;\n        let reward_claimed_event = RewardClaimed {\n            pool_id: object::id<Pool<T>>(pool),\n            user: sender,\n            number_nft_staked: user_info.number_nft_staked,\n            reward_from: previous_lock_at,\n            reward_to: get_reward_to(previous_lock_at, pool.lock_duration, current_timestamp, pool.end_at),\n            timestamp_ms: current_timestamp,\n        };\n        event::emit<RewardClaimed>(reward_claimed_event);\n    }\n\n    public entry fun stake<T: store + key>(\n        pool: &mut Pool<T>,\n        nft: T,\n        amount: u64,\n        signature: vector<u8>,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(pool.version <= 1, 5);\n        assert!(!pool.is_paused, 9);\n        let timestamp_ms = clock::timestamp_ms(clock);\n        assert!(pool.end_at == 0 || pool.end_at > timestamp_ms, 7);\n        let pool_id = object::id<Pool<T>>(pool);\n        let nft_id = object::id(&nft);\n        let sender = tx_context::sender(ctx);\n        validate_signature<T>(pool, sender, nft_id, amount, signature, clock);\n        if (!dynamic_field::exists_with_type<address, UserInfo>(&pool.id, sender)) {\n            let user_info = UserInfo {\n                number_nft_staked: 0,\n                nft_ids: vector::empty<object::ID>(),\n                lock_at: 0,\n            };\n            dynamic_field::add<address, UserInfo>(&mut pool.id, sender, user_info);\n        };\n        let user_info_mut = dynamic_field::borrow_mut<address, UserInfo>(&mut pool.id, sender);\n        if (user_info_mut.number_nft_staked > 0) {\n            let reward_claimed = RewardClaimed {\n                pool_id,\n                user: sender,\n                number_nft_staked: user_info_mut.number_nft_staked,\n                reward_from: user_info_mut.lock_at,\n                reward_to: get_reward_to(user_info_mut.lock_at, pool.lock_duration, timestamp_ms, pool.end_at),\n                timestamp_ms,\n            };\n            event::emit<RewardClaimed>(reward_claimed);\n        };\n        user_info_mut.lock_at = timestamp_ms;\n        pool.total_staked_nft = pool.total_staked_nft + 1;\n        user_info_mut.number_nft_staked = user_info_mut.number_nft_staked + 1;\n        vector::push_back<object::ID>(&mut user_info_mut.nft_ids, nft_id);\n        dynamic_object_field::add<object::ID, T>(&mut pool.id, nft_id, nft);\n        let nft_staked = NftStaked {\n            pool_id,\n            nft_id,\n            user: sender,\n            timestamp_ms,\n        };\n        event::emit<NftStaked>(nft_staked);\n    }\n\n    public entry fun update_pool_info<T>(\n        owner_cap: &OwnerCap,\n        pool: &mut Pool<T>,\n        start_at: u64,\n        end_at: u64,\n        lock_duration: u64,\n        is_paused: bool\n    ) {\n        pool.start_at = start_at;\n        pool.end_at = end_at;\n        pool.lock_duration = lock_duration;\n        pool.is_paused = is_paused;\n    }\n\n    public entry fun withdraw<T: store + key>(\n        pool: &mut Pool<T>,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(pool.version <= 1, 5);\n        assert!(!pool.is_paused, 9);\n        let sender = tx_context::sender(ctx);\n        assert!(dynamic_field::exists_with_type<address, UserInfo>(&pool.id, sender), 4);\n        let pool_id = object::id<Pool<T>>(pool);\n        let current_timestamp = clock::timestamp_ms(clock);\n        let user_info = dynamic_field::borrow_mut<address, UserInfo>(&mut pool.id, sender);\n        assert!(user_info.number_nft_staked > 0, 12);\n        let reward_to_timestamp = current_timestamp;\n        if (pool.end_at != 0 && pool.end_at < current_timestamp) {\n            reward_to_timestamp = pool.end_at;\n        };\n        assert!(user_info.lock_at + pool.lock_duration <= reward_to_timestamp, 6);\n        let num_nfts = vector::length(&user_info.nft_ids);\n        pool.total_staked_nft = pool.total_staked_nft - num_nfts;\n        let nft_ids = user_info.nft_ids;\n        user_info.number_nft_staked = 0;\n        user_info.nft_ids = vector::empty<object::ID>();\n        let reward_claimed_event = RewardClaimed {\n            pool_id,\n            user: sender,\n            number_nft_staked: num_nfts,\n            reward_from: user_info.lock_at,\n            reward_to: get_reward_to(user_info.lock_at, pool.lock_duration, current_timestamp, pool.end_at),\n            timestamp_ms: current_timestamp,\n        };\n        event::emit<RewardClaimed>(reward_claimed_event);\n        let remaining_nfts = num_nfts;\n        while (remaining_nfts > 0) {\n            let nft_id = vector::pop_back(&mut nft_ids);\n            transfer::public_transfer(\n                dynamic_object_field::remove<object::ID, T>(&mut pool.id, nft_id),\n                sender\n            );\n            remaining_nfts = remaining_nfts - 1;\n            let nft_withdrawn_event = NftWithdrawn {\n                pool_id,\n                nft_id,\n                user: sender,\n                timestamp_ms: current_timestamp,\n            };\n            event::emit<NftWithdrawn>(nft_withdrawn_event);\n        };\n    }\n\n    public(entry) fun update_operator<T>(\n        owner_cap: &OwnerCap,\n        pool: &mut Pool<T>,\n        operator_pk: vector<u8>,\n    ) {\n        pool.operator_pk = operator_pk;\n    }\n\n    entry fun migrate<T>(\n        owner_cap: &OwnerCap,\n        pool: &mut Pool<T>\n    ) {\n        assert!(pool.version < 1, 8);\n        pool.version = 1;\n    }\n}"
}