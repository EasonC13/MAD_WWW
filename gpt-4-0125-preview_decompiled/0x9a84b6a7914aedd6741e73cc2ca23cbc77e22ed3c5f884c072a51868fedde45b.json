{
    "hyperspace": "// Decompiled by SuiGPT\nmodule 0x9a84b6a7914aedd6741e73cc2ca23cbc77e22ed3c5f884c072a51868fedde45b::hyperspace {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::bag;\n    use sui::tx_context;\n    use sui::package;\n    use sui::transfer_policy;\n    use sui::transfer;\n    use sui::kiosk;\n    use sui::dynamic_field;\n    use sui::event;\n    use sui::coin;\n    use sui::sui;\n\n    // ----- Structs -----\n\n    struct Extension<phantom T0> has copy, drop, store {\n        dummy_field: bool,\n    }\n\n    struct HYPERSPACE has drop {\n        dummy_field: bool,\n    }\n\n    struct Hyperspace has store, key {\n        id: object::UID,\n    }\n\n    struct ItemDelisted<phantom T0, phantom T1> has copy, drop {\n        kiosk: object::ID,\n        id: object::ID,\n    }\n\n    struct ItemListed<phantom T0, phantom T1> has copy, drop {\n        kiosk: object::ID,\n        id: object::ID,\n        price: u64,\n    }\n\n    struct Marketplace has store {\n        storage: bag::Bag,\n        transfer_policy_id: object::ID,\n    }\n\n    // ----- Functions -----\n\n    fun init(\n        hyperspace: HYPERSPACE,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let publisher = package::claim<HYPERSPACE>(hyperspace, ctx);\n        let (policy, cap) = transfer_policy::new<Hyperspace>(&publisher, ctx);\n        transfer::public_transfer(publisher, sender);\n        transfer::public_transfer(cap, sender);\n        transfer::public_share_object(policy);\n    }\n\n    fun storage_mut<T: store + key>(\n        kiosk: &mut kiosk::Kiosk\n    ): &mut bag::Bag {\n        let extension = Extension<T>{dummy_field: false};\n        &mut dynamic_field::borrow_mut<Extension<T>, Marketplace>(\n            kiosk::uid_mut(kiosk),\n            extension\n        ).storage\n    }\n\n    public fun install<T: store + key>(\n        kiosk: &mut kiosk::Kiosk,\n        owner_cap: &kiosk::KioskOwnerCap,\n        transfer_policy: &transfer_policy::TransferPolicy<T>,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let extension = Extension<T>{dummy_field: false};\n        let marketplace = Marketplace{\n            storage: bag::new(ctx), \n            transfer_policy_id: object::id(transfer_policy),\n        };\n        dynamic_field::add<Extension<T>, Marketplace>(\n            kiosk::uid_mut(kiosk),\n            extension,\n            marketplace\n        );\n    }\n\n    public fun delist<T, V: store + key>(\n        kiosk: &mut kiosk::Kiosk,\n        owner_cap: &kiosk::KioskOwnerCap,\n        id: object::ID\n    ) {\n        kiosk::return_purchase_cap<T>(\n            kiosk,\n            bag::remove<object::ID, kiosk::PurchaseCap<T>>(\n                storage_mut<V>(kiosk),\n                id\n            )\n        );\n        let item_delisted = ItemDelisted<T, V>{\n            kiosk: object::id(kiosk),\n            id,\n        };\n        event::emit<ItemDelisted<T, V>>(item_delisted);\n    }\n\n    public fun list<T: store + key, S: store + key>(\n        kiosk: &mut kiosk::Kiosk,\n        owner_cap: &kiosk::KioskOwnerCap,\n        id: object::ID,\n        price: u64,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let event = ItemListed<T, S> {\n            kiosk: object::id(kiosk),\n            id,\n            price,\n        };\n        event::emit<ItemListed<T, S>>(event);\n        bag::add<object::ID, kiosk::PurchaseCap<T>>(\n            storage_mut<S>(kiosk),\n            id,\n            kiosk::list_with_purchase_cap<T>(kiosk, owner_cap, id, price, ctx)\n        );\n    }\n\n    public fun purchase<T: store + key, U: store + key>(\n        kiosk: &mut kiosk::Kiosk,\n        object_id: object::ID,\n        payment: coin::Coin<sui::SUI>\n    ): (\n        T,\n        transfer_policy::TransferRequest<T>,\n        transfer_policy::TransferRequest<Hyperspace>,\n        transfer_policy::TransferRequest<U>\n    ) {\n        let (item, transfer_request) = kiosk::purchase_with_cap<T>(\n            kiosk,\n            bag::remove<object::ID, kiosk::PurchaseCap<T>>(storage_mut<U>(kiosk), object_id),\n            payment\n        );\n        let transfer_request_clone = transfer_request;\n        (\n            item,\n            transfer_request_clone,\n            transfer_policy::new_request<Hyperspace>(\n                object_id,\n                transfer_policy::paid<T>(&transfer_request_clone),\n                transfer_policy::from<T>(&transfer_request_clone)\n            ),\n            transfer_policy::new_request<U>(\n                object_id,\n                transfer_policy::paid<T>(&transfer_request_clone),\n                transfer_policy::from<T>(&transfer_request_clone)\n            )\n        )\n    }\n}",
    "hyperspace_mp": "// Decompiled by SuiGPT\nmodule 0x9a84b6a7914aedd6741e73cc2ca23cbc77e22ed3c5f884c072a51868fedde45b::hyperspace_mp {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::tx_context;\n    use sui::package;\n    use sui::transfer_policy;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct HYPERSPACE_MP has drop {\n        dummy_field: bool,\n    }\n\n    struct Hyperspace_mp has store, key {\n        id: object::UID,\n    }\n\n    // ----- Functions -----\n\n    fun init(\n        hyperspaceMP: HYPERSPACE_MP,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let publisher = package::claim<HYPERSPACE_MP>(hyperspaceMP, ctx);\n        let (transferPolicy, transferPolicyCap) = transfer_policy::new<Hyperspace_mp>(&publisher, ctx);\n        transfer::public_transfer(publisher, sender);\n        transfer::public_transfer(transferPolicyCap, sender);\n        transfer::public_share_object(transferPolicy);\n    }\n}"
}