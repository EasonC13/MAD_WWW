{
    "SupraSValueFeed": "// Decompiled by MAD\nmodule 0x5d8fbbf6f908a4af8c6d072669a462d53e03eb3c1d863bd0359dc818c69ea706::SupraSValueFeed {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::table;\n    use sui::tx_context;\n    use std::vector;\n    use sui::event;\n    use sui::transfer;\n    use sui::hash;\n    use sui::bcs;\n    use sui::bls12381;\n\n    // ----- Structs -----\n\n    struct CoherentCluster has copy, drop {\n        data_hash: vector<u8>,\n        pair: vector<u32>,\n        prices: vector<u128>,\n        timestamp: vector<u128>,\n        decimals: vector<u16>,\n    }\n\n    struct DkgState has store, key {\n        id: object::UID,\n        public_key: vector<u8>,\n    }\n\n    struct Entry has copy, drop, store {\n        value: u128,\n        decimal: u16,\n        timestamp: u128,\n        round: u64,\n    }\n\n    struct MinBatch has drop {\n        protocol: vector<u8>,\n        txn_hashes: vector<vector<u8>>,\n    }\n\n    struct MinBlock has drop {\n        round: vector<u8>,\n        timestamp: vector<u8>,\n        author: vector<u8>,\n        qc_hash: vector<u8>,\n        batch_hashes: vector<vector<u8>>,\n    }\n\n    struct MinTxn has drop {\n        cluster_hashes: vector<vector<u8>>,\n        sender: vector<u8>,\n        protocol: vector<u8>,\n        tx_sub_type: u8,\n    }\n\n    struct OracleHolder has store, key {\n        id: object::UID,\n        version: u64,\n        owner: object::ID,\n        feeds: table::Table<u32, Entry>,\n    }\n\n    struct Origin has drop {\n        id: vector<u8>,\n        member_index: u64,\n        committee_index: u64,\n    }\n\n    struct OwnerCap has key {\n        id: object::UID,\n    }\n\n    struct Price has drop {\n        pair: u32,\n        value: u128,\n        decimal: u16,\n        timestamp: u128,\n        round: u64,\n    }\n\n    struct SCCProcessedEvent has copy, drop {\n        hash: vector<u8>,\n    }\n\n    struct SignedCoherentCluster has drop {\n        cc: CoherentCluster,\n        qc: vector<u8>,\n        round: u64,\n        origin: Origin,\n    }\n\n    struct Vote has drop {\n        smr_block: MinBlock,\n        round: u64,\n    }\n\n    // ----- Functions -----\n\n    fun batch_verification(\n        min_batch: &MinBatch,\n        hashes: &vector<vector<u8>>,\n        index: u64\n    ): bool {\n        let batch_hash = hash_min_batch(min_batch);\n        vector::borrow(hashes, index) == &batch_hash\n    }\n\n    fun create_dkg_state(\n        public_key: vector<u8>,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let dkg_state = DkgState {\n            id: object::new(ctx),\n            public_key,\n        };\n        transfer::freeze_object(dkg_state);\n    }\n\n    fun create_oracle_holder(ctx: &mut tx_context::TxContext, owner_cap: &OwnerCap) {\n        let oracle_holder = OracleHolder {\n            id: object::new(ctx),\n            version: 1,\n            owner: object::id(owner_cap),\n            feeds: table::new<u32, Entry>(ctx),\n        };\n        transfer::share_object(oracle_holder);\n    }\n\n    fun create_owner(\n        owner_cap: OwnerCap,\n        ctx: &mut tx_context::TxContext\n    ) {\n        transfer::transfer(owner_cap, tx_context::sender(ctx));\n    }\n\n    fun hash_min_batch(batch: &MinBatch): vector<u8> {\n        let data_prefix = b\"\";\n        let flattened_data = vector_flatten_concate(data_prefix, &batch.txn_hashes);\n        let protocol_data = batch.protocol;\n        vector::append(&mut protocol_data, hash::keccak256(&flattened_data));\n        hash::keccak256(&protocol_data)\n    }\n\n    fun hash_min_txn(min_txn: &MinTxn): vector<u8> {\n        let prefix = b\"\".to_vec();\n        let data = vector_flatten_concate(&prefix, &min_txn.cluster_hashes);\n        vector::append(&mut data, &min_txn.sender);\n        vector::append(&mut data, &min_txn.protocol);\n        let tx_sub_type_vec = vector::empty<u8>();\n        vector::push_back(&mut tx_sub_type_vec, min_txn.tx_sub_type);\n        vector::append(&mut data, &tx_sub_type_vec);\n        hash::keccak256(&data)\n    }\n\n    fun hash_scc(scc: &SignedCoherentCluster): vector<u8> {\n        let scc_bytes = bcs::to_bytes(scc);\n        hash::keccak256(&scc_bytes)\n    }\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let owner_cap = OwnerCap { id: object::new(ctx) };\n        create_oracle_holder(ctx, &owner_cap);\n        create_owner(owner_cap, ctx);\n    }\n\n    fun new_min_batch(\n        protocol: vector<u8>,\n        txn_hashes: vector<vector<u8>>\n    ): MinBatch {\n        MinBatch {\n            protocol,\n            txn_hashes\n        }\n    }\n\n    fun new_min_txn(\n        cluster_hashes: vector<vector<u8>>,\n        sender: vector<u8>,\n        protocol: vector<u8>,\n        tx_sub_type: u8\n    ): MinTxn {\n        MinTxn {\n            cluster_hashes,\n            sender,\n            protocol,\n            tx_sub_type,\n        }\n    }\n\n    fun new_scc(\n        data_hash: vector<u8>,\n        pair: vector<u32>,\n        prices: vector<u128>,\n        timestamp: vector<u128>,\n        decimals: vector<u16>,\n        qc: vector<u8>,\n        round: u64,\n        id: vector<u8>,\n        member_index: u64,\n        committee_index: u64\n    ): SignedCoherentCluster {\n        let cc = CoherentCluster {\n            data_hash,\n            pair,\n            prices,\n            timestamp,\n            decimals,\n        };\n        let origin = Origin {\n            id,\n            member_index,\n            committee_index,\n        };\n        SignedCoherentCluster {\n            cc,\n            qc,\n            round,\n            origin,\n        }\n    }\n\n    fun new_vote(\n        round: vector<u8>,\n        timestamp: vector<u8>,\n        author: vector<u8>,\n        qc_hash: vector<u8>,\n        batch_hashes: vector<vector<u8>>,\n        vote_round: u64\n    ): Vote {\n        let min_block = MinBlock {\n            round,\n            timestamp,\n            author,\n            qc_hash,\n            batch_hashes,\n        };\n        Vote {\n            smr_block: min_block,\n            round: vote_round,\n        }\n    }\n\n    fun scc_verification(\n        scc: &SignedCoherentCluster,\n        signatures: &vector<vector<u8>>,\n        index: u64\n    ): bool {\n        let scc_hash = hash_scc(scc);\n        vector::borrow(signatures, index) == &scc_hash\n    }\n\n    fun smr_hash_vote(vote: &Vote): vector<u8> {\n        let data_prefix = b\"\".to_vec();\n        let data = vector_flatten_concate(&data_prefix, &vote.smr_block.batch_hashes);\n        let round_data = vote.smr_block.round.to_vec();\n        vector::append(&mut round_data, &vote.smr_block.timestamp);\n        vector::append(&mut round_data, &vote.smr_block.author);\n        vector::append(&mut round_data, &vote.smr_block.qc_hash);\n        vector::append(&mut data, &hash::keccak256(&round_data));\n        let final_data = hash::keccak256(&data);\n        vector::append(&mut final_data, &bcs::to_bytes(&vote.round));\n        hash::keccak256(&final_data)\n    }\n\n    fun transaction_verification(\n        min_txn: &MinTxn,\n        signatures: &vector<vector<u8>>,\n        index: u64\n    ): bool {\n        let txn_hash = hash_min_txn(min_txn);\n        vector::borrow(signatures, index) == &txn_hash\n    }\n\n    fun update_price(oracleHolder: &mut OracleHolder, signedCluster: SignedCoherentCluster) {\n        let cc = signedCluster.cc;\n        let i = 0;\n        while (i < vector::length(&cc.pair)) {\n            let pair_id = *vector::borrow<u32>(&cc.pair, i);\n            let timestamp = *vector::borrow<u128>(&cc.timestamp, i);\n            let entry = Entry {\n                value: *vector::borrow<u128>(&cc.prices, i),\n                decimal: *vector::borrow<u16>(&cc.decimals, i),\n                timestamp,\n                round: signedCluster.round,\n            };\n            if (table::contains(&oracleHolder.feeds, pair_id)) {\n                let current_entry = table::borrow_mut(&mut oracleHolder.feeds, pair_id);\n                if (current_entry.timestamp < timestamp) {\n                    *current_entry = entry;\n                };\n            } else {\n                table::add(&mut oracleHolder.feeds, pair_id, entry);\n            };\n            i = i + 1;\n        };\n    }\n\n    fun vector_flatten_concate<T: copy + drop>(\n        target: &mut vector<T>,\n        sources: vector<vector<T>>,\n    ) {\n        let i = 0;\n        while (i < vector::length(&sources)) {\n            let source = vector::borrow(&sources, i);\n            vector::append(target, *source);\n            i = i + 1;\n        };\n    }\n\n    fun verify_signature(\n        public_key: vector<u8>,\n        message: vector<u8>,\n        signature: vector<u8>\n    ): bool {\n        bls12381::bls12381_min_sig_verify(&signature, &public_key, &message)\n    }\n\n    fun vote_verification(\n        public_key: vector<u8>,\n        vote: &Vote,\n        signature: vector<u8>\n    ): bool {\n        verify_signature(public_key, smr_hash_vote(vote), signature)\n    }\n\n    public entry fun add_public_key(\n        ownerCap: &mut OwnerCap,\n        public_key: vector<u8>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        create_dkg_state(public_key, ctx);\n    }\n\n    entry fun process_cluster(\n        dkg_state: &DkgState,\n        oracle_holder: &mut OracleHolder,\n        vote_hashes: vector<vector<u8>>,\n        vote_signatures: vector<vector<u8>>,\n        smr_block_hashes: vector<vector<u8>>,\n        smr_block_signatures: vector<vector<u8>>,\n        batch_hashes: vector<vector<vector<u8>>>,\n        batch_sizes: vector<u64>,\n        min_batch_hashes: vector<vector<u8>>,\n        txn_hashes: vector<vector<vector<u8>>>,\n        min_txn_hashes: vector<vector<vector<u8>>>,\n        cluster_hashes: vector<vector<u8>>,\n        cluster_signatures: vector<vector<u8>>,\n        cluster_epoch: vector<u8>,\n        scc_hashes: vector<vector<u8>>,\n        scc_sizes: vector<vector<u32>>,\n        scc_values: vector<vector<u128>>,\n        scc_weights: vector<vector<u128>>,\n        scc_epochs: vector<vector<u16>>,\n        scc_signatures: vector<vector<u8>>,\n        scc_thresholds: vector<u64>,\n        scc_public_keys: vector<vector<u8>>,\n        scc_voting_powers: vector<u64>,\n        scc_total_voting_powers: vector<u64>,\n        scc_cluster_indices: vector<u64>,\n        scc_cluster_sizes: vector<u64>,\n        vote_public_keys: vector<vector<u8>>,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        assert!(oracle_holder.version == 1, 21);\n        let index = 0;\n        while (index < vector::length(&vote_hashes)) {\n            let vote = new_vote(\n                *vector::borrow(&vote_hashes, index),\n                *vector::borrow(&vote_signatures, index),\n                *vector::borrow(&smr_block_hashes, index),\n                *vector::borrow(&smr_block_signatures, index),\n                *vector::borrow(&batch_hashes, index),\n                *vector::borrow(&batch_sizes, index)\n            );\n            let min_batch = new_min_batch(\n                *vector::borrow(&min_batch_hashes, index),\n                *vector::borrow(&txn_hashes, index)\n            );\n            let min_txn = new_min_txn(\n                *vector::borrow(&min_txn_hashes, index),\n                *vector::borrow(&cluster_hashes, index),\n                *vector::borrow(&cluster_signatures, index),\n                *vector::borrow(&cluster_epoch, index)\n            );\n            let scc = new_scc(\n                *vector::borrow(&scc_hashes, index),\n                *vector::borrow(&scc_sizes, index),\n                *vector::borrow(&scc_values, index),\n                *vector::borrow(&scc_weights, index),\n                *vector::borrow(&scc_epochs, index),\n                *vector::borrow(&scc_signatures, index),\n                *vector::borrow(&scc_thresholds, index),\n                *vector::borrow(&scc_public_keys, index),\n                *vector::borrow(&scc_voting_powers, index),\n                *vector::borrow(&scc_total_voting_powers, index)\n            );\n            let cluster_index = *vector::borrow(&scc_cluster_indices, index);\n            if (!vote_verification(dkg_state.public_key, &vote, *vector::borrow(&vote_public_keys, index))) {\n                index = index + 1;\n                continue;\n            };\n            if (!batch_verification(&min_batch, &vote.smr_block.batch_hashes, *vector::borrow(&scc_cluster_sizes, index))) {\n                index = index + 1;\n                continue;\n            };\n            if (!transaction_verification(&min_txn, &min_batch.txn_hashes, *vector::borrow(&scc_cluster_sizes, index))) {\n                index = index + 1;\n                continue;\n            };\n            if (!scc_verification(&scc, &min_txn.cluster_hashes, cluster_index)) {\n                index = index + 1;\n                continue;\n            };\n            let event = SCCProcessedEvent{hash: *vector::borrow(&min_txn.cluster_hashes, cluster_index)};\n            event::emit<SCCProcessedEvent>(event);\n            update_price(oracle_holder, scc);\n            index = index + 1;\n        };\n    }\n\n    public fun get_price(\n        oracleHolder: &OracleHolder,\n        feed_id: u32\n    ): (u128, u16, u128, u64) {\n        assert!(oracleHolder.version == 1, 21);\n        if (!table::contains<u32, Entry>(&oracleHolder.feeds, feed_id)) {\n            abort 11\n        };\n        let entry = table::borrow<u32, Entry>(&oracleHolder.feeds, feed_id);\n        (entry.value, entry.decimal, entry.timestamp, entry.round)\n    }\n\n    public fun get_prices(\n        oracleHolder: &OracleHolder,\n        pairs: vector<u32>\n    ): vector<Price> {\n        assert!(oracleHolder.version == 1, 21);\n        let i = 0;\n        let prices = vector::empty<Price>();\n        while (i < vector::length(&pairs)) {\n            let pair = vector::borrow(&pairs, i);\n            i = i + 1;\n            if (!table::contains(&oracleHolder.feeds, *pair)) {\n                continue;\n            };\n            let entry = table::borrow(&oracleHolder.feeds, *pair);\n            let price = Price {\n                pair: *pair,\n                value: entry.value,\n                decimal: entry.decimal,\n                timestamp: entry.timestamp,\n                round: entry.round,\n            };\n            vector::push_back(&mut prices, price);\n        };\n        prices\n    }\n\n    public fun extract_price(price: &Price): (u32, u128, u16, u128, u64) {\n        (price.pair, price.value, price.decimal, price.timestamp, price.round)\n    }\n\n    entry fun migrate(\n        owner_cap: &OwnerCap,\n        oracle_holder: &mut OracleHolder\n    ) {\n        assert!(oracle_holder.owner == object::id(owner_cap), 41);\n        assert!(oracle_holder.version < 1, 31);\n        oracle_holder.version = 1;\n    }\n}"
}