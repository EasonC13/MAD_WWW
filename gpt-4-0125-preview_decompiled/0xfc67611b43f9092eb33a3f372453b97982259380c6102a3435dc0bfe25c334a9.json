{
    "safe": "// Decompiled by MAD\nmodule 0xfc67611b43f9092eb33a3f372453b97982259380c6102a3435dc0bfe25c334a9::safe {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::vec_set;\n    use sui::tx_context;\n    use sui::coin;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct OwnerCapability<phantom T0> has store, key {\n        id: object::UID,\n        safe_id: object::ID,\n    }\n\n    struct Safe<phantom T0> has key {\n        id: object::UID,\n        balance: balance::Balance<T0>,\n        allowed_safes: vec_set::VecSet<object::ID>,\n    }\n\n    struct TransferCapability<phantom T0> has store, key {\n        id: object::UID,\n        safe_id: object::ID,\n        amount: u64,\n    }\n\n    // ----- Functions -----\n\n    fun check_capability_validity<T>(\n        safe: &Safe<T>,\n        capability: &TransferCapability<T>\n    ) {\n        assert!(\n            object::id<Safe<T>>(safe) == capability.safe_id,\n            0\n        );\n        let capability_id = object::id<TransferCapability<T>>(capability);\n        assert!(\n            vec_set::contains<object::ID>(&safe.allowed_safes, &capability_id),\n            2\n        );\n    }\n\n    fun check_owner_capability_validity<T>(\n        safe: &Safe<T>,\n        owner_capability: &OwnerCapability<T>\n    ) {\n        assert!(\n            object::id<Safe<T>>(safe) == owner_capability.safe_id,\n            1\n        );\n    }\n\n    fun create_capability_<T>(\n        safe: &mut Safe<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): TransferCapability<T> {\n        let id = object::new(ctx);\n        vec_set::insert<object::ID>(&mut safe.allowed_safes, object::uid_to_inner(&id));\n        TransferCapability<T> {\n            id,\n            safe_id: object::uid_to_inner(&safe.id),\n            amount,\n        }\n    }\n\n    public entry fun create<T>(\n        coin: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        transfer::public_transfer(\n            create_<T>(coin::into_balance(coin, ctx), ctx),\n            tx_context::sender(ctx)\n        );\n    }\n\n    public entry fun create_empty<T>(\n        ctx: &mut tx_context::TxContext\n    ) {\n        transfer::public_transfer<OwnerCapability<T>>(\n            create_<T>(balance::zero<T>(), ctx),\n            tx_context::sender(ctx)\n        );\n    }\n\n    public entry fun create_new_cap<T>(\n        safe: &mut Safe<T>,\n        owner_cap: &OwnerCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        check_owner_capability_validity(safe, owner_cap);\n        transfer::public_transfer(\n            create_capability_<T>(safe, amount, ctx),\n            tx_context::sender(ctx)\n        );\n    }\n\n    public entry fun debit_transfer<T>(\n        safe: &mut Safe<T>,\n        capability: &mut TransferCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        check_capability_validity(safe, capability);\n        assert!(capability.amount >= amount, 3);\n        capability.amount = capability.amount - amount;\n        let split_balance = balance::split(&mut safe.balance, amount);\n        let coin = coin::from_balance(split_balance, ctx);\n        transfer::public_transfer(coin, tx_context::sender(ctx));\n    }\n\n    public entry fun deposit<T>(\n        safe: &mut Safe<T>,\n        coin: coin::Coin<T>\n    ) {\n        deposit_<T>(safe, coin::into_balance(coin));\n    }\n\n    public entry fun deposit_check_threshold<T>(\n        safe: &mut Safe<T>,\n        coin: coin::Coin<T>,\n        threshold: u64\n    ) {\n        assert!(coin::value(&coin) >= threshold, 4);\n        deposit_<T>(safe, coin::into_balance(coin));\n    }\n\n    public entry fun revoke_transfer_capability<T>(\n        safe: &mut Safe<T>,\n        owner_capability: &OwnerCapability<T>,\n        object_id: object::ID\n    ) {\n        check_owner_capability_validity(safe, owner_capability);\n        vec_set::remove(&mut safe.allowed_safes, &object_id);\n    }\n\n    public entry fun self_revoke_transfer_capability<T>(\n        safe: &mut Safe<T>,\n        capability: &TransferCapability<T>\n    ) {\n        check_capability_validity(safe, capability);\n        let cap_id = object::id(capability);\n        vec_set::remove(&mut safe.allowed_safes, &cap_id);\n    }\n\n    public entry fun withdraw<T>(\n        safe: &mut Safe<T>,\n        owner_capability: &OwnerCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        transfer::public_transfer(\n            coin::from_balance(withdraw_<T>(safe, owner_capability, amount), ctx),\n            tx_context::sender(ctx)\n        );\n    }\n\n    public fun balance<T>(\n        safe: &Safe<T>\n    ): &balance::Balance<T> {\n        &safe.balance\n    }\n\n    public fun create_<T>(\n        balance: balance::Balance<T>,\n        ctx: &mut tx_context::TxContext\n    ): OwnerCapability<T> {\n        let safe = Safe<T>{\n            id: object::new(ctx),\n            balance,\n            allowed_safes: vec_set::empty<object::ID>(),\n        };\n        let owner_capability = OwnerCapability<T>{\n            id: object::new(ctx),\n            safe_id: object::id(&safe),\n        };\n        transfer::share_object(safe);\n        owner_capability\n    }\n\n    public fun deposit_<T>(\n        safe: &mut Safe<T>,\n        amount: balance::Balance<T>,\n    ) {\n        balance::join(&mut safe.balance, amount);\n    }\n\n    public fun withdraw_<T>(\n        safe: &mut Safe<T>,\n        owner_capability: &OwnerCapability<T>,\n        amount: u64\n    ): balance::Balance<T> {\n        check_owner_capability_validity(safe, owner_capability);\n        balance::split(&mut safe.balance, amount)\n    }\n\n    public fun debit<T>(\n        safe: &mut Safe<T>,\n        capability: &mut TransferCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        check_capability_validity(safe, capability);\n        assert!(capability.amount >= amount, 3);\n        capability.amount = capability.amount - amount;\n        coin::from_balance(balance::split(&mut safe.balance, amount), ctx)\n    }\n\n    public fun create_transfer_capability<T>(\n        safe: &mut Safe<T>,\n        owner_capability: &OwnerCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): TransferCapability<T> {\n        check_owner_capability_validity(safe, owner_capability);\n        create_capability_<T>(safe, amount, ctx)\n    }\n}"
}