{
    "coin_flip_v2": "// Decompiled by SuiGPT\nmodule 0xdc6160acd35ecf8d86a945525b53399723f76e971f35cc6f4f699a583f94303b::coin_flip_v2 {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use std::option;\n    use std::type_name;\n    use sui::tx_context;\n    use sui::transfer;\n    use sui::package;\n    use sui::coin;\n    use sui::event;\n    use std::vector;\n    use sui::dynamic_object_field;\n    use sui::bls12381;\n    use sui::hash;\n    use sui::kiosk;\n\n    // ----- Structs -----\n\n    struct AdminCap has key {\n        id: object::UID,\n    }\n\n    struct COIN_FLIP_V2 has drop {\n        dummy_field: bool,\n    }\n\n    struct FeeCollected<phantom T0> has copy, drop {\n        amount: u64,\n    }\n\n    struct Game<phantom T0> has store, key {\n        id: object::UID,\n        player: address,\n        start_epoch: u64,\n        stake: balance::Balance<T0>,\n        guess: u8,\n        seed: vector<u8>,\n        fee_rate: u128,\n    }\n\n    struct House<phantom T0> has key {\n        id: object::UID,\n        pub_key: vector<u8>,\n        fee_rate: u128,\n        min_stake_amount: u64,\n        max_stake_amount: u64,\n        pool: balance::Balance<T0>,\n        treasury: balance::Balance<T0>,\n    }\n\n    struct NewGame<phantom T0> has copy, drop {\n        game_id: object::ID,\n        player: address,\n        guess: u8,\n        seed: vector<u8>,\n        stake_amount: u64,\n        partnership_type: option::Option<type_name::TypeName>,\n    }\n\n    struct Outcome<phantom T0> has copy, drop {\n        game_id: object::ID,\n        player: address,\n        player_won: bool,\n        pnl: u64,\n        challenged: bool,\n    }\n\n    struct Partnership<phantom T0> has key {\n        id: object::UID,\n        fee_rate: u128,\n    }\n\n    // ----- Functions -----\n\n    fun compute_fee_amount(\n        amount: u64,\n        fee_rate: u128\n    ): u64 {\n        let amount_u128 = (amount as u128);\n        let fee_amount = (amount_u128 * fee_rate / 1000000) as u64;\n        fee_amount\n    }\n\n    fun init(\n        coin_flip_v2: COIN_FLIP_V2,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let sender = tx_context::sender(ctx);\n        transfer::public_transfer(\n            package::claim<COIN_FLIP_V2>(coin_flip_v2, ctx),\n            sender\n        );\n        let admin_cap = AdminCap { id: object::new(ctx) };\n        transfer::transfer(admin_cap, sender);\n    }\n\n    fun min_u128(\n        a: u128,\n        b: u128\n    ): u128 {\n        if (a <= b) {\n            a\n        } else {\n            b\n        }\n    }\n\n    fun new_game<T>(\n        house: &mut House<T>,\n        guess: u8,\n        seed: vector<u8>,\n        stake: coin::Coin<T>,\n        fee_rate: u128,\n        partnership_type: option::Option<type_name::TypeName>,\n        ctx: &mut tx_context::TxContext\n    ): (object::ID, Game<T>) {\n        assert!(guess == 1 || guess == 0, 1);\n        let stake_value = coin::value(&stake);\n        assert!(stake_value >= house.min_stake_amount && stake_value <= house.max_stake_amount, 0);\n        let stake_balance = coin::into_balance(stake);\n        assert!(house_pool_balance<T>(house) >= stake_value, 6);\n        balance::join(&mut stake_balance, balance::split(&mut house.pool, stake_value));\n        let game_id = object::new(ctx);\n        let game_id_inner = object::uid_to_inner(&game_id);\n        let player = tx_context::sender(ctx);\n        let new_game_event = NewGame<T>{\n            game_id: game_id_inner,\n            player,\n            guess,\n            seed: seed.clone(),\n            stake_amount: stake_value,\n            partnership_type,\n        };\n        event::emit<NewGame<T>>(new_game_event);\n        let game = Game<T>{\n            id: game_id,\n            player,\n            start_epoch: tx_context::epoch(ctx),\n            stake: stake_balance,\n            guess,\n            seed,\n            fee_rate,\n        };\n        (game_id_inner, game)\n    }\n\n    fun settle_internal<T>(\n        house: &mut House<T>,\n        player: address,\n        player_won: bool,\n        balance: balance::Balance<T>,\n        fee_rate: u128,\n        ctx: &mut tx_context::TxContext\n    ): u64 {\n        let total_value = balance::value(&balance);\n        if (player_won) {\n            let fee_amount = compute_fee_amount(total_value, fee_rate);\n            let fee_event = FeeCollected<T>{amount: fee_amount};\n            event::emit<FeeCollected<T>>(fee_event);\n            balance::join(&mut house.treasury, balance::split(&mut balance, fee_amount));\n            transfer::public_transfer(\n                coin::from_balance(balance, ctx),\n                player\n            );\n            (total_value / 2) - fee_amount\n        } else {\n            balance::join(&mut house.pool, balance);\n            total_value / 2\n        }\n    }\n\n    public entry fun batch_settle<T>(\n        house: &mut House<T>,\n        game_ids: vector<object::ID>,\n        proofs: vector<vector<u8>>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(\n            vector::length(&game_ids) == vector::length(&proofs),\n            8\n        );\n        while (!vector::is_empty(&game_ids)) {\n            let game_id = vector::pop_back(&mut game_ids);\n            if (game_exists<T>(house, game_id)) {\n                settle<T>(house, game_id, vector::pop_back(&mut proofs), ctx);\n                continue;\n            };\n        };\n    }\n\n    public entry fun challenge<T>(\n        house: &mut House<T>,\n        game_id: object::ID,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(game_exists<T>(house, game_id), 7);\n\n        let Game {\n            id,\n            player,\n            start_epoch,\n            stake,\n            guess: _,\n            seed: _,\n            fee_rate: _,\n        } = dynamic_object_field::remove<object::ID, Game<T>>(&mut house.id, game_id);\n\n        assert!(\n            tx_context::epoch(ctx) > start_epoch + 7,\n            4\n        );\n\n        let stake_value = balance::value(&stake);\n        transfer::public_transfer(\n            coin::from_balance(stake, ctx),\n            player\n        );\n\n        object::delete(id);\n\n        let outcome = Outcome<T> {\n            game_id,\n            player,\n            player_won: true,\n            pnl: stake_value / 2,\n            challenged: true,\n        };\n\n        event::emit<Outcome<T>>(outcome);\n    }\n\n    public entry fun claim<T>(\n        admin_cap: &AdminCap,\n        house: &mut House<T>,\n        recipient: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let treasury_balance = house_treasury_balance(house);\n        transfer::public_transfer(\n            coin::take(&mut house.treasury, treasury_balance, ctx),\n            recipient\n        );\n    }\n\n    public entry fun copy_admin_cap_to<T>(\n        admin_cap: &AdminCap,\n        recipient: address,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let new_admin_cap = AdminCap { id: object::new(ctx) };\n        transfer::transfer(new_admin_cap, recipient);\n    }\n\n    public entry fun create_house<T>(\n        admin_cap: &AdminCap,\n        pub_key: vector<u8>,\n        fee_rate: u128,\n        min_stake_amount: u64,\n        max_stake_amount: u64,\n        pool_coin: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(fee_rate <= 1000000, 5);\n        let house = House<T> {\n            id: object::new(ctx),\n            pub_key,\n            fee_rate,\n            min_stake_amount,\n            max_stake_amount,\n            pool: coin::into_balance(pool_coin),\n            treasury: balance::zero<T>(),\n        };\n        transfer::share_object(house);\n    }\n\n    public entry fun create_partnership<T>(\n        admin_cap: &AdminCap,\n        fee_rate: u128,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let partnership = Partnership<T> {\n            id: object::new(ctx),\n            fee_rate,\n        };\n        transfer::share_object(partnership);\n    }\n\n    public entry fun settle<T>(\n        house: &mut House<T>,\n        game_id: object::ID,\n        signature: vector<u8>,\n        ctx: &mut tx_context::TxContext\n    ): bool {\n        assert!(game_exists<T>(house, game_id), 7);\n\n        let Game {\n            id,\n            player,\n            start_epoch: _,\n            stake,\n            guess,\n            seed,\n            fee_rate,\n        } = dynamic_object_field::remove<object::ID, Game<T>>(&mut house.id, game_id);\n\n        let game_id_bytes = object::uid_to_bytes(&id);\n        let seed_plus_game_id = game_id_bytes;\n        vector::append(&mut seed_plus_game_id, seed);\n        let house_pub_key = house_pub_key(house);\n        assert!(\n            bls12381::bls12381_min_pk_verify(&signature, &house_pub_key, &seed_plus_game_id),\n            2\n        );\n\n        object::delete(id);\n\n        let hash = hash::blake2b256(&signature);\n        let player_won = guess == *vector::borrow(&hash, 0) % 2;\n        let pnl = settle_internal<T>(\n            house,\n            player,\n            player_won,\n            stake,\n            fee_rate,\n            ctx\n        );\n\n        let outcome = Outcome<T> {\n            game_id,\n            player,\n            player_won,\n            pnl,\n            challenged: false,\n        };\n\n        event::emit<Outcome<T>>(outcome);\n\n        player_won\n    }\n\n    public entry fun start_game<T>(\n        house: &mut House<T>,\n        game_type: u8,\n        game_data: vector<u8>,\n        bet: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ): object::ID {\n        let fee_rate = house_fee_rate(house);\n        let (game_id, game) = new_game(\n            house,\n            game_type,\n            game_data,\n            bet,\n            fee_rate,\n            option::none<type_name::TypeName>(),\n            ctx\n        );\n        dynamic_object_field::add(&mut house.id, game_id, game);\n        game_id\n    }\n\n    public entry fun start_game_with_kiosk<T, V: store + key>(\n        house: &mut House<T>,\n        game_type: u8,\n        game_data: vector<u8>,\n        bet: coin::Coin<T>,\n        partnership: &Partnership<V>,\n        kiosk: &kiosk::Kiosk,\n        item_id: object::ID,\n        ctx: &mut tx_context::TxContext\n    ): object::ID {\n        assert!(kiosk::has_item_with_type<V>(kiosk, item_id), 3);\n        let fee_rate = min_u128(house_fee_rate(house), partnership_fee_rate(partnership));\n        let (game_id, game) = new_game(\n            house,\n            game_type,\n            game_data,\n            bet,\n            fee_rate,\n            option::some(type_name::get<V>()),\n            ctx\n        );\n        dynamic_object_field::add(&mut house.id, game_id, game);\n        game_id\n    }\n\n    public entry fun start_game_with_parternship<T, P: key>(\n        house: &mut House<T>,\n        game_type: u8,\n        game_data: vector<u8>,\n        bet: coin::Coin<T>,\n        partnership: &Partnership<P>,\n        partner: &P,\n        ctx: &mut tx_context::TxContext\n    ): object::ID {\n        let house_fee = house_fee_rate(house);\n        let partnership_fee = partnership_fee_rate(partnership);\n        let fee_rate = min_u128(house_fee, partnership_fee);\n        let partner_type_name = option::some(type_name::get<P>());\n        let (game_id, game) = new_game(\n            house,\n            game_type,\n            game_data,\n            bet,\n            fee_rate,\n            partner_type_name,\n            ctx\n        );\n        dynamic_object_field::add(&mut house.id, game_id, game);\n        game_id\n    }\n\n    public entry fun top_up<T>(\n        adminCap: &AdminCap,\n        house: &mut House<T>,\n        coin: coin::Coin<T>\n    ) {\n        balance::join(&mut house.pool, coin::into_balance(coin));\n    }\n\n    public entry fun update_fee_rate<T>(\n        admin_cap: &AdminCap,\n        house: &mut House<T>,\n        new_fee_rate: u128\n    ) {\n        assert!(new_fee_rate <= 1000000, 5);\n        house.fee_rate = new_fee_rate;\n    }\n\n    public entry fun update_max_stake_amount<T>(\n        adminCap: &AdminCap,\n        house: &mut House<T>,\n        max_stake_amount: u64,\n    ) {\n        house.max_stake_amount = max_stake_amount;\n    }\n\n    public entry fun update_min_stake_amount<T>(\n        _admin_cap: &AdminCap,\n        house: &mut House<T>,\n        min_stake_amount: u64\n    ) {\n        house.min_stake_amount = min_stake_amount;\n    }\n\n    public entry fun update_partnership_fee_rate<T>(\n        admin_cap: &AdminCap,\n        partnership: &mut Partnership<T>,\n        fee_rate: u128\n    ) {\n        assert!(fee_rate < 1000000, 5);\n        partnership.fee_rate = fee_rate;\n    }\n\n    public entry fun withdraw<T>(\n        admin_cap: &AdminCap,\n        house: &mut House<T>,\n        amount: u64,\n        recipient: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(\n            amount <= balance::value(&house.pool),\n            6\n        );\n        transfer::public_transfer(\n            coin::take(&mut house.pool, amount, ctx),\n            recipient\n        );\n    }\n\n    public fun house_pub_key<T>(\n        house: &House<T>\n    ): vector<u8> {\n        house.pub_key\n    }\n\n    public fun house_fee_rate<T>(house: &House<T>): u128 {\n        house.fee_rate\n    }\n\n    public fun house_pool_balance<T>(\n        house: &House<T>\n    ): u64 {\n        balance::value(&house.pool)\n    }\n\n    public fun house_treasury_balance<T>(\n        house: &House<T>\n    ): u64 {\n        balance::value<T>(&house.treasury)\n    }\n\n    public fun house_stake_range<T>(\n        house: &House<T>\n    ): (u64, u64) {\n        (house.min_stake_amount, house.max_stake_amount)\n    }\n\n    public fun game_exists<T>(\n        house: &House<T>,\n        game_id: object::ID\n    ): bool {\n        dynamic_object_field::exists_with_type<object::ID, Game<T>>(&house.id, game_id)\n    }\n\n    public fun borrow_game<T>(\n        house: &House<T>,\n        game_id: object::ID\n    ): &Game<T> {\n        dynamic_object_field::borrow<object::ID, Game<T>>(&house.id, game_id)\n    }\n\n    public fun game_start_epoch<T>(\n        game: &Game<T>\n    ): u64 {\n        game.start_epoch\n    }\n\n    public fun game_guess<T>(\n        game: &Game<T>\n    ): u8 {\n        game.guess\n    }\n\n    public fun game_stake_amount<T>(\n        game: &Game<T>\n    ): u64 {\n        balance::value(&game.stake)\n    }\n\n    public fun game_fee_rate<T>(game: &Game<T>): u128 {\n        game.fee_rate\n    }\n\n    public fun game_seed<T>(game: &Game<T>): vector<u8> {\n        game.seed\n    }\n\n    public fun partnership_fee_rate<T>(\n        partnership: &Partnership<T>\n    ): u128 {\n        partnership.fee_rate\n    }\n}"
}