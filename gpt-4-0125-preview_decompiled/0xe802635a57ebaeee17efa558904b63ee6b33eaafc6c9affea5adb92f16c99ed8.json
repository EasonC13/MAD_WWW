{
    "game": "// Decompiled by MAD\nmodule 0xe802635a57ebaeee17efa558904b63ee6b33eaafc6c9affea5adb92f16c99ed8::game {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use std::option;\n    use sui::balance;\n    use sui::sui;\n    use sui::table;\n    use sui::package;\n    use sui::tx_context;\n    use std::string;\n    use sui::zklogin_verified_issuer;\n    use sui::event;\n    use sui::pay;\n    use sui::coin;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct GAME has drop {\n        dummy_field: bool,\n    }\n\n    struct Game has key {\n        id: object::UID,\n        active: bool,\n        prize: option::Option<balance::Balance<sui::SUI>>,\n        taps: u64,\n        taps_per_address: table::Table<address, u64>,\n        winner: option::Option<address>,\n        initial_prize: u64,\n        initial_taps: u64,\n    }\n\n    struct GameCancelled has copy, drop {\n        game: object::ID,\n    }\n\n    struct GameCreated has copy, drop {\n        game: object::ID,\n    }\n\n    struct GameEnded has copy, drop {\n        game: object::ID,\n        winner: address,\n    }\n\n    struct Tapped has copy, drop {\n        game: object::ID,\n        address: address,\n    }\n\n    // ----- Functions -----\n\n    fun assert_admin(publisher: &package::Publisher) {\n        assert!(package::from_module<GAME>(publisher), 0);\n    }\n\n    fun assert_game_is_active(game: &Game) {\n        assert!(game.active, 1);\n    }\n\n    fun assert_sender_zklogin(\n        zklogin_data: u256,\n        ctx: &tx_context::TxContext\n    ) {\n        let data_prefix = string::utf8(b\"https://accounts.google.com\");\n        assert!(\n            zklogin_verified_issuer::check_zklogin_issuer(\n                tx_context::sender(ctx),\n                zklogin_data,\n                &data_prefix\n            ),\n            4\n        );\n    }\n\n    fun end(\n        game: &mut Game,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let game_id = object::id(game);\n        event::emit<GameEnded>(GameEnded {\n            game: game_id,\n            winner: sender,\n        });\n        game.active = false;\n        game.winner = option::some(sender);\n        let prize_balance = option::extract(&mut game.prize);\n        let prize_coin = coin::from_balance(prize_balance, ctx);\n        pay::keep<sui::SUI>(prize_coin, ctx);\n    }\n\n    fun init(\n        game: GAME,\n        ctx: &mut tx_context::TxContext\n    ) {\n        transfer::public_transfer(\n            package::claim<GAME>(game, ctx),\n            tx_context::sender(ctx)\n        );\n    }\n\n    fun update_taps_per_address(\n        game: &mut Game,\n        ctx: &tx_context::TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let taps_per_address = &mut game.taps_per_address;\n        if (!table::contains<address, u64>(taps_per_address, sender)) {\n            table::add<address, u64>(taps_per_address, sender, 0);\n        };\n        let taps = table::borrow_mut<address, u64>(taps_per_address, sender);\n        *taps = *taps + 1;\n    }\n\n    public fun new(\n        publisher: &package::Publisher,\n        taps: u64,\n        prize: coin::Coin<sui::SUI>,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        assert_admin(publisher);\n        assert!(taps > 0, 3);\n        let prize_balance = coin::into_balance(prize);\n        let prize_value = balance::value(&prize_balance);\n        assert!(prize_value > 0, 2);\n        let game = Game {\n            id: object::new(ctx),\n            active: true,\n            prize: option::some(prize_balance),\n            taps,\n            taps_per_address: table::new(ctx),\n            winner: option::none<address>(),\n            initial_prize: prize_value,\n            initial_taps: taps,\n        };\n        let game_created_event = GameCreated { game: object::id(&game) };\n        event::emit(game_created_event);\n        transfer::share_object(game);\n    }\n\n    public fun cancel(\n        publisher: &package::Publisher,\n        game: &mut Game,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        assert_admin(publisher);\n        assert_game_is_active(game);\n        let game_cancelled_event = GameCancelled { game: object::id(game) };\n        event::emit(game_cancelled_event);\n        end(game, ctx);\n    }\n\n    public fun tap(\n        game: &mut Game,\n        zklogin_proof: u256,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert_game_is_active(game);\n        assert_sender_zklogin(zklogin_proof, ctx);\n        let tapped_event = Tapped {\n            game: object::id(game),\n            address: tx_context::sender(ctx),\n        };\n        event::emit<Tapped>(tapped_event);\n        game.taps = game.taps - 1;\n        update_taps_per_address(game, ctx);\n        if (game.taps == 0) {\n            end(game, ctx);\n        };\n    }\n\n    public fun get_address_taps(\n        game: &Game,\n        address: address\n    ): u64 {\n        *table::borrow<address, u64>(&game.taps_per_address, address)\n    }\n}"
}