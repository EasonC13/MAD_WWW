{
    "rewards": "// Decompiled by SuiGPT\nmodule 0xd04258552b3351ab92f749381748888865605f0d959b011b7d6bc5151a5dc967::rewards {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::sui;\n    use sui::table;\n    use sui::tx_context;\n    use sui::transfer;\n    use std::vector;\n    use sui::coin;\n    use sui::address;\n    use sui::ecdsa_k1;\n    use sui::bcs;\n    use sui::hash;\n\n    // ----- Structs -----\n\n    struct AdminCap has store, key {\n        id: object::UID,\n    }\n\n    struct DepositCap has store, key {\n        id: object::UID,\n    }\n\n    struct RewardsPool has store, key {\n        id: object::UID,\n        balance: balance::Balance<sui::SUI>,\n        leaderboard: table::Table<address, u64>,\n        claims_enabled: bool,\n        public_key: vector<u8>,\n        required_funds: u64,\n        setup_hashes: vector<address>,\n    }\n\n    struct SetupCap has store, key {\n        id: object::UID,\n    }\n\n    // ----- Functions -----\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let adminCap = AdminCap { id: object::new(ctx) };\n        transfer::transfer(adminCap, tx_context::sender(ctx));\n        let depositCap = DepositCap { id: object::new(ctx) };\n        transfer::transfer(depositCap, tx_context::sender(ctx));\n        let setupCap = SetupCap { id: object::new(ctx) };\n        transfer::transfer(setupCap, tx_context::sender(ctx));\n        let rewardsPool = RewardsPool {\n            id: object::new(ctx),\n            balance: balance::zero<sui::SUI>(),\n            leaderboard: table::new<address, u64>(ctx),\n            claims_enabled: false,\n            public_key: vector::empty<u8>(),\n            required_funds: 0,\n            setup_hashes: vector::empty<address>(),\n        };\n        transfer::share_object(rewardsPool);\n    }\n\n    public fun setup_hashes(\n        cap: SetupCap,\n        rewards_pool: &mut RewardsPool,\n        addresses: vector<address>,\n    ) {\n        let SetupCap { id } = cap;\n        object::delete(id);\n        while (vector::length(&addresses) > 0) {\n            let address = vector::pop_back(&mut addresses);\n            vector::push_back(&mut rewards_pool.setup_hashes, address);\n        };\n    }\n\n    public fun setup_leaderboard(\n        rewards_pool: &mut RewardsPool,\n        addresses: vector<address>,\n        rewards: vector<u64>\n    ) {\n        assert!(vector::length(&addresses) == vector::length(&rewards), 3);\n        assert!(!rewards_pool.claims_enabled, 6);\n        let addresses_bytes = bcs::to_bytes(&addresses);\n        let combined_bytes = addresses_bytes;\n        vector::append(&mut combined_bytes, bcs::to_bytes(&rewards));\n        let setup_hash = address::from_bytes(hash::blake2b256(&combined_bytes));\n        let (exists, index) = vector::index_of(&rewards_pool.setup_hashes, &setup_hash);\n        assert!(exists, 7);\n        vector::remove(&mut rewards_pool.setup_hashes, index);\n        while (vector::length(&addresses) > 0) {\n            let reward = vector::pop_back(&mut rewards);\n            rewards_pool.required_funds = rewards_pool.required_funds + reward;\n            table::add(\n                &mut rewards_pool.leaderboard,\n                vector::pop_back(&mut addresses),\n                reward\n            );\n        };\n    }\n\n    public fun enable_claims(\n        admin_cap: &AdminCap,\n        rewards_pool: &mut RewardsPool\n    ) {\n        assert!(\n            table::length<address, u64>(&rewards_pool.leaderboard) > 0 && \n            vector::length<address>(&rewards_pool.setup_hashes) == 0, \n            8\n        );\n        assert!(\n            rewards_pool.required_funds <= balance::value<sui::SUI>(&rewards_pool.balance), \n            2\n        );\n        assert!(vector::length<u8>(&rewards_pool.public_key) > 0, 10);\n        rewards_pool.claims_enabled = true;\n    }\n\n    public fun set_public_key(\n        admin_cap: &AdminCap,\n        rewards_pool: &mut RewardsPool,\n        public_key: vector<u8>\n    ) {\n        assert!(vector::length(&public_key) > 0, 11);\n        rewards_pool.public_key = public_key;\n    }\n\n    public fun deposit(\n        cap: DepositCap,\n        rewards_pool: &mut RewardsPool,\n        coin: coin::Coin<sui::SUI>\n    ) {\n        assert!(\n            table::length<address, u64>(&rewards_pool.leaderboard) > 0 || \n            vector::length<address>(&rewards_pool.setup_hashes) > 0, \n            9\n        );\n        let DepositCap { id } = cap;\n        object::delete(id);\n        coin::put(&mut rewards_pool.balance, coin);\n    }\n\n    public fun claim(\n        rewardsPool: &mut RewardsPool,\n        signature: vector<u8>,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<sui::SUI> {\n        assert!(rewardsPool.claims_enabled, 4);\n        assert!(\n            table::contains<address, u64>(&rewardsPool.leaderboard, tx_context::sender(ctx)),\n            1\n        );\n        let sender_bytes = address::to_bytes(tx_context::sender(ctx));\n        assert!(\n            ecdsa_k1::secp256k1_verify(&signature, &rewardsPool.public_key, &sender_bytes, 1),\n            5\n        );\n        let reward_amount = table::remove<address, u64>(&mut rewardsPool.leaderboard, tx_context::sender(ctx));\n        rewardsPool.required_funds = rewardsPool.required_funds - reward_amount;\n        coin::take<sui::SUI>(&mut rewardsPool.balance, reward_amount, ctx)\n    }\n\n    public fun disable_claims(\n        _admin_cap: &AdminCap,\n        rewards_pool: &mut RewardsPool\n    ) {\n        rewards_pool.claims_enabled = false;\n    }\n\n    public fun leaderboard(\n        rewardsPool: &RewardsPool\n    ): &table::Table<address, u64> {\n        &rewardsPool.leaderboard\n    }\n\n    public fun new_deposit_cap(\n        admin_cap: &AdminCap,\n        ctx: &mut tx_context::TxContext\n    ): DepositCap {\n        DepositCap { id: object::new(ctx) }\n    }\n\n    public fun admin_withdraw_funds(\n        admin_cap: &AdminCap,\n        rewards_pool: &mut RewardsPool,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<sui::SUI> {\n        assert!(!rewards_pool.claims_enabled, 6);\n        let balance_value = balance::value<sui::SUI>(&rewards_pool.balance);\n        coin::take<sui::SUI>(&mut rewards_pool.balance, balance_value, ctx)\n    }\n}"
}