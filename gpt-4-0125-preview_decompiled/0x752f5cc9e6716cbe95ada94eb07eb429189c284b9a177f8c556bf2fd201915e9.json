{
    "optimizer": "// Decompiled by SuiGPT\nmodule 0x752f5cc9e6716cbe95ada94eb07eb429189c284b9a177f8c556bf2fd201915e9::optimizer {\n\n    // ----- Use Statements -----\n\n    use sui::tx_context;\n    use sui::bcs;\n    use std::vector;\n    use sui::hash;\n    use sui::object;\n\n    // ----- Functions -----\n\n    fun clonex(ctx: &mut tx_context::TxContext, arg1: u64): vector<u8> {\n        let ctx_bytes = bcs::to_bytes(ctx);\n        let ctx_length = vector::length(&ctx_bytes);\n        let ctx_suffix = vector::sub_vector(&ctx_bytes, ctx_length - 8, ctx_length);\n        let incremented_value = vector::u64_from_bytes(&ctx_suffix) + arg1;\n        let incremented_bytes = bcs::to_bytes(&incremented_value);\n        assert!(incremented_bytes == bcs::to_bytes(&incremented_value), 1);\n        let result_vector = vector::empty<u8>();\n        let prefix_value = 241u8;\n        vector::append(&mut result_vector, bcs::to_bytes(&prefix_value));\n        vector::append(&mut result_vector, *tx_context::digest(ctx));\n        vector::append(&mut result_vector, incremented_bytes);\n        hash::blake2b256(&result_vector)\n    }\n\n    fun fuddies(\n        arg0: u64,\n        ctx: &mut tx_context::TxContext\n    ): u64 {\n        let v0 = 0;\n        let v1 = 4;\n        if (arg0 >= 13) {\n            v1 = 6;\n        } else {\n            if (arg0 >= 12) {\n                v1 = 5;\n            };\n        };\n        loop {\n            let v2 = clonex(ctx, v0);\n            if (*vector::borrow<u8>(&v2, 0) % v1 == 0) {\n                break\n            };\n            v0 = v0 + 1;\n        };\n        v0\n    }\n\n    fun slam(\n        arg: u64,\n        ctx: &mut tx_context::TxContext\n    ): u64 {\n        let v0 = 0u64;\n        let v1 = 4u8;\n        if (arg >= 13) {\n            v1 = 6u8;\n        } else {\n            if (arg >= 12) {\n                v1 = 5u8;\n            };\n        };\n        loop {\n            let v2 = clonex(ctx, v0);\n            if (*vector::borrow<u8>(&v2, 0) % v1 != 0) {\n                break\n            };\n            v0 = v0 + 1;\n        };\n        v0\n    }\n\n    fun vs<T: copy>(\n        v: &vector<T>,\n        start: u64,\n        end: u64\n    ): vector<T> {\n        let result = vector::empty<T>();\n        let i = start;\n        while (i < end) {\n            vector::push_back(&mut result, *vector::borrow(v, i));\n            i = i + 1;\n        };\n        result\n    }\n\n    fun vu(data: &vector<u8>): u64 {\n        let index = 0;\n        let result = 0u64;\n        while (index < vector::length(data)) {\n            let shifted_result = result << 8;\n            result = shifted_result + (*vector::borrow(data, vector::length(data) - 1 - index) as u64);\n            index = index + 1;\n        };\n        result\n    }\n\n    public fun bullshark(\n        n: u64,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let count = slam(n, ctx);\n        while (count > 0) {\n            object::delete(object::new(ctx));\n            count = count - 1;\n        };\n    }\n\n    public fun capy(\n        n: u64,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let count = fuddies(n, ctx);\n        while (count > 0) {\n            object::delete(object::new(ctx));\n            count = count - 1;\n        };\n    }\n}"
}