{
    "safeV2": "// Decompiled by MAD\nmodule 0xe016516cae4c27eb871870e3b1dd63d45ae180c412677784915b437a7ec930f0::safeV2 {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::tx_context;\n    use std::vector;\n    use sui::coin;\n    use sui::event;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct AccessList has store, key {\n        id: object::UID,\n        list: vector<address>,\n    }\n\n    struct Pool<phantom T0> has key {\n        id: object::UID,\n        balance: balance::Balance<T0>,\n    }\n\n    struct RepayEvent<phantom T0> has copy, drop {\n        repaylimit_amount: u64,\n        repay_amount: u64,\n    }\n\n    // ----- Functions -----\n\n    fun is_valid(\n        accessList: &mut AccessList,\n        ctx: &mut tx_context::TxContext\n    ): bool {\n        let list = accessList.list;\n        let sender = tx_context::sender(ctx);\n        vector::contains(&list, &sender)\n    }\n\n    public fun access_list_add(\n        access_list: &mut AccessList,\n        addr: address,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        assert!(\n            tx_context::sender(ctx) == @0x87c9e076815e78ee63b7dc225704c428b8c51072ccead4304ae07f6c68fe1b92,\n            1\n        );\n        vector::push_back(&mut access_list.list, addr);\n    }\n\n    public fun new_access_list(ctx: &mut tx_context::TxContext) {\n        assert!(tx_context::sender(ctx) == @0x87c9e076815e78ee63b7dc225704c428b8c51072ccead4304ae07f6c68fe1b92, 1);\n        let access_list = AccessList {\n            id: object::new(ctx),\n            list: vector::singleton<address>(@0x87c9e076815e78ee63b7dc225704c428b8c51072ccead4304ae07f6c68fe1b92),\n        };\n        transfer::share_object(access_list);\n    }\n\n    public fun withdraw<T>(\n        accessList: &mut AccessList,\n        pool: &mut Pool<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        assert!(is_valid(accessList, ctx), 1);\n        coin::take(&mut pool.balance, amount, ctx)\n    }\n\n    public fun new_pool<T>(\n        accessList: &mut AccessList,\n        coin: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        assert!(is_valid(accessList, ctx), 1);\n        let pool = Pool<T> {\n            id: object::new(ctx),\n            balance: coin::into_balance(coin),\n        };\n        transfer::share_object(pool);\n    }\n\n    public fun deposit<T>(\n        pool: &mut Pool<T>,\n        coin: coin::Coin<T>,\n        repay_limit_amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let repay_amount = coin::value(&coin);\n        assert!(repay_amount >= repay_limit_amount, 2);\n        coin::put(&mut pool.balance, coin);\n        let event = RepayEvent<T>{\n            repaylimit_amount: repay_limit_amount,\n            repay_amount: repay_amount,\n        };\n        event::emit<RepayEvent<T>>(event);\n    }\n}"
}