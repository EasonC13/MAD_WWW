{
    "account_graph": "// Decompiled by MAD\nmodule 0x2461e4bcbc7f92d4d838cc6628afd8361d7ebb80eb11d1d4f249134db27a7756::account_graph {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use std::string;\n    use std::option;\n    use sui::table;\n    use sui::vec_set;\n    use sui::tx_context;\n    use sui::event;\n    use sui::vec_map;\n    use std::vector;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct AccountGraph<phantom T0: copy + drop + store, phantom T1: copy + drop + store> has store, key {\n        id: object::UID,\n        description: string::String,\n        max_out_degree: option::Option<u32>,\n        relationships: table::Table<address, vec_set::VecSet<address>>,\n        account_props: table::Table<address, T0>,\n        relationship_props: table::Table<RelationshipKey, T1>,\n    }\n\n    struct AccountPropsSet<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        node: address,\n        props: T0,\n    }\n\n    struct AccountPropsUnset<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        node: address,\n        props: T0,\n    }\n\n    struct EmptyProp has copy, drop, store {\n        dummy_field: bool,\n    }\n\n    struct GraphCreated has copy, drop {\n        graph_id: object::ID,\n    }\n\n    struct RelationshipAdded has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n    }\n\n    struct RelationshipKey has copy, drop, store {\n        source: address,\n        target: address,\n    }\n\n    struct RelationshipPropsSet<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n        props: T0,\n    }\n\n    struct RelationshipPropsUnset<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n        props: T0,\n    }\n\n    struct RelationshipRemoved has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n    }\n\n    // ----- Functions -----\n\n    fun new<T0: copy + drop + store, T1: copy + drop + store>(\n        description: string::String,\n        max_out_degree: option::Option<u32>,\n        ctx: &mut tx_context::TxContext\n    ): AccountGraph<T0, T1> {\n        let is_valid_max_out_degree = if (option::is_none(&max_out_degree)) {\n            true\n        } else {\n            let zero = 0u32;\n            !option::contains(&max_out_degree, &zero)\n        };\n        assert!(is_valid_max_out_degree, 1);\n        AccountGraph<T0, T1> {\n            id: object::new(ctx),\n            description,\n            max_out_degree,\n            relationships: table::new<address, vec_set::VecSet<address>>(ctx),\n            account_props: table::new<address, T0>(ctx),\n            relationship_props: table::new<RelationshipKey, T1>(ctx),\n        }\n    }\n\n    fun relationship_exists<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &AccountGraph<T0, T1>,\n        account_a: address,\n        account_b: address\n    ): bool {\n        table::contains<address, vec_set::VecSet<address>>(&graph.relationships, account_a) &&\n        vec_set::contains<address>(\n            table::borrow<address, vec_set::VecSet<address>>(&graph.relationships, account_a),\n            &account_b\n        )\n    }\n\n    public fun create<T0: copy + drop + store, T1: copy + drop + store>(\n        name: string::String,\n        option: option::Option<u32>,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let graph = new<T0, T1>(name, option, ctx);\n        transfer::share_object<AccountGraph<T0, T1>>(graph);\n        let graph_id = object::id<AccountGraph<T0, T1>>(&graph);\n        event::emit<GraphCreated>(GraphCreated { graph_id });\n    }\n\n    public fun add_relationship<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        target: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let source = tx_context::sender(ctx);\n        let relationships = &mut graph.relationships;\n        if (table::contains<address, vec_set::VecSet<address>>(relationships, source)) {\n            let relationship_set = table::borrow_mut<address, vec_set::VecSet<address>>(relationships, source);\n            assert!(\n                option::is_none<u32>(&graph.max_out_degree) || \n                vec_set::size<address>(relationship_set) < (*option::borrow<u32>(&graph.max_out_degree) as u64),\n                0\n            );\n            vec_set::insert<address>(relationship_set, target);\n        } else {\n            table::add<address, vec_set::VecSet<address>>(relationships, source, vec_set::singleton<address>(target));\n        };\n        let event = RelationshipAdded {\n            graph_id: object::id<AccountGraph<T0, T1>>(graph),\n            source,\n            target,\n        };\n        event::emit<RelationshipAdded>(event);\n    }\n\n    public fun remove_relationship<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        target: address,\n        ctx: &mut tx_context::TxContext\n    ): (address, option::Option<T1>) {\n        let sender = tx_context::sender(ctx);\n        let relationships = table::borrow_mut(&mut graph.relationships, sender);\n        vec_set::remove(relationships, &target);\n        if (vec_set::size(relationships) == 0) {\n            table::remove(&mut graph.relationships, sender);\n        };\n        let event = RelationshipRemoved {\n            graph_id: object::id(graph),\n            source: sender,\n            target,\n        };\n        event::emit(event);\n        (target, unset_relationship_props<T0, T1>(graph, target, ctx))\n    }\n\n    public fun clear_relationships<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        ctx: &mut tx_context::TxContext\n    ): vec_map::VecMap<address, option::Option<T1>> {\n        let sender = tx_context::sender(ctx);\n        let relationships = &mut graph.relationships;\n        let result_map = vec_map::empty<address, option::Option<T1>>();\n        if (!table::contains<address, vec_set::VecSet<address>>(relationships, sender)) {\n            return result_map;\n        };\n        let removed_set = table::remove<address, vec_set::VecSet<address>>(relationships, sender);\n        let keys = vec_set::keys<address>(&removed_set);\n        let i = 0;\n        while (i < vector::length<address>(keys)) {\n            let target = *vector::borrow<address>(keys, i);\n            vec_map::insert<address, option::Option<T1>>(\n                &mut result_map, \n                target, \n                unset_relationship_props<T0, T1>(graph, target, ctx)\n            );\n            let event = RelationshipRemoved {\n                graph_id: object::id<AccountGraph<T0, T1>>(graph), \n                source: sender, \n                target: target,\n            };\n            event::emit<RelationshipRemoved>(event);\n            i = i + 1;\n        };\n        result_map\n    }\n\n    public fun set_account_props<T: copy + drop + store>(\n        graph: &mut AccountGraph<T>,\n        props: T,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T> {\n        let sender = tx_context::sender(ctx);\n        let account_props = &mut graph.account_props;\n        let result = if (table::contains<address, T>(account_props, sender)) {\n            let existing_props = table::borrow_mut<address, T>(account_props, sender);\n            *existing_props = props;\n            option::some<T>(*existing_props)\n        } else {\n            table::add<address, T>(account_props, sender, props);\n            option::none<T>()\n        };\n        let event = AccountPropsSet<T>{\n            graph_id: object::id<AccountGraph<T>>(graph), \n            node: sender, \n            props: props,\n        };\n        event::emit<AccountPropsSet<T>>(event);\n        result\n    }\n\n    public fun unset_account_props<T0: copy + drop + store, T1: copy + drop + store>(\n        accountGraph: &mut AccountGraph<T0, T1>,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T0> {\n        let sender = tx_context::sender(ctx);\n        let account_props = &mut accountGraph.account_props;\n        if (table::contains<address, T0>(account_props, sender)) {\n            let props = table::remove<address, T0>(account_props, sender);\n            let unset_event = AccountPropsUnset<T0>{\n                graph_id: object::id<AccountGraph<T0, T1>>(accountGraph), \n                node: sender, \n                props: props,\n            };\n            event::emit<AccountPropsUnset<T0>>(unset_event);\n            option::some<T0>(props)\n        } else {\n            option::none<T0>()\n        }\n    }\n\n    public fun set_relationship_props<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        target: address,\n        props: T1,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T1> {\n        let sender = tx_context::sender(ctx);\n        assert!(relationship_exists<T0, T1>(graph, sender, target), 2);\n        let relationship_props = &mut graph.relationship_props;\n        let key = RelationshipKey {\n            source: sender,\n            target: target,\n        };\n        let result = if (table::contains<RelationshipKey, T1>(relationship_props, key)) {\n            let existing_props = table::borrow_mut<RelationshipKey, T1>(relationship_props, key);\n            *existing_props = props;\n            option::some<T1>(*existing_props)\n        } else {\n            table::add<RelationshipKey, T1>(relationship_props, key, props);\n            option::none<T1>()\n        };\n        let event = RelationshipPropsSet<T1> {\n            graph_id: object::id<AccountGraph<T0, T1>>(graph),\n            source: sender,\n            target: target,\n            props: props,\n        };\n        event::emit<RelationshipPropsSet<T1>>(event);\n        result\n    }\n\n    public fun unset_relationship_props<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        target: address,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T1> {\n        let sender = tx_context::sender(ctx);\n        let relationship_props = &mut graph.relationship_props;\n        let key = RelationshipKey {\n            source: sender,\n            target,\n        };\n        if (table::contains<RelationshipKey, T1>(relationship_props, &key)) {\n            let props = table::remove<RelationshipKey, T1>(relationship_props, &key);\n            let event = RelationshipPropsUnset<T1> {\n                graph_id: object::id<AccountGraph<T0, T1>>(graph),\n                source: sender,\n                target,\n                props,\n            };\n            event::emit<RelationshipPropsUnset<T1>>(event);\n            option::some(props)\n        } else {\n            option::none<T1>()\n        }\n    }\n}"
}