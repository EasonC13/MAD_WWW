{
    "allowlist_rule": "// Decompiled by MAD\nmodule 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::allowlist_rule {\n\n    // ----- Use Statements -----\n\n    use sui::token;\n    use sui::bag;\n    use sui::tx_context;\n    use std::vector;\n    use std::option;\n\n    // ----- Structs -----\n\n    struct Allowlist has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    fun config<T>(\n        token_policy: &token::TokenPolicy<T>\n    ): &bag::Bag {\n        let allowlist = Allowlist { dummy_field: false };\n        token::rule_config<T, Allowlist, bag::Bag>(allowlist, token_policy)\n    }\n\n    fun config_mut<T>(\n        token_policy: &mut token::TokenPolicy<T>,\n        token_policy_cap: &token::TokenPolicyCap<T>\n    ): &mut bag::Bag {\n        let allowlist = Allowlist { dummy_field: false };\n        token::rule_config_mut<T, Allowlist, bag::Bag>(allowlist, token_policy, token_policy_cap)\n    }\n\n    fun has_config<T>(\n        token_policy: &token::TokenPolicy<T>\n    ): bool {\n        token::has_rule_config_with_type<T, Allowlist, bag::Bag>(token_policy)\n    }\n\n    public fun verify<T>(\n        token_policy: &token::TokenPolicy<T>,\n        action_request: &mut token::ActionRequest<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(has_config<T>(token_policy), 0);\n        let config = config<T>(token_policy);\n        let recipient = token::recipient(action_request);\n        assert!(\n            bag::contains(config, token::sender(action_request)),\n            0\n        );\n        if (option::is_some(&recipient)) {\n            assert!(\n                bag::contains(config, *option::borrow(&recipient)),\n                0\n            );\n        };\n        let allowlist = Allowlist { dummy_field: false };\n        token::add_approval(allowlist, action_request, ctx);\n    }\n\n    public fun add_records<T>(\n        token_policy: &mut token::TokenPolicy<T>,\n        token_policy_cap: &token::TokenPolicyCap<T>,\n        addresses: vector<address>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        if (!has_config<T>(token_policy)) {\n            let allowlist = Allowlist { dummy_field: false };\n            token::add_rule_config<T, Allowlist, bag::Bag>(\n                allowlist,\n                token_policy,\n                token_policy_cap,\n                bag::new(ctx),\n                ctx\n            );\n        };\n        while (vector::length(&addresses) > 0) {\n            let address = vector::pop_back(&mut addresses);\n            bag::add(config_mut<T>(token_policy, token_policy_cap), address, true);\n        };\n    }\n\n    public fun remove_records<T>(\n        token_policy: &mut token::TokenPolicy<T>,\n        policy_cap: &token::TokenPolicyCap<T>,\n        addresses: vector<address>\n    ) {\n        while (vector::length(&addresses) > 0) {\n            let address = vector::pop_back(&mut addresses);\n            bag::remove(config_mut(token_policy, policy_cap), address);\n        };\n    }\n}",
    "coffee": "// Decompiled by MAD\nmodule 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::coffee {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::coin;\n    use sui::balance;\n    use sui::sui;\n    use sui::tx_context;\n    use std::option;\n    use sui::url;\n    use sui::transfer;\n    use sui::token;\n    use sui::event;\n\n    // ----- Structs -----\n\n    struct COFFEE has drop {\n        dummy_field: bool,\n    }\n\n    struct CoffeePurchased has copy, drop, store {\n        dummy_field: bool,\n    }\n\n    struct CoffeeShop has key {\n        id: object::UID,\n        coffee_points: coin::TreasuryCap<COFFEE>,\n        balance: balance::Balance<sui::SUI>,\n    }\n\n    // ----- Functions -----\n\n    fun init(\n        coffee: COFFEE,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let (coffee_points, metadata) = coin::create_currency<COFFEE>(\n            coffee,\n            0,\n            b\"COFFEE\",\n            b\"Coffee Point\",\n            b\"Buy 4 coffees and get 1 free\",\n            option::none<url::Url>(),\n            ctx\n        );\n        transfer::public_freeze_object(metadata);\n        let coffee_shop = CoffeeShop {\n            id: object::new(ctx),\n            coffee_points,\n            balance: balance::zero<sui::SUI>(),\n        };\n        transfer::share_object(coffee_shop);\n    }\n\n    public fun buy_coffee(\n        shop: &mut CoffeeShop,\n        payment: coin::Coin<sui::SUI>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(coin::value(&payment) > 10000000000, 0);\n\n        let mint_amount = 1;\n        let mint_result = token::mint(&mut shop.coffee_points, mint_amount, ctx);\n        let transfer_result = token::transfer(mint_result, tx_context::sender(ctx), ctx);\n        let _ = token::confirm_with_treasury_cap(&mut shop.coffee_points, transfer_result, ctx);\n\n        coin::put(&mut shop.balance, payment);\n\n        let purchase_event = CoffeePurchased { dummy_field: false };\n        event::emit(purchase_event);\n    }\n\n    public fun claim_free(\n        coffee_shop: &mut CoffeeShop,\n        coffee_token: token::Token<COFFEE>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(token::value(&coffee_token) == 4, 0);\n        let (_, _, _, _) = token::confirm_with_treasury_cap(\n            &mut coffee_shop.coffee_points,\n            token::spend(coffee_token, ctx),\n            ctx\n        );\n        event::emit<CoffeePurchased>(CoffeePurchased {\n            dummy_field: false\n        });\n    }\n\n    public fun transfer(\n        coffee_shop: &mut CoffeeShop,\n        coffee_token: token::Token<COFFEE>,\n        recipient: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(token::value(&coffee_token) > 1, 1);\n        let (_, _, _, _) = token::confirm_with_treasury_cap(\n            &mut coffee_shop.coffee_points,\n            token::transfer(coffee_token, recipient, ctx),\n            ctx\n        );\n        token::burn(\n            &mut coffee_shop.coffee_points,\n            token::split(&mut coffee_token, 1, ctx)\n        );\n    }\n}",
    "denylist_rule": "// Decompiled by MAD\nmodule 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::denylist_rule {\n\n    // ----- Use Statements -----\n\n    use sui::token;\n    use sui::bag;\n    use sui::tx_context;\n    use std::vector;\n    use std::option;\n\n    // ----- Structs -----\n\n    struct Denylist has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    fun config<T>(\n        token_policy: &token::TokenPolicy<T>\n    ): &bag::Bag {\n        let denylist = Denylist { dummy_field: false };\n        token::rule_config<T, Denylist, bag::Bag>(denylist, token_policy)\n    }\n\n    fun config_mut<T>(\n        token_policy: &mut token::TokenPolicy<T>,\n        token_policy_cap: &token::TokenPolicyCap<T>\n    ): &mut bag::Bag {\n        let denylist = Denylist { dummy_field: false };\n        token::rule_config_mut<T, Denylist, bag::Bag>(denylist, token_policy, token_policy_cap)\n    }\n\n    fun has_config<T>(\n        token_policy: &token::TokenPolicy<T>\n    ): bool {\n        token::has_rule_config_with_type<T, Denylist, bag::Bag>(token_policy)\n    }\n\n    public fun verify<T>(\n        policy: &token::TokenPolicy<T>,\n        request: &mut token::ActionRequest<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        if (!has_config<T>(policy)) {\n            let denylist = Denylist { dummy_field: false };\n            token::add_approval<T, Denylist>(denylist, request, ctx);\n            return\n        };\n\n        let config = config<T>(policy);\n        let recipient = token::recipient(request);\n        assert!(\n            !bag::contains<address>(config, token::sender(request)),\n            0\n        );\n\n        if (option::is_some(&recipient)) {\n            assert!(\n                !bag::contains<address>(config, *option::borrow(&recipient)),\n                0\n            );\n        };\n\n        let denylist = Denylist { dummy_field: false };\n        token::add_approval<T, Denylist>(denylist, request, ctx);\n    }\n\n    public fun add_records<T>(\n        token_policy: &mut token::TokenPolicy<T>,\n        token_policy_cap: &token::TokenPolicyCap<T>,\n        addresses: vector<address>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        if (!has_config<T>(token_policy)) {\n            let denylist = Denylist { dummy_field: false };\n            token::add_rule_config<T, Denylist, bag::Bag>(\n                denylist,\n                token_policy,\n                token_policy_cap,\n                bag::new(ctx),\n                ctx\n            );\n        };\n        while (vector::length(&addresses) > 0) {\n            let address = vector::pop_back(&mut addresses);\n            bag::add(config_mut<T>(token_policy, token_policy_cap), address, true);\n        };\n    }\n\n    public fun remove_records<T>(\n        token_policy: &mut token::TokenPolicy<T>,\n        policy_cap: &token::TokenPolicyCap<T>,\n        addresses: vector<address>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let config = config_mut(token_policy, policy_cap);\n        while (vector::length(&addresses) > 0) {\n            let address = vector::pop_back(&mut addresses);\n            if (bag::contains(config, address)) {\n                bag::remove<address, bool>(config, address);\n                continue\n            };\n        };\n    }\n}",
    "gem": "// Decompiled by MAD\nmodule 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::gem {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::sui;\n    use sui::coin;\n    use sui::tx_context;\n    use std::option;\n    use sui::url;\n    use sui::token;\n    use sui::transfer;\n    use std::string;\n\n    // ----- Structs -----\n\n    struct GEM has drop {\n        dummy_field: bool,\n    }\n\n    struct GemStore has key {\n        id: object::UID,\n        profits: balance::Balance<sui::SUI>,\n        gem_treasury: coin::TreasuryCap<GEM>,\n    }\n\n    // ----- Functions -----\n\n    fun init(\n        gem: GEM,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let (gem_treasury, coin_metadata) = coin::create_currency<GEM>(\n            gem,\n            0,\n            b\"GEM\",\n            b\"Capy Gems\",\n            b\"In-game currency for Capy Miners\",\n            option::none<url::Url>(),\n            ctx\n        );\n\n        let (token_policy, token_policy_cap) = token::new_policy<GEM>(&gem_treasury, ctx);\n\n        token::allow<GEM>(&mut token_policy, &token_policy_cap, buy_action(), ctx);\n        token::allow<GEM>(&mut token_policy, &token_policy_cap, token::spend_action(), ctx);\n\n        let gem_store = GemStore {\n            id: object::new(ctx),\n            profits: balance::zero<sui::SUI>(),\n            gem_treasury,\n        };\n\n        transfer::share_object(gem_store);\n        transfer::public_freeze_object(coin_metadata);\n        transfer::public_transfer(token_policy_cap, tx_context::sender(ctx));\n        token::share_policy(token_policy);\n    }\n\n    public fun buy_gems(\n        store: &mut GemStore,\n        payment: coin::Coin<sui::SUI>,\n        ctx: &mut tx_context::TxContext\n    ): (token::Token<GEM>, token::ActionRequest<GEM>) {\n        let payment_value = coin::value(&payment);\n        let gem_amount = if (payment_value == 10000000000) {\n            100\n        } else {\n            let amount = if (payment_value == 100000000000) {\n                5000\n            } else {\n                assert!(payment_value == 1000000000000, 0);\n                100000\n            };\n            amount\n        };\n        coin::put(&mut store.profits, payment);\n        (\n            token::mint(&mut store.gem_treasury, gem_amount, ctx),\n            token::new_request(\n                buy_action(),\n                gem_amount,\n                option::none(),\n                option::none(),\n                ctx\n            )\n        )\n    }\n\n    public fun buy_action(): string::String {\n        string::utf8(b\"buy\")\n    }\n}",
    "limiter_rule": "// Decompiled by MAD\nmodule 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::limiter_rule {\n\n    // ----- Use Statements -----\n\n    use sui::vec_map;\n    use std::string;\n    use sui::token;\n    use sui::tx_context;\n\n    // ----- Structs -----\n\n    struct Config has drop, store {\n        limits: vec_map::VecMap<string::String, u64>,\n    }\n\n    struct Limiter has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    public fun verify<T>(\n        policy: &token::TokenPolicy<T>,\n        request: &mut token::ActionRequest<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        if (!token::has_rule_config<T, Limiter>(policy)) {\n            let approval = Limiter { dummy_field: false };\n            token::add_approval<T, Limiter>(approval, request, ctx);\n            return\n        };\n\n        let approval = Limiter { dummy_field: false };\n        let config = token::rule_config<T, Limiter, Config>(approval, policy);\n        let action = token::action(request);\n\n        if (!vec_map::contains(&config.limits, &action)) {\n            let approval = Limiter { dummy_field: false };\n            token::add_approval<T, Limiter>(approval, request, ctx);\n            return\n        };\n\n        let action = token::action(request);\n        assert!(\n            token::amount(request) <= *vec_map::get(&config.limits, &action),\n            0\n        );\n\n        let approval = Limiter { dummy_field: false };\n        token::add_approval<T, Limiter>(approval, request, ctx);\n    }\n\n    public fun set_config<T>(\n        token_policy: &mut token::TokenPolicy<T>,\n        token_policy_cap: &token::TokenPolicyCap<T>,\n        limits: vec_map::VecMap<string::String, u64>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        if (!token::has_rule_config<T, Limiter>(token_policy)) {\n            let config = Config { limits };\n            let limiter = Limiter { dummy_field: false };\n            token::add_rule_config<T, Limiter, Config>(limiter, token_policy, token_policy_cap, config, ctx);\n        } else {\n            let limiter = Limiter { dummy_field: false };\n            token::rule_config_mut<T, Limiter, Config>(limiter, token_policy, token_policy_cap).limits = limits;\n        };\n    }\n\n    public fun get_config<T>(\n        token_policy: &token::TokenPolicy<T>\n    ): vec_map::VecMap<string::String, u64> {\n        let limiter = Limiter { dummy_field: false };\n        token::rule_config<T, Limiter, Config>(limiter, token_policy).limits\n    }\n}",
    "loyalty": "// Decompiled by MAD\nmodule 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::loyalty {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::tx_context;\n    use sui::coin;\n    use std::option;\n    use sui::url;\n    use sui::token;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct Gift has store, key {\n        id: object::UID,\n    }\n\n    struct GiftShop has drop {\n        dummy_field: bool,\n    }\n\n    struct LOYALTY has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    fun init(\n        loyalty: LOYALTY,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let (treasury_cap, coin_metadata) = coin::create_currency<LOYALTY>(\n            loyalty,\n            0,\n            b\"LOY\",\n            b\"Loyalty Token\",\n            b\"Token for Loyalty\",\n            option::none<url::Url>(),\n            ctx\n        );\n\n        let (token_policy, token_policy_cap) = token::new_policy<LOYALTY>(&treasury_cap, ctx);\n\n        token::add_rule_for_action<LOYALTY, GiftShop>(\n            &mut token_policy,\n            &token_policy_cap,\n            token::spend_action(),\n            ctx\n        );\n\n        token::share_policy<LOYALTY>(token_policy);\n        transfer::public_freeze_object(coin_metadata);\n        transfer::public_transfer(token_policy_cap, tx_context::sender(ctx));\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n    }\n\n    public fun reward_user(\n        treasury_cap: &mut coin::TreasuryCap<LOYALTY>,\n        amount: u64,\n        recipient: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let loyalty_coin = token::mint(treasury_cap, amount, ctx);\n        let transferred_coin = token::transfer(loyalty_coin, recipient, ctx);\n        token::confirm_with_treasury_cap(treasury_cap, transferred_coin, ctx);\n    }\n\n    public fun buy_a_gift(\n        loyalty_token: token::Token<LOYALTY>,\n        ctx: &mut tx_context::TxContext\n    ): (Gift, token::ActionRequest<LOYALTY>) {\n        assert!(token::value(&loyalty_token) == 10, 0);\n        let gift = Gift { id: object::new(ctx) };\n        let action_request = token::spend(loyalty_token, ctx);\n        let gift_shop = GiftShop { dummy_field: false };\n        token::add_approval(gift_shop, &mut action_request, ctx);\n        (gift, action_request)\n    }\n}",
    "regulated_token": "// Decompiled by MAD\nmodule 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::regulated_token {\n\n    // ----- Use Statements -----\n\n    use sui::tx_context;\n    use sui::coin;\n    use std::option;\n    use sui::url;\n    use sui::transfer;\n    use sui::token;\n    use 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::denylist_rule;\n    use 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::limiter_rule;\n    use sui::vec_map;\n    use std::string;\n    use 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::allowlist_rule;\n\n    // ----- Structs -----\n\n    struct REGULATED_TOKEN has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    fun create_currency<T: drop>(\n        currency: T,\n        ctx: &mut tx_context::TxContext\n    ): coin::TreasuryCap<T> {\n        let (treasury_cap, coin_metadata) = coin::create_currency(\n            currency,\n            6,\n            b\"REG\",\n            b\"Regulated Coin\",\n            b\"Coin that illustrates different regulatory requirements\",\n            option::none<url::Url>(),\n            ctx\n        );\n        transfer::public_freeze_object(coin_metadata);\n        treasury_cap\n    }\n\n    fun init(\n        regulated_token: REGULATED_TOKEN,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let treasury_cap = create_currency<REGULATED_TOKEN>(regulated_token, ctx);\n        let (policy, policy_cap) = token::new_policy<REGULATED_TOKEN>(&treasury_cap, ctx);\n        let token_policy = policy;\n        let token_policy_cap = policy_cap;\n        set_rules<REGULATED_TOKEN>(&mut token_policy, &token_policy_cap, ctx);\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n        transfer::public_transfer(token_policy_cap, tx_context::sender(ctx));\n        token::share_policy(token_policy);\n    }\n\n    public(friend) fun set_rules<T>(\n        token_policy: &mut token::TokenPolicy<T>,\n        token_policy_cap: &token::TokenPolicyCap<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        token::add_rule_for_action<T, denylist_rule::Denylist>(\n            token_policy,\n            token_policy_cap,\n            token::spend_action(),\n            ctx\n        );\n        token::add_rule_for_action<T, denylist_rule::Denylist>(\n            token_policy,\n            token_policy_cap,\n            token::to_coin_action(),\n            ctx\n        );\n        token::add_rule_for_action<T, denylist_rule::Denylist>(\n            token_policy,\n            token_policy_cap,\n            token::transfer_action(),\n            ctx\n        );\n        token::add_rule_for_action<T, denylist_rule::Denylist>(\n            token_policy,\n            token_policy_cap,\n            token::from_coin_action(),\n            ctx\n        );\n        token::add_rule_for_action<T, limiter_rule::Limiter>(\n            token_policy,\n            token_policy_cap,\n            token::transfer_action(),\n            ctx\n        );\n        token::add_rule_for_action<T, limiter_rule::Limiter>(\n            token_policy,\n            token_policy_cap,\n            token::to_coin_action(),\n            ctx\n        );\n        let config = vec_map::empty<string::String, u64>();\n        vec_map::insert(&mut config, token::transfer_action(), 3000000000);\n        vec_map::insert(&mut config, token::to_coin_action(), 1000000000);\n        limiter_rule::set_config<T>(\n            token_policy,\n            token_policy_cap,\n            config,\n            ctx\n        );\n        token::add_rule_for_action<T, allowlist_rule::Allowlist>(\n            token_policy,\n            token_policy_cap,\n            token::from_coin_action(),\n            ctx\n        );\n        token::add_rule_for_action<T, allowlist_rule::Allowlist>(\n            token_policy,\n            token_policy_cap,\n            token::transfer_action(),\n            ctx\n        );\n    }\n}",
    "simple_token": "// Decompiled by MAD\nmodule 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::simple_token {\n\n    // ----- Use Statements -----\n\n    use sui::tx_context;\n    use sui::coin;\n    use std::option;\n    use sui::url;\n    use sui::transfer;\n    use sui::token;\n    use 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::denylist_rule;\n\n    // ----- Structs -----\n\n    struct SIMPLE_TOKEN has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    fun create_currency<T: drop>(\n        currency: T,\n        ctx: &mut tx_context::TxContext\n    ): coin::TreasuryCap<T> {\n        let (treasury_cap, coin_metadata) = coin::create_currency(\n            currency,\n            6,\n            b\"SMPL\",\n            b\"Simple Token\",\n            b\"Token that showcases denylist\",\n            option::none<url::Url>(),\n            ctx\n        );\n        transfer::public_freeze_object(coin_metadata);\n        treasury_cap\n    }\n\n    fun init(\n        simple_token: SIMPLE_TOKEN,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let treasury_cap = create_currency(simple_token, ctx);\n        let (policy_cap, token_policy) = token::new_policy(&treasury_cap, ctx);\n        let token_policy_cap = token_policy;\n        let policy_cap_copy = policy_cap;\n        set_rules(&mut policy_cap_copy, &token_policy_cap, ctx);\n        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));\n        transfer::public_transfer(token_policy_cap, tx_context::sender(ctx));\n        token::share_policy(policy_cap_copy);\n    }\n\n    public(friend) fun set_rules<T>(\n        token_policy: &mut token::TokenPolicy<T>,\n        policy_cap: &token::TokenPolicyCap<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        token::add_rule_for_action<T, denylist_rule::Denylist>(\n            token_policy,\n            policy_cap,\n            token::spend_action(),\n            ctx\n        );\n        token::add_rule_for_action<T, denylist_rule::Denylist>(\n            token_policy,\n            policy_cap,\n            token::to_coin_action(),\n            ctx\n        );\n        token::add_rule_for_action<T, denylist_rule::Denylist>(\n            token_policy,\n            policy_cap,\n            token::transfer_action(),\n            ctx\n        );\n        token::add_rule_for_action<T, denylist_rule::Denylist>(\n            token_policy,\n            policy_cap,\n            token::from_coin_action(),\n            ctx\n        );\n    }\n}",
    "sword": "// Decompiled by MAD\nmodule 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::sword {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::token;\n    use 0x9b2e92c21c2ba3e0cf04370451e75b02eb1556fafd254b44d597b6c4bf440f1d::gem;\n    use sui::tx_context;\n\n    // ----- Structs -----\n\n    struct Sword has store, key {\n        id: object::UID,\n    }\n\n    // ----- Functions -----\n\n    public fun buy_sword(\n        gem_token: token::Token<gem::GEM>,\n        ctx: &mut tx_context::TxContext\n    ): (Sword, token::ActionRequest<gem::GEM>) {\n        assert!(\n            10 == token::value(&gem_token),\n            0\n        );\n        let sword = Sword { id: object::new(ctx) };\n        (\n            sword,\n            token::spend(gem_token, ctx)\n        )\n    }\n}"
}