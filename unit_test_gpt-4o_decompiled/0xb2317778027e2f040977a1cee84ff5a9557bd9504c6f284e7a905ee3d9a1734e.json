{
    "lock": "// Decompiled by MAD\nmodule 0xb2317778027e2f040977a1cee84ff5a9557bd9504c6f284e7a905ee3d9a1734e::lock {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::tx_context;\n    use sui::event;\n    use sui::dynamic_object_field;\n\n    // ----- Structs -----\n\n    struct Key has store, key {\n        id: object::UID,\n    }\n\n    struct LockCreated has copy, drop {\n        lock_id: object::ID,\n        key_id: object::ID,\n        creator: address,\n        item_id: object::ID,\n    }\n\n    struct LockDestroyed has copy, drop {\n        lock_id: object::ID,\n    }\n\n    struct Locked<phantom T0: store + key> has store, key {\n        id: object::UID,\n        key: object::ID,\n    }\n\n    struct LockedObjectKey has copy, drop, store {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    public fun lock<T: store + key>(\n        item: T,\n        ctx: &mut tx_context::TxContext\n    ): (Locked<T>, Key) {\n        let key = Key { id: object::new(ctx) };\n        let locked = Locked<T> {\n            id: object::new(ctx),\n            key: object::id(&key),\n        };\n        event::emit<LockCreated>(LockCreated {\n            lock_id: object::id(&locked),\n            key_id: object::id(&key),\n            creator: tx_context::sender(ctx),\n            item_id: object::id(&item),\n        });\n        let locked_object_key = LockedObjectKey { dummy_field: false };\n        dynamic_object_field::add(&mut locked.id, locked_object_key, item);\n        (locked, key)\n    }\n\n    public fun unlock<T: store + key>(\n        locked: Locked<T>,\n        key: Key\n    ): T {\n        assert!(locked.key == object::id(&key), 0);\n        let Key { id: key_id } = key;\n        object::delete(key_id);\n\n        let locked_object_key = LockedObjectKey { dummy_field: false };\n        let lock_destroyed_event = LockDestroyed {\n            lock_id: object::id(&locked)\n        };\n        event::emit(lock_destroyed_event);\n\n        let Locked { id: locked_id, key: _ } = locked;\n        object::delete(locked_id);\n\n        dynamic_object_field::remove(&mut locked.id, locked_object_key)\n    }\n}",
    "owned": "// Decompiled by MAD\nmodule 0xb2317778027e2f040977a1cee84ff5a9557bd9504c6f284e7a905ee3d9a1734e::owned {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use 0xb2317778027e2f040977a1cee84ff5a9557bd9504c6f284e7a905ee3d9a1734e::lock;\n    use sui::tx_context;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct Escrow<T0: store + key> has key {\n        id: object::UID,\n        sender: address,\n        recipient: address,\n        exchange_key: object::ID,\n        escrowed_key: object::ID,\n        escrowed: T0,\n    }\n\n    // ----- Functions -----\n\n    public fun create<T: store + key>(\n        key: lock::Key,\n        locked: lock::Locked<T>,\n        exchange_key: object::ID,\n        recipient: address,\n        owner: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let escrow = Escrow<T> {\n            id: object::new(ctx),\n            sender: tx_context::sender(ctx),\n            recipient,\n            exchange_key,\n            escrowed_key: object::id(&key),\n            escrowed: lock::unlock(locked, key),\n        };\n        transfer::transfer(escrow, owner);\n    }\n\n    public fun swap<T0: store + key, T1: store + key>(\n        escrow1: Escrow<T0>,\n        escrow2: Escrow<T1>\n    ) {\n        let Escrow {\n            id: id1,\n            sender: sender1,\n            recipient: recipient1,\n            exchange_key: exchange_key1,\n            escrowed_key: escrowed_key1,\n            escrowed: escrowed1,\n        } = escrow1;\n\n        let Escrow {\n            id: id2,\n            sender: sender2,\n            recipient: recipient2,\n            exchange_key: exchange_key2,\n            escrowed_key: escrowed_key2,\n            escrowed: escrowed2,\n        } = escrow2;\n\n        object::delete(id1);\n        object::delete(id2);\n\n        assert!(sender1 == recipient2, 0);\n        assert!(sender2 == recipient1, 0);\n        assert!(escrowed_key1 == exchange_key2, 1);\n        assert!(escrowed_key2 == exchange_key1, 1);\n\n        transfer::public_transfer(escrowed1, recipient1);\n        transfer::public_transfer(escrowed2, recipient2);\n    }\n\n    public fun return_to_sender<T: store + key>(\n        escrow: Escrow<T>\n    ) {\n        let Escrow {\n            id,\n            sender,\n            recipient: _,\n            exchange_key: _,\n            escrowed_key: _,\n            escrowed,\n        } = escrow;\n        object::delete(id);\n        transfer::public_transfer(escrowed, sender);\n    }\n}",
    "shared": "// Decompiled by MAD\nmodule 0xb2317778027e2f040977a1cee84ff5a9557bd9504c6f284e7a905ee3d9a1734e::shared {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::tx_context;\n    use sui::event;\n    use sui::dynamic_object_field;\n    use sui::transfer;\n    use 0xb2317778027e2f040977a1cee84ff5a9557bd9504c6f284e7a905ee3d9a1734e::lock;\n\n    // ----- Structs -----\n\n    struct Escrow<phantom T0: store + key> has store, key {\n        id: object::UID,\n        sender: address,\n        recipient: address,\n        exchange_key: object::ID,\n    }\n\n    struct EscrowCancelled has copy, drop {\n        escrow_id: object::ID,\n    }\n\n    struct EscrowCreated has copy, drop {\n        escrow_id: object::ID,\n        key_id: object::ID,\n        sender: address,\n        recipient: address,\n        item_id: object::ID,\n    }\n\n    struct EscrowSwapped has copy, drop {\n        escrow_id: object::ID,\n    }\n\n    struct EscrowedObjectKey has copy, drop, store {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    public fun create<T: store + key>(\n        item: T,\n        exchange_key: object::ID,\n        recipient: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let escrow = Escrow<T> {\n            id: object::new(ctx),\n            sender: tx_context::sender(ctx),\n            recipient,\n            exchange_key,\n        };\n        let escrow_id = object::id(&escrow);\n        let item_id = object::id(&item);\n        event::emit<EscrowCreated>(EscrowCreated {\n            escrow_id,\n            key_id: exchange_key,\n            sender: escrow.sender,\n            recipient,\n            item_id,\n        });\n        let escrowed_object_key = EscrowedObjectKey { dummy_field: false };\n        dynamic_object_field::add(&mut escrow.id, escrowed_object_key, item);\n        transfer::public_share_object(escrow);\n    }\n\n    public fun swap<T0: store + key, T1: store + key>(\n        escrow: Escrow<T0>,\n        key: lock::Key,\n        locked: lock::Locked<T1>,\n        ctx: &tx_context::TxContext\n    ): T0 {\n        let escrowed_object_key = EscrowedObjectKey { dummy_field: false };\n        let Escrow {\n            id,\n            sender,\n            recipient,\n            exchange_key,\n        } = escrow;\n        assert!(recipient == tx_context::sender(ctx), 0);\n        assert!(exchange_key == object::id(&key), 1);\n        transfer::public_transfer(\n            lock::unlock(locked, key),\n            sender\n        );\n        event::emit<EscrowSwapped>(EscrowSwapped {\n            escrow_id: object::uid_to_inner(&id)\n        });\n        object::delete(id);\n        dynamic_object_field::remove<EscrowedObjectKey, T0>(&mut escrow.id, escrowed_object_key)\n    }\n\n    public fun return_to_sender<V: key + store>(\n        escrow: Escrow<V>,\n        ctx: &tx_context::TxContext\n    ): V {\n        let escrow_id = object::id(&escrow);\n        event::emit<EscrowCancelled>(EscrowCancelled { escrow_id });\n\n        let escrowed_object_key = EscrowedObjectKey { dummy_field: false };\n\n        let Escrow {\n            id,\n            sender,\n            recipient: _,\n            exchange_key: _,\n        } = escrow;\n\n        assert!(sender == tx_context::sender(ctx), 0);\n\n        object::delete(id);\n\n        dynamic_object_field::remove<EscrowedObjectKey, V>(&mut escrow.id, escrowed_object_key)\n    }\n}"
}