{
    "epoch_time_lock": "// Decompiled by MAD\nmodule 0x99465a35a8daacf2486231d2d13dfaa87ee04ffba6662df845d5998adf9b9c06::epoch_time_lock {\n\n    // ----- Use Statements -----\n\n    use sui::tx_context;\n\n    // ----- Structs -----\n\n    struct EpochTimeLock has copy, store {\n        epoch: u64,\n    }\n\n    // ----- Functions -----\n\n    public fun new(\n        epoch: u64,\n        ctx: &tx_context::TxContext\n    ): EpochTimeLock {\n        assert!(tx_context::epoch(ctx) < epoch, 0);\n        EpochTimeLock { epoch }\n    }\n\n    public fun destroy(\n        lock: EpochTimeLock,\n        ctx: &tx_context::TxContext\n    ) {\n        let EpochTimeLock { epoch } = lock;\n        assert!(tx_context::epoch(ctx) >= epoch, 1);\n    }\n\n    public fun epoch(lock: &EpochTimeLock): u64 {\n        lock.epoch\n    }\n}",
    "locked_stake": "// Decompiled by MAD\nmodule 0x99465a35a8daacf2486231d2d13dfaa87ee04ffba6662df845d5998adf9b9c06::locked_stake {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::vec_map;\n    use 0x3::staking_pool;\n    use sui::balance;\n    use sui::sui;\n    use 0x99465a35a8daacf2486231d2d13dfaa87ee04ffba6662df845d5998adf9b9c06::epoch_time_lock;\n    use sui::tx_context;\n    use 0x3::sui_system;\n    use sui::coin;\n\n    // ----- Structs -----\n\n    struct LockedStake has key {\n        id: object::UID,\n        staked_sui: vec_map::VecMap<object::ID, staking_pool::StakedSui>,\n        sui: balance::Balance<sui::SUI>,\n        locked_until_epoch: epoch_time_lock::EpochTimeLock,\n    }\n\n    // ----- Functions -----\n\n    public fun new(\n        lock_epoch: u64,\n        ctx: &mut tx_context::TxContext\n    ): LockedStake {\n        LockedStake {\n            id: object::new(ctx),\n            staked_sui: vec_map::empty<object::ID, staking_pool::StakedSui>(),\n            sui: balance::zero<sui::SUI>(),\n            locked_until_epoch: epoch_time_lock::new(lock_epoch, ctx),\n        }\n    }\n\n    public fun unlock(\n        locked_stake: LockedStake,\n        ctx: &tx_context::TxContext\n    ): (vec_map::VecMap<object::ID, staking_pool::StakedSui>, balance::Balance<sui::SUI>) {\n        let LockedStake {\n            id,\n            staked_sui,\n            sui,\n            locked_until_epoch,\n        } = locked_stake;\n        \n        epoch_time_lock::destroy(locked_until_epoch, ctx);\n        object::delete(id);\n        \n        (staked_sui, sui)\n    }\n\n    public fun deposit_staked_sui(\n        locked_stake: &mut LockedStake,\n        staked_sui: staking_pool::StakedSui\n    ) {\n        let staked_sui_id = object::id(&staked_sui);\n        vec_map::insert(&mut locked_stake.staked_sui, staked_sui_id, staked_sui);\n    }\n\n    public fun deposit_sui(\n        locked_stake: &mut LockedStake,\n        sui_balance: balance::Balance<sui::SUI>\n    ) {\n        balance::join(&mut locked_stake.sui, sui_balance);\n    }\n\n    public fun stake(\n        locked_stake: &mut LockedStake,\n        sui_system_state: &mut sui_system::SuiSystemState,\n        amount: u64,\n        staker: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(\n            balance::value(&locked_stake.sui) >= amount,\n            0\n        );\n        let split_balance = balance::split(&mut locked_stake.sui, amount);\n        let coin = coin::from_balance(split_balance, ctx);\n        let stake_request = sui_system::request_add_stake_non_entry(sui_system_state, coin, staker, ctx);\n        deposit_staked_sui(locked_stake, stake_request);\n    }\n\n    public fun unstake(\n        locked_stake: &mut LockedStake,\n        sui_system_state: &mut sui_system::SuiSystemState,\n        stake_id: object::ID,\n        ctx: &mut tx_context::TxContext\n    ): u64 {\n        assert!(\n            vec_map::contains(&locked_stake.staked_sui, &stake_id),\n            1\n        );\n        let (_, staked_sui) = vec_map::remove(&mut locked_stake.staked_sui, &stake_id);\n        let withdrawn_sui = sui_system::request_withdraw_stake_non_entry(sui_system_state, staked_sui, ctx);\n        deposit_sui(locked_stake, withdrawn_sui);\n        balance::value(&withdrawn_sui)\n    }\n\n    public fun staked_sui(\n        locked_stake: &LockedStake\n    ): &vec_map::VecMap<object::ID, staking_pool::StakedSui> {\n        &locked_stake.staked_sui\n    }\n\n    public fun sui_balance(\n        locked_stake: &LockedStake\n    ): u64 {\n        balance::value<sui::SUI>(&locked_stake.sui)\n    }\n\n    public fun locked_until_epoch(\n        locked_stake: &LockedStake\n    ): u64 {\n        epoch_time_lock::epoch(&locked_stake.locked_until_epoch)\n    }\n}"
}