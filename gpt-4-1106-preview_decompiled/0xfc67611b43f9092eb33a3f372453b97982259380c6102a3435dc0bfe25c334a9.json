{
    "safe": "// Decompiled by SuiGPT\nmodule 0xfc67611b43f9092eb33a3f372453b97982259380c6102a3435dc0bfe25c334a9::safe {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::vec_set;\n    use sui::tx_context;\n    use sui::coin;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct OwnerCapability<phantom T0> has store, key {\n        id: object::UID,\n        safe_id: object::ID,\n    }\n\n    struct Safe<phantom T0> has key {\n        id: object::UID,\n        balance: balance::Balance<T0>,\n        allowed_safes: vec_set::VecSet<object::ID>,\n    }\n\n    struct TransferCapability<phantom T0> has store, key {\n        id: object::UID,\n        safe_id: object::ID,\n        amount: u64,\n    }\n\n    // ----- Functions -----\n\n    fun check_capability_validity<T>(\n        safe: &Safe<T>,\n        capability: &TransferCapability<T>\n    ) {\n        assert!(\n            object::id(safe) == capability.safe_id,\n            0\n        );\n        let capability_id = object::id(capability);\n        assert!(\n            vec_set::contains(&safe.allowed_safes, &capability_id),\n            2\n        );\n    }\n\n    fun check_owner_capability_validity<T>(\n        safe: &Safe<T>,\n        owner_capability: &OwnerCapability<T>\n    ) {\n        assert!(\n            object::id<Safe<T>>(safe) == owner_capability.safe_id,\n            1\n        );\n    }\n\n    fun create_capability_<T>(\n        safe: &mut Safe<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): TransferCapability<T> {\n        let cap_id = object::new(ctx);\n        vec_set::insert(&mut safe.allowed_safes, object::uid_to_inner(&cap_id));\n        TransferCapability<T> {\n            id: cap_id,\n            safe_id: object::uid_to_inner(&safe.id),\n            amount\n        }\n    }\n\n    public entry fun create<T>(\n        coin: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let balance = coin::into_balance(coin);\n        let owner_capability = create_<T>(balance, ctx);\n        transfer::public_transfer(owner_capability, tx_context::sender(ctx));\n    }\n\n    public entry fun create_empty<T>(\n        ctx: &mut tx_context::TxContext\n    ) {\n        transfer::public_transfer(\n            create_<T>(balance::zero<T>(), ctx),\n            tx_context::sender(ctx)\n        );\n    }\n\n    public entry fun create_new_cap<T>(\n        safe: &mut Safe<T>,\n        owner_cap: &OwnerCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        check_owner_capability_validity(safe, owner_cap);\n        transfer::public_transfer(\n            create_capability_<T>(safe, amount, ctx),\n            tx_context::sender(ctx)\n        );\n    }\n\n    public entry fun debit_transfer<T>(\n        safe: &mut Safe<T>,\n        capability: &mut TransferCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        check_capability_validity(safe, capability);\n        assert!(capability.amount >= amount, 3);\n        capability.amount = capability.amount - amount;\n        let coin_to_transfer = coin::from_balance(balance::split(&mut safe.balance, amount), ctx);\n        transfer::public_transfer(coin_to_transfer, tx_context::sender(ctx));\n    }\n\n    public entry fun deposit<T>(\n        safe: &mut Safe<T>,\n        coin: coin::Coin<T>\n    ) {\n        deposit_(safe, coin::into_balance(coin));\n    }\n\n    public entry fun deposit_check_threshold<T>(\n        safe: &mut Safe<T>,\n        coin: coin::Coin<T>,\n        threshold: u64\n    ) {\n        assert!(coin::value(&coin) >= threshold, 4);\n        deposit_(safe, coin::into_balance(coin));\n    }\n\n    public entry fun revoke_transfer_capability<T>(\n        safe: &mut Safe<T>,\n        owner_capability: &OwnerCapability<T>,\n        safe_id: object::ID\n    ) {\n        check_owner_capability_validity(safe, owner_capability);\n        vec_set::remove(&mut safe.allowed_safes, &safe_id);\n    }\n\n    public entry fun self_revoke_transfer_capability<T>(\n        safe: &mut Safe<T>,\n        capability: &TransferCapability<T>\n    ) {\n        check_capability_validity(safe, capability);\n        let capability_id = object::id(capability);\n        vec_set::remove(&mut safe.allowed_safes, &capability_id);\n    }\n\n    public entry fun withdraw<T>(\n        safe: &mut Safe<T>,\n        owner_capability: &OwnerCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let coin = withdraw_(safe, owner_capability, amount);\n        transfer::public_transfer(\n            coin::from_balance(coin, ctx),\n            tx_context::sender(ctx)\n        );\n    }\n\n    public fun balance<T>(\n        safe: &Safe<T>\n    ): &balance::Balance<T> {\n        &safe.balance\n    }\n\n    public fun create_<T>(\n        balance: balance::Balance<T>,\n        ctx: &mut tx_context::TxContext\n    ): OwnerCapability<T> {\n        let safe = Safe<T> {\n            id: object::new(ctx),\n            balance,\n            allowed_safes: vec_set::empty<object::ID>(),\n        };\n        let owner_capability = OwnerCapability<T> {\n            id: object::new(ctx),\n            safe_id: object::id(&safe),\n        };\n        transfer::share_object(safe);\n        owner_capability\n    }\n\n    public fun deposit_<T>(\n        safe: &mut Safe<T>,\n        balance: balance::Balance<T>\n    ) {\n        balance::join(&mut safe.balance, balance);\n    }\n\n    public fun withdraw_<T>(\n        safe: &mut Safe<T>,\n        owner_capability: &OwnerCapability<T>,\n        amount: u64\n    ): balance::Balance<T> {\n        check_owner_capability_validity(safe, owner_capability);\n        balance::split(&mut safe.balance, amount)\n    }\n\n    public fun debit<T>(\n        safe: &mut Safe<T>,\n        capability: &mut TransferCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        check_capability_validity(safe, capability);\n        assert!(capability.amount >= amount, 3);\n        capability.amount = capability.amount - amount;\n        let split_balance = balance::split(&mut safe.balance, amount);\n        coin::from_balance(split_balance, ctx)\n    }\n\n    public fun create_transfer_capability<T>(\n        safe: &mut Safe<T>,\n        owner_capability: &OwnerCapability<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): TransferCapability<T> {\n        check_owner_capability_validity(safe, owner_capability);\n        create_capability_<T>(safe, amount, ctx)\n    }\n}"
}