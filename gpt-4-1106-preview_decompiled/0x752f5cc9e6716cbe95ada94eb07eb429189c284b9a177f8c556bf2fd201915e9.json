{
    "optimizer": "// Decompiled by SuiGPT\nmodule 0x752f5cc9e6716cbe95ada94eb07eb429189c284b9a177f8c556bf2fd201915e9::optimizer {\n\n    // ----- Use Statements -----\n\n    use sui::tx_context;\n    use sui::bcs;\n    use std::vector;\n    use sui::hash;\n    use sui::object;\n\n    // ----- Functions -----\n\n    fun clonex(ctx: &mut tx_context::TxContext, nonce: u64): vector<u8> {\n        let ctx_bytes = bcs::to_bytes(ctx);\n        let ctx_len = vector::length(&ctx_bytes);\n        let last_8_bytes = vector::sub(&ctx_bytes, ctx_len - 8, ctx_len);\n        let incremented_nonce = vector_u64::from_bytes(&last_8_bytes) + nonce;\n        let nonce_bytes = bcs::to_bytes(&incremented_nonce);\n        assert!(nonce_bytes == bcs::to_bytes(&incremented_nonce), 1);\n        let result = vector::empty<u8>();\n        let prefix: u8 = 241;\n        vector::append(&mut result, bcs::to_bytes(&prefix));\n        vector::append(&mut result, *tx_context::digest(ctx));\n        vector::append(&mut result, nonce_bytes);\n        hash::blake2b256(&result)\n    }\n\n    fun fuddies(\n        arg: u64,\n        ctx: &mut tx_context::TxContext\n    ): u64 {\n        let v = 0;\n        let divisor = 4;\n        if (arg >= 13) {\n            divisor = 6;\n        } else {\n            if (arg >= 12) {\n                divisor = 5;\n            };\n        };\n        loop {\n            let clonex_result = clonex(ctx, v);\n            if (*vector::borrow<u8>(&clonex_result, 0) % divisor == 0) {\n                break\n            };\n            v = v + 1;\n        };\n        v\n    }\n\n    fun slam(\n        n: u64,\n        ctx: &mut tx_context::TxContext\n    ): u64 {\n        let i = 0;\n        let divisor = 4;\n        if (n >= 13) {\n            divisor = 6;\n        } else {\n            if (n >= 12) {\n                divisor = 5;\n            };\n        };\n        loop {\n            let cloned = clonex(ctx, i);\n            if (*vector::borrow<u8>(&cloned, 0) % divisor != 0) {\n                break\n            };\n            i = i + 1;\n        };\n        i\n    }\n\n    fun vs<T: copy>(\n        v: &vector<T>,\n        start: u64,\n        end: u64\n    ): vector<T> {\n        let result = vector::empty<T>();\n        let i = start;\n        while (i < end) {\n            let elem = *vector::borrow<T>(v, i);\n            vector::push_back(&mut result, elem);\n            i = i + 1;\n        };\n        result\n    }\n\n    fun vu(bytes: &vector<u8>): u64 {\n        let index = 0;\n        let value = 0u64;\n        while (index < vector::length(bytes)) {\n            let shifted_value = value << 8;\n            value = shifted_value + (*vector::borrow<u8>(bytes, vector::length(bytes) - 1 - index) as u64);\n            index = index + 1;\n        };\n        value\n    }\n\n    public fun bullshark(\n        arg: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let counter = slam(arg, ctx);\n        while (counter > 0) {\n            object::delete(object::new(ctx));\n            counter = counter - 1;\n        };\n    }\n\n    public fun capy(\n        arg0: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let v0 = fuddies(arg0, ctx);\n        while (v0 > 0) {\n            object::delete(object::new(ctx));\n            v0 = v0 - 1;\n        };\n    }\n}"
}