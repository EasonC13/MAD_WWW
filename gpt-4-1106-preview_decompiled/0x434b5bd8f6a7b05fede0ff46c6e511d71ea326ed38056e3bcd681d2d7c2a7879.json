{
    "kiosk_lock_rule": "// Decompiled by SuiGPT\nmodule 0x434b5bd8f6a7b05fede0ff46c6e511d71ea326ed38056e3bcd681d2d7c2a7879::kiosk_lock_rule {\n\n    // ----- Use Statements -----\n\n    use sui::transfer_policy;\n    use sui::kiosk;\n\n    // ----- Structs -----\n\n    struct Config has drop, store {\n        dummy_field: bool,\n    }\n\n    struct Rule has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    public fun add<T>(\n        policy: &mut transfer_policy::TransferPolicy<T>,\n        cap: &transfer_policy::TransferPolicyCap<T>\n    ) {\n        let rule = Rule { dummy_field: false };\n        let config = Config { dummy_field: false };\n        transfer_policy::add_rule<T, Rule, Config>(rule, policy, cap, config);\n    }\n\n    public fun prove<T>(\n        request: &mut transfer_policy::TransferRequest<T>,\n        kiosk: &kiosk::Kiosk\n    ) {\n        let item = transfer_policy::item(request);\n        assert!(\n            kiosk::has_item(kiosk, item) && \n            kiosk::is_locked(kiosk, item),\n            0\n        );\n        let rule = Rule{ dummy_field: false };\n        transfer_policy::add_receipt<Rule>(rule, request);\n    }\n}",
    "royalty_rule": "// Decompiled by SuiGPT\nmodule 0x434b5bd8f6a7b05fede0ff46c6e511d71ea326ed38056e3bcd681d2d7c2a7879::royalty_rule {\n\n    // ----- Use Statements -----\n\n    use sui::transfer_policy;\n    use sui::coin;\n    use sui::sui;\n\n    // ----- Structs -----\n\n    struct Config has drop, store {\n        amount_bp: u16,\n        min_amount: u64,\n    }\n\n    struct Rule has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    public fun add<T: store + key>(\n        policy: &mut transfer_policy::TransferPolicy<T>,\n        cap: &transfer_policy::TransferPolicyCap<T>,\n        amount_bp: u16,\n        min_amount: u64\n    ) {\n        assert!(amount_bp <= 10000, 0);\n        let rule = Rule { dummy_field: false };\n        let config = Config {\n            amount_bp,\n            min_amount,\n        };\n        transfer_policy::add_rule<T, Rule, Config>(rule, policy, cap, config);\n    }\n\n    public fun pay<T: store + key>(\n        policy: &mut transfer_policy::TransferPolicy<T>,\n        request: &mut transfer_policy::TransferRequest<T>,\n        sui: coin::Coin<sui::SUI>\n    ) {\n        assert!(\n            coin::value(&sui) == fee_amount(policy, transfer_policy::paid(request)),\n            1\n        );\n        let rule = Rule { dummy_field: false };\n        transfer_policy::add_to_balance(rule, policy, sui);\n        let receipt_rule = Rule { dummy_field: false };\n        transfer_policy::add_receipt(receipt_rule, request);\n    }\n\n    public fun fee_amount<T: store + key>(\n        policy: &transfer_policy::TransferPolicy<T>,\n        amount: u64\n    ): u64 {\n        let dummy_rule = Rule { dummy_field: false };\n        let rule = transfer_policy::get_rule<T, Rule, Config>(dummy_rule, policy);\n        let fee_bp = (((amount as u128) * (rule.amount_bp as u128) / 10000) as u64);\n        let fee = if (fee_bp < rule.min_amount) {\n            rule.min_amount\n        } else {\n            fee_bp\n        };\n        fee\n    }\n}",
    "witness_rule": "// Decompiled by SuiGPT\nmodule 0x434b5bd8f6a7b05fede0ff46c6e511d71ea326ed38056e3bcd681d2d7c2a7879::witness_rule {\n\n    // ----- Use Statements -----\n\n    use sui::transfer_policy;\n\n    // ----- Structs -----\n\n    struct Rule<phantom T0: drop> has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    public fun add<V: store + key, R: drop>(\n        policy: &mut transfer_policy::TransferPolicy<V>,\n        cap: &transfer_policy::TransferPolicyCap<V>\n    ) {\n        let rule = Rule<R>{ dummy_field: false };\n        transfer_policy::add_rule<V, Rule<R>, bool>(rule, policy, cap, true);\n    }\n\n    public fun prove<V: store + key, R: drop>(\n        dummy: R,\n        policy: &transfer_policy::TransferPolicy<V>,\n        request: &mut transfer_policy::TransferRequest<V>,\n    ) {\n        assert!(transfer_policy::has_rule<V, Rule<R>>(policy), 0);\n        let rule = Rule<R> { dummy_field: false };\n        transfer_policy::add_receipt<V, Rule<R>>(rule, request);\n    }\n}"
}