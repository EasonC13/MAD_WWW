{
    "xfantv": "// Decompiled by MAD\nmodule 0xda12d621169da92ed8af5f6b332b7bec64c840bb49bb3d4206d6739cd76bad14::xfantv {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::coin;\n    use sui::tx_context;\n    use std::option;\n    use sui::url;\n    use sui::token;\n    use sui::transfer;\n    use std::vector;\n    use sui::event;\n\n    // ----- Structs -----\n\n    struct AdminAdded has copy, drop {\n        admin: address,\n    }\n\n    struct AdminCap has key {\n        id: object::UID,\n        admins: vector<address>,\n    }\n\n    struct AdminRemoved has copy, drop {\n        admin: address,\n    }\n\n    struct CoinStore has key {\n        id: object::UID,\n        coin_treasury: coin::TreasuryCap<XFANTV>,\n    }\n\n    struct MaxCredit has store, key {\n        id: object::UID,\n        amount: u64,\n    }\n\n    struct SpendCoin has drop {\n        dummy_field: bool,\n    }\n\n    struct SuperAdminCap has key {\n        id: object::UID,\n    }\n\n    struct TokenCredited has copy, drop {\n        beneficiary: address,\n        amount: u64,\n    }\n\n    struct TokenDebited has copy, drop {\n        spender: address,\n        amount: u64,\n    }\n\n    struct TokenMinted has copy, drop {\n        beneficiary: address,\n        amount: u64,\n    }\n\n    struct Wallet has store, key {\n        id: object::UID,\n        beneficiary: address,\n        amount: u64,\n    }\n\n    struct WalletCap has key {\n        id: object::UID,\n    }\n\n    struct WalletCapGranted has copy, drop {\n        to_address: address,\n    }\n\n    struct XFANTV has drop {\n        dummy_field: bool,\n    }\n\n    // ----- Functions -----\n\n    fun init(xfantv: XFANTV, ctx: &mut tx_context::TxContext) {\n        let (coin_treasury, coin_metadata) = coin::create_currency<XFANTV>(\n            xfantv,\n            9,\n            b\"$FAN\",\n            b\"xFanTV\",\n            b\"xFanTV represents the platform token linked to FanTV, offering ownership in the platform\",\n            option::some(url::new_unsafe_from_bytes(b\"https://assets.artistfirst.in/uploads/1715789262935-FanTV.png\")),\n            ctx\n        );\n        let (policy, policy_cap) = token::new_policy(&coin_treasury, ctx);\n        token::add_rule_for_action<SpendCoin>(\n            &mut policy,\n            &policy_cap,\n            token::spend_action(),\n            ctx\n        );\n        token::share_policy(policy);\n        transfer::public_transfer(policy_cap, tx_context::sender(ctx));\n        transfer::public_transfer(coin_metadata, tx_context::sender(ctx));\n        let super_admin_cap = SuperAdminCap { id: object::new(ctx) };\n        transfer::transfer(super_admin_cap, tx_context::sender(ctx));\n        let wallet_cap = WalletCap { id: object::new(ctx) };\n        transfer::transfer(wallet_cap, tx_context::sender(ctx));\n        let admin_addresses = vector::empty<address>();\n        vector::push_back(&mut admin_addresses, tx_context::sender(ctx));\n        let admin_cap = AdminCap {\n            id: object::new(ctx),\n            admins: admin_addresses,\n        };\n        let max_credit = MaxCredit {\n            id: object::new(ctx),\n            amount: 0,\n        };\n        transfer::share_object(admin_cap);\n        transfer::share_object(max_credit);\n        let coin_store = CoinStore {\n            id: object::new(ctx),\n            coin_treasury: coin_treasury,\n        };\n        transfer::share_object(coin_store);\n    }\n\n    fun is_admin(\n        admin_cap: &AdminCap,\n        addr: address\n    ): bool {\n        let (index, _) = vector::index_of(&admin_cap.admins, &addr);\n        index\n    }\n\n    public fun init_wallet(\n        cap: &WalletCap,\n        beneficiary: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let wallet = Wallet {\n            id: object::new(ctx),\n            beneficiary,\n            amount: 0,\n        };\n        transfer::share_object(wallet);\n    }\n\n    public fun grant_wallet_cap(\n        cap: &SuperAdminCap,\n        to_address: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let wallet_cap = WalletCap { id: object::new(ctx) };\n        transfer::transfer(wallet_cap, to_address);\n        let event = WalletCapGranted { to_address };\n        event::emit<WalletCapGranted>(event);\n    }\n\n    public fun mint_and_transfer(\n        super_admin_cap: &SuperAdminCap,\n        coin_store: &mut CoinStore,\n        amount: u64,\n        beneficiary: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let minted_coin = token::mint<XFANTV>(&mut coin_store.coin_treasury, amount, ctx);\n        let transferred_coin = token::transfer<XFANTV>(minted_coin, beneficiary, ctx);\n        let treasury = &mut coin_store.coin_treasury;\n        token::confirm_with_treasury_cap<XFANTV>(treasury, transferred_coin, ctx);\n\n        let token_minted_event = TokenMinted {\n            beneficiary,\n            amount,\n        };\n        event::emit<TokenMinted>(token_minted_event);\n    }\n\n    public fun ern_xft(\n        admin_cap: &AdminCap,\n        max_credit: &MaxCredit,\n        wallet: &mut Wallet,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(is_admin(admin_cap, tx_context::sender(ctx)), 2);\n        assert!(amount < max_credit.amount, 1);\n        wallet.amount = wallet.amount + amount;\n        let event = TokenCredited {\n            beneficiary: wallet.beneficiary,\n            amount: amount,\n        };\n        event::emit<TokenCredited>(event);\n    }\n\n    public fun spnd_xft(\n        xft: token::Token<XFANTV>,\n        coin_store: &mut CoinStore,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let token_debited = TokenDebited {\n            spender: tx_context::sender(ctx),\n            amount: token::value(&xft),\n        };\n        event::emit<TokenDebited>(token_debited);\n        let spent_token = token::spend(xft, ctx);\n        let spend_coin = SpendCoin { dummy_field: false };\n        token::add_approval<SpendCoin>(spend_coin, &mut spent_token, ctx);\n        let _ = token::confirm_with_treasury_cap(&mut coin_store.coin_treasury, spent_token, ctx);\n    }\n\n    public fun claim_token(\n        wallet: &mut Wallet,\n        coin_store: &mut CoinStore,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(wallet.amount > 0, 0);\n        let token_minted_event = TokenMinted {\n            beneficiary: wallet.beneficiary,\n            amount: wallet.amount,\n        };\n        event::emit<TokenMinted>(token_minted_event);\n        wallet.amount = 0;\n\n        let minted_coin = token::mint<XFANTV>(&mut coin_store.coin_treasury, wallet.amount, ctx);\n        let transferred_coin = token::transfer<XFANTV>(minted_coin, wallet.beneficiary, ctx);\n        let _ = token::confirm_with_treasury_cap<XFANTV>(\n            &mut coin_store.coin_treasury,\n            transferred_coin,\n            ctx\n        );\n    }\n\n    public fun update_max_credit(\n        _cap: &SuperAdminCap,\n        new_amount: u64,\n        max_credit: &mut MaxCredit\n    ) {\n        max_credit.amount = new_amount;\n    }\n\n    public fun add_admin(\n        admin_cap: &mut AdminCap,\n        new_admin: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(is_admin(admin_cap, tx_context::sender(ctx)), 2);\n        vector::push_back(&mut admin_cap.admins, new_admin);\n        let admin_added_event = AdminAdded { admin: new_admin };\n        event::emit(admin_added_event);\n    }\n\n    public fun remove_admin(\n        admin_cap: &mut AdminCap,\n        admin: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(is_admin(admin_cap, tx_context::sender(ctx)), 2);\n        assert!(is_admin(admin_cap, admin), 2);\n        let (_, index) = vector::index_of(&admin_cap.admins, &admin);\n        vector::remove(&mut admin_cap.admins, index);\n        let admin_removed_event = AdminRemoved { admin };\n        event::emit(admin_removed_event);\n    }\n}"
}