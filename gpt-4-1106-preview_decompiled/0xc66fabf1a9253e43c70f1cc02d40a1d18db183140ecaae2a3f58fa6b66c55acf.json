{
    "referral_vault": "// Decompiled by SuiGPT\nmodule 0xc66fabf1a9253e43c70f1cc02d40a1d18db183140ecaae2a3f58fa6b66c55acf::referral_vault {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::table;\n    use sui::bag;\n    use sui::tx_context;\n    use sui::transfer;\n    use std::type_name;\n    use sui::balance;\n    use sui::coin;\n    use std::option;\n\n    // ----- Structs -----\n\n    struct ReferralVault has key {\n        id: object::UID,\n        version: u64,\n        referrer_addresses: table::Table<address, address>,\n        rebates: table::Table<address, bag::Bag>,\n    }\n\n    // ----- Functions -----\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let vault = ReferralVault {\n            id: object::new(ctx),\n            version: 1,\n            referrer_addresses: table::new<address, address>(ctx),\n            rebates: table::new<address, bag::Bag>(ctx),\n        };\n        transfer::share_object(vault);\n    }\n\n    public fun has_referrer(\n        vault: &ReferralVault,\n        account: address\n    ): bool {\n        table::contains(&vault.referrer_addresses, account)\n    }\n\n    public fun referrer_for(\n        vault: &ReferralVault,\n        account: address\n    ): option::Option<address> {\n        if (has_referrer(vault, account)) {\n            option::some(*table::borrow<address, address>(&vault.referrer_addresses, account))\n        } else {\n            option::none<address>()\n        }\n    }\n\n    public fun referrer_has_rebate(\n        vault: &ReferralVault,\n        referrer: address\n    ): bool {\n        table::contains(&vault.rebates, referrer)\n    }\n\n    public fun referrer_has_rebate_with_type<T>(\n        vault: &ReferralVault,\n        referrer: address\n    ): bool {\n        referrer_has_rebate(vault, referrer) && \n        bag::contains<type_name::TypeName>(\n            table::borrow<address, bag::Bag>(&vault.rebates, referrer),\n            type_name::get<T>()\n        )\n    }\n\n    public fun balance_of<T>(\n        vault: &ReferralVault,\n        account: address\n    ): u64 {\n        let type_name = type_name::get<T>();\n        if (!referrer_has_rebate(vault, account)) {\n            return 0;\n        };\n        let rebates_bag = table::borrow<address, bag::Bag>(&vault.rebates, account);\n        if (!bag::contains<type_name::TypeName>(rebates_bag, type_name)) {\n            return 0;\n        };\n        balance::value<T>(bag::borrow<type_name::TypeName, balance::Balance<T>>(rebates_bag, type_name))\n    }\n\n    public fun update_referrer_address(\n        vault: &mut ReferralVault,\n        new_referrer: address,\n        ctx: &tx_context::TxContext\n    ) {\n        assert_version(vault);\n        let sender = tx_context::sender(ctx);\n        assert!(sender != new_referrer, 2);\n        if (!has_referrer(vault, sender)) {\n            table::add(&mut vault.referrer_addresses, sender, new_referrer);\n        } else {\n            let current_referrer = table::borrow(&vault.referrer_addresses, sender);\n            if (*current_referrer != new_referrer) {\n                let current_referrer_mut = table::borrow_mut(&mut vault.referrer_addresses, sender);\n                *current_referrer_mut = new_referrer;\n            };\n        };\n    }\n\n    public fun deposit_rebate<T>(\n        vault: &mut ReferralVault,\n        coin: coin::Coin<T>,\n        referrer: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert_version(vault);\n        let type_name = type_name::get<T>();\n        if (!referrer_has_rebate(vault, referrer)) {\n            table::add(&mut vault.rebates, referrer, bag::new(ctx));\n        };\n        let rebate_bag = table::borrow_mut(&mut vault.rebates, referrer);\n        if (!bag::contains(rebate_bag, type_name)) {\n            bag::add(rebate_bag, type_name, coin::into_balance(coin));\n        } else {\n            let balance = bag::borrow_mut(rebate_bag, type_name);\n            balance::join(balance, coin::into_balance(coin));\n        };\n    }\n\n    public fun withdraw_rebate<T>(\n        vault: &mut ReferralVault,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        assert_version(vault);\n        let sender = tx_context::sender(ctx);\n        assert!(referrer_has_rebate_with_type<T>(vault, sender), 1);\n        let rebate_balance = bag::remove<type_name::TypeName, balance::Balance<T>>(\n            table::borrow_mut(&mut vault.rebates, sender),\n            type_name::get<T>()\n        );\n        coin::from_balance(rebate_balance, ctx)\n    }\n\n    public fun withdraw_and_transfer<T>(\n        vault: &mut ReferralVault,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let rebate = withdraw_rebate<T>(vault, ctx);\n        transfer::public_transfer(rebate, tx_context::sender(ctx));\n    }\n\n    public fun assert_version(vault: &ReferralVault) {\n        assert!(vault.version == 1, 0);\n    }\n}"
}