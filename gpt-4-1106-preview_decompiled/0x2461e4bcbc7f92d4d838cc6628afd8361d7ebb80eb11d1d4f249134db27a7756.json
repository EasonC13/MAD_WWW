{
    "account_graph": "// Decompiled by MAD\nmodule 0x2461e4bcbc7f92d4d838cc6628afd8361d7ebb80eb11d1d4f249134db27a7756::account_graph {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use std::string;\n    use std::option;\n    use sui::table;\n    use sui::vec_set;\n    use sui::tx_context;\n    use sui::event;\n    use sui::vec_map;\n    use std::vector;\n    use sui::transfer;\n\n    // ----- Structs -----\n\n    struct AccountGraph<phantom T0: copy + drop + store, phantom T1: copy + drop + store> has store, key {\n        id: object::UID,\n        description: string::String,\n        max_out_degree: option::Option<u32>,\n        relationships: table::Table<address, vec_set::VecSet<address>>,\n        account_props: table::Table<address, T0>,\n        relationship_props: table::Table<RelationshipKey, T1>,\n    }\n\n    struct AccountPropsSet<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        node: address,\n        props: T0,\n    }\n\n    struct AccountPropsUnset<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        node: address,\n        props: T0,\n    }\n\n    struct EmptyProp has copy, drop, store {\n        dummy_field: bool,\n    }\n\n    struct GraphCreated has copy, drop {\n        graph_id: object::ID,\n    }\n\n    struct RelationshipAdded has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n    }\n\n    struct RelationshipKey has copy, drop, store {\n        source: address,\n        target: address,\n    }\n\n    struct RelationshipPropsSet<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n        props: T0,\n    }\n\n    struct RelationshipPropsUnset<T0: copy> has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n        props: T0,\n    }\n\n    struct RelationshipRemoved has copy, drop {\n        graph_id: object::ID,\n        source: address,\n        target: address,\n    }\n\n    // ----- Functions -----\n\n    fun new<T0: copy + drop + store, T1: copy + drop + store>(\n        description: string::String,\n        max_out_degree: option::Option<u32>,\n        ctx: &mut tx_context::TxContext\n    ): AccountGraph<T0, T1> {\n        let is_valid_max_degree = if (option::is_none(&max_out_degree)) {\n            true\n        } else {\n            let zero = 0u32;\n            !option::contains(&max_out_degree, &zero)\n        };\n        assert!(is_valid_max_degree, 1);\n        AccountGraph<T0, T1> {\n            id: object::new(ctx),\n            description,\n            max_out_degree,\n            relationships: table::new<address, vec_set::VecSet<address>>(ctx),\n            account_props: table::new<address, T0>(ctx),\n            relationship_props: table::new<RelationshipKey, T1>(ctx),\n        }\n    }\n\n    fun relationship_exists<T0: copy + drop + store, T1: copy + drop + store>(\n        account_graph: &AccountGraph<T0, T1>,\n        account1: address,\n        account2: address\n    ): bool {\n        table::contains(&account_graph.relationships, account1) &&\n        vec_set::contains(\n            table::borrow(&account_graph.relationships, account1),\n            &account2\n        )\n    }\n\n    public fun create<T: copy + drop + store, U: copy + drop + store>(\n        name: string::String,\n        max_depth: option::Option<u32>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let graph = new<T, U>(name, max_depth, ctx);\n        transfer::share_object<AccountGraph<T, U>>(graph);\n        let graph_id = object::id(&graph);\n        event::emit<GraphCreated>(GraphCreated { graph_id });\n    }\n\n    public fun add_relationship<T, U: copy + drop + store>(\n        account_graph: &mut AccountGraph<T, U>,\n        target: address,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let relationships = &mut account_graph.relationships;\n        if (table::contains(relationships, sender)) {\n            let sender_relationships = table::borrow_mut(relationships, sender);\n            assert!(\n                option::is_none(&account_graph.max_out_degree) || \n                vec_set::size(sender_relationships) < (*option::borrow(&account_graph.max_out_degree) as u64),\n                0\n            );\n            vec_set::insert(sender_relationships, target);\n        } else {\n            table::add(relationships, sender, vec_set::singleton(target));\n        };\n        let event = RelationshipAdded {\n            graph_id: object::id(account_graph),\n            source: sender,\n            target,\n        };\n        event::emit(event);\n    }\n\n    public fun remove_relationship<T, U: copy + drop + store>(\n        graph: &mut AccountGraph<T, U>,\n        target: address,\n        ctx: &mut tx_context::TxContext\n    ): (address, option::Option<U>) {\n        let sender = tx_context::sender(ctx);\n        let sender_relationships = table::borrow_mut(&mut graph.relationships, sender);\n        vec_set::remove(sender_relationships, &target);\n        if (vec_set::size(sender_relationships) == 0) {\n            table::remove(&mut graph.relationships, sender);\n        };\n        let removal_event = RelationshipRemoved {\n            graph_id: object::id(graph),\n            source: sender,\n            target,\n        };\n        event::emit(removal_event);\n        (target, unset_relationship_props<T, U>(graph, target, ctx))\n    }\n\n    public fun clear_relationships<T0: copy + drop + store, T1: copy + drop + store>(\n        graph: &mut AccountGraph<T0, T1>,\n        ctx: &mut tx_context::TxContext\n    ): vec_map::VecMap<address, option::Option<T1>> {\n        let sender = tx_context::sender(ctx);\n        let relationships = &mut graph.relationships;\n        let cleared_relationships = vec_map::empty<address, option::Option<T1>>();\n        \n        if (!table::contains(relationships, sender)) {\n            return cleared_relationships;\n        };\n        \n        let related_addresses = table::remove(relationships, sender);\n        let keys = vec_set::keys(&related_addresses);\n        let i = 0;\n        \n        while (i < vector::length(keys)) {\n            let target = *vector::borrow(keys, i);\n            let unset_rel = unset_relationship_props<T0, T1>(graph, target, ctx);\n            vec_map::insert(&mut cleared_relationships, target, unset_rel);\n            \n            let event = RelationshipRemoved {\n                graph_id: object::id(graph),\n                source: sender,\n                target: target,\n            };\n            event::emit(event);\n            \n            i = i + 1;\n        };\n        \n        cleared_relationships\n    }\n\n    public fun set_account_props<T: copy + drop + store, U: copy + drop + store>(\n        graph: &mut AccountGraph<T, U>,\n        props: T,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T> {\n        let sender = tx_context::sender(ctx);\n        let account_props = &mut graph.account_props;\n        let result = if (table::contains<address, T>(account_props, sender)) {\n            let current_props = table::borrow_mut<address, T>(account_props, sender);\n            *current_props = props;\n            option::some(*current_props)\n        } else {\n            table::add<address, T>(account_props, sender, props);\n            option::none<T>()\n        };\n        let event = AccountPropsSet<T>{\n            graph_id: object::id<AccountGraph<T, U>>(graph),\n            node: sender,\n            props,\n        };\n        event::emit<AccountPropsSet<T>>(event);\n        result\n    }\n\n    public fun unset_account_props<T: copy + drop + store, U: copy + drop + store>(\n        graph: &mut AccountGraph<T, U>,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<T> {\n        let sender = tx_context::sender(ctx);\n        let account_props = &mut graph.account_props;\n        if (table::contains<address, T>(account_props, sender)) {\n            let props = table::remove<address, T>(account_props, sender);\n            let unset_event = AccountPropsUnset<T>{\n                graph_id: object::id<AccountGraph<T, U>>(graph),\n                node: sender,\n                props: props,\n            };\n            event::emit<AccountPropsUnset<T>>(unset_event);\n            option::some(props)\n        } else {\n            option::none<T>()\n        }\n    }\n\n    public fun set_relationship_props<A: copy + drop + store, P: copy + drop + store>(\n        graph: &mut AccountGraph<A, P>,\n        target: address,\n        props: P,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<P> {\n        let source = tx_context::sender(ctx);\n        assert!(relationship_exists<A, P>(graph, source, target), 2);\n        let relationship_props = &mut graph.relationship_props;\n        let key = RelationshipKey {\n            source,\n            target,\n        };\n        let previous_props = if (table::contains<RelationshipKey, P>(relationship_props, key)) {\n            let current_props = table::borrow_mut<RelationshipKey, P>(relationship_props, key);\n            *current_props = props;\n            option::some(*current_props)\n        } else {\n            table::add<RelationshipKey, P>(relationship_props, key, props);\n            option::none<P>()\n        };\n        let event = RelationshipPropsSet<P> {\n            graph_id: object::id<AccountGraph<A, P>>(graph),\n            source,\n            target,\n            props,\n        };\n        event::emit<RelationshipPropsSet<P>>(event);\n        previous_props\n    }\n\n    public fun unset_relationship_props<V: copy + drop + store, W: copy + drop + store>(\n        graph: &mut AccountGraph<V, W>,\n        target: address,\n        ctx: &mut tx_context::TxContext\n    ): option::Option<W> {\n        let sender = tx_context::sender(ctx);\n        let relationship_props = &mut graph.relationship_props;\n        let key = RelationshipKey {\n            source: sender,\n            target,\n        };\n        if (table::contains<RelationshipKey, W>(relationship_props, key)) {\n            let props = table::remove<RelationshipKey, W>(relationship_props, key);\n            let unset_event = RelationshipPropsUnset<W> {\n                graph_id: object::id(graph),\n                source: sender,\n                target,\n                props,\n            };\n            event::emit<RelationshipPropsUnset<W>>(unset_event);\n            option::some(props)\n        } else {\n            option::none<W>()\n        }\n    }\n}"
}