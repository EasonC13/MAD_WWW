{
    "vault": "// Decompiled by MAD\nmodule 0x62285e6bf9ce841f9bf98b7e3a8e4478e02219135cf2bc1ccaf409ec5883f7b6::vault {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::coin;\n    use sui::tx_context;\n    use sui::transfer;\n    use std::vector;\n    use sui::event;\n\n    // ----- Structs -----\n\n    struct AdminCap has store, key {\n        id: object::UID,\n        vault_id: object::ID,\n    }\n\n    struct FlashLoanEvent<phantom T0> has copy, drop {\n        loan_amount: u64,\n        repay_amount: u64,\n        repay_actual: u64,\n    }\n\n    struct Receipt<phantom T0> {\n        vault_id: object::ID,\n        loan_amount: u64,\n        repay_amount: u64,\n    }\n\n    struct Vault<phantom T0> has key {\n        id: object::UID,\n        to_lend: balance::Balance<T0>,\n        fee_fix: u64,\n        fee_bps: u64,\n    }\n\n    // ----- Functions -----\n\n    fun check_admin<T>(\n        vault: &Vault<T>,\n        admin_cap: &AdminCap\n    ) {\n        assert!(\n            object::borrow_id(vault) == &admin_cap.vault_id,\n            3\n        );\n    }\n\n    public entry fun create<T>(\n        coin: coin::Coin<T>,\n        arg1: u64,\n        arg2: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let balance = coin::into_balance(coin);\n        let admin_cap = new<T>(balance, arg1, arg2, ctx);\n        transfer::public_transfer(admin_cap, tx_context::sender(ctx));\n    }\n\n    public entry fun create_<T>(\n        cap: u64,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        transfer::public_transfer(\n            new(cap, amount, ctx),\n            tx_context::sender(ctx)\n        );\n    }\n\n    public entry fun deposit<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        coin: coin::Coin<T>\n    ) {\n        check_admin(vault, admin_cap);\n        coin::put(&mut vault.to_lend, coin);\n    }\n\n    public entry fun deposit_<T>(\n        vault: &mut Vault<T>,\n        coin: coin::Coin<T>\n    ) {\n        coin::put(&mut vault.to_lend, coin);\n    }\n\n    public entry fun sends<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        recipients: vector<address>,\n        amounts: vector<u64>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        check_admin(vault, admin_cap);\n        let num_recipients = vector::length(&recipients);\n        let i = 0;\n        assert!(vector::length(&amounts) == num_recipients, 9);\n        let to_lend = &mut vault.to_lend;\n        while (i < num_recipients) {\n            let amount = vector::pop_back(&mut amounts);\n            assert!(balance::value(to_lend) >= amount, 4);\n            let recipient = vector::pop_back(&mut recipients);\n            transfer::public_transfer(\n                coin::take(to_lend, amount, ctx),\n                recipient\n            );\n            i = i + 1;\n        };\n    }\n\n    public entry fun update_fee<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        fee_fix: u64,\n        fee_bps: u64\n    ) {\n        check_admin(vault, admin_cap);\n        vault.fee_fix = fee_fix;\n        vault.fee_bps = fee_bps;\n    }\n\n    public entry fun ww<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let coin = withdraw(vault, admin_cap, amount, ctx);\n        transfer::public_transfer(coin, tx_context::sender(ctx));\n    }\n\n    public fun new<T>(\n        to_lend: balance::Balance<T>,\n        fee_fix: u64,\n        fee_bps: u64,\n        ctx: &mut tx_context::TxContext\n    ): AdminCap {\n        assert!(fee_bps >= 0 && fee_bps < 10000, 5);\n        let vault_id = object::new(ctx);\n        let vault = Vault<T> {\n            id: vault_id,\n            to_lend,\n            fee_fix,\n            fee_bps,\n        };\n        transfer::share_object(vault);\n        AdminCap {\n            id: object::new(ctx),\n            vault_id: object::uid_to_inner(&vault_id),\n        }\n    }\n\n    public fun loan<T>(\n        vault: &mut Vault<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): (coin::Coin<T>, Receipt<T>) {\n        let to_lend = &mut vault.to_lend;\n        assert!(balance::value<T>(to_lend) >= amount, 0);\n        let fee = amount / 10000 * vault.fee_bps + vault.fee_fix;\n        let receipt = Receipt<T> {\n            vault_id: object::id(vault),\n            loan_amount: amount,\n            repay_amount: amount + fee,\n        };\n        (coin::take<T>(to_lend, amount, ctx), receipt)\n    }\n\n    public fun loan_<T>(\n        vault: &mut Vault<T>,\n        amount: u64\n    ): (balance::Balance<T>, Receipt<T>) {\n        let to_lend = &mut vault.to_lend;\n        assert!(balance::value<T>(to_lend) >= amount, 0);\n        let fee = amount / 10000 * vault.fee_bps + vault.fee_fix;\n        let receipt = Receipt<T> {\n            vault_id: object::id(vault),\n            loan_amount: amount,\n            repay_amount: amount + fee,\n        };\n        (balance::split<T>(to_lend, amount), receipt)\n    }\n\n    public fun repay<T>(\n        vault: &mut Vault<T>,\n        coin: coin::Coin<T>,\n        receipt: Receipt<T>\n    ) {\n        let Receipt {\n            vault_id,\n            loan_amount,\n            repay_amount,\n        } = receipt;\n\n        assert!(object::id(vault) == vault_id, 2);\n        let repay_value = coin::value(&coin);\n        assert!(repay_value >= repay_amount, 1);\n        coin::put(&mut vault.to_lend, coin);\n\n        let event = FlashLoanEvent<T> {\n            loan_amount,\n            repay_amount,\n            repay_actual: repay_value,\n        };\n        event::emit(event);\n    }\n\n    public fun repay_<T>(\n        vault: &mut Vault<T>,\n        balance: balance::Balance<T>,\n        receipt: Receipt<T>\n    ) {\n        let Receipt {\n            vault_id,\n            loan_amount,\n            repay_amount,\n        } = receipt;\n\n        assert!(object::id<Vault<T>>(vault) == vault_id, 2);\n\n        let repay_value = balance::value(&balance);\n        assert!(repay_value >= repay_amount, 1);\n\n        balance::join(&mut vault.to_lend, balance);\n\n        let flash_loan_event = FlashLoanEvent<T> {\n            loan_amount,\n            repay_amount,\n            repay_actual: repay_value,\n        };\n\n        event::emit<FlashLoanEvent<T>>(flash_loan_event);\n    }\n\n    public fun withdraw<T>(\n        vault: &mut Vault<T>,\n        admin_cap: &AdminCap,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        check_admin(vault, admin_cap);\n        let to_lend = &mut vault.to_lend;\n        assert!(balance::value(to_lend) >= amount, 4);\n        coin::take(to_lend, amount, ctx)\n    }\n\n    public fun fee<T>(vault: &Vault<T>): (u64, u64) {\n        (vault.fee_fix, vault.fee_bps)\n    }\n\n    public fun max_loan<T>(vault: &Vault<T>): u64 {\n        balance::value(&vault.to_lend)\n    }\n\n    public fun repay_amount<T>(receipt: &Receipt<T>): u64 {\n        receipt.repay_amount\n    }\n\n    public fun loan_amount<T>(receipt: &Receipt<T>): u64 {\n        receipt.loan_amount\n    }\n\n    public fun vault_id<T>(receipt: &Receipt<T>): object::ID {\n        receipt.vault_id\n    }\n\n    public fun limit_transfer_coin<T>(\n        coin: coin::Coin<T>,\n        min_value: u64,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(coin::value(&coin) >= min_value, 10);\n        transfer::public_transfer(coin, tx_context::sender(ctx));\n    }\n}"
}