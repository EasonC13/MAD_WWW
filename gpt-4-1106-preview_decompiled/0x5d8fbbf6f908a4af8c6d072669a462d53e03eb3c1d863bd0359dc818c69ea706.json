{
    "SupraSValueFeed": "// Decompiled by SuiGPT\nmodule 0x5d8fbbf6f908a4af8c6d072669a462d53e03eb3c1d863bd0359dc818c69ea706::SupraSValueFeed {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::table;\n    use std::vector;\n    use sui::tx_context;\n    use sui::transfer;\n    use sui::hash;\n    use sui::bcs;\n    use sui::bls12381;\n\n    // ----- Structs -----\n\n    struct CoherentCluster has copy, drop {\n        data_hash: vector<u8>,\n        pair: vector<u32>,\n        prices: vector<u128>,\n        timestamp: vector<u128>,\n        decimals: vector<u16>,\n    }\n\n    struct DkgState has store, key {\n        id: object::UID,\n        public_key: vector<u8>,\n    }\n\n    struct Entry has copy, drop, store {\n        value: u128,\n        decimal: u16,\n        timestamp: u128,\n        round: u64,\n    }\n\n    struct MinBatch has drop {\n        protocol: vector<u8>,\n        txn_hashes: vector<vector<u8>>,\n    }\n\n    struct MinBlock has drop {\n        round: vector<u8>,\n        timestamp: vector<u8>,\n        author: vector<u8>,\n        qc_hash: vector<u8>,\n        batch_hashes: vector<vector<u8>>,\n    }\n\n    struct MinTxn has drop {\n        cluster_hashes: vector<vector<u8>>,\n        sender: vector<u8>,\n        protocol: vector<u8>,\n        tx_sub_type: u8,\n    }\n\n    struct OracleHolder has store, key {\n        id: object::UID,\n        version: u64,\n        owner: object::ID,\n        feeds: table::Table<u32, Entry>,\n    }\n\n    struct Origin has drop {\n        id: vector<u8>,\n        member_index: u64,\n        committee_index: u64,\n    }\n\n    struct OwnerCap has key {\n        id: object::UID,\n    }\n\n    struct Price has drop {\n        pair: u32,\n        value: u128,\n        decimal: u16,\n        timestamp: u128,\n        round: u64,\n    }\n\n    struct SCCProcessedEvent has copy, drop {\n        hash: vector<u8>,\n    }\n\n    struct SignedCoherentCluster has drop {\n        cc: CoherentCluster,\n        qc: vector<u8>,\n        round: u64,\n        origin: Origin,\n    }\n\n    struct Vote has drop {\n        smr_block: MinBlock,\n        round: u64,\n    }\n\n    // ----- Functions -----\n\n    fun batch_verification(\n        min_batch: &MinBatch,\n        signatures: &vector<vector<u8>>,\n        index: u64\n    ): bool {\n        let batch_hash = hash_min_batch(min_batch);\n        vector::borrow(signatures, index) == &batch_hash\n    }\n\n    fun create_dkg_state(\n        public_key: vector<u8>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let dkg_state = DkgState {\n            id: object::new(ctx),\n            public_key\n        };\n        transfer::freeze_object(dkg_state);\n    }\n\n    fun create_oracle_holder(ctx: &mut tx_context::TxContext, owner_cap: &OwnerCap) {\n        let oracle_holder = OracleHolder {\n            id: object::new(ctx),\n            version: 1,\n            owner: object::id(owner_cap),\n            feeds: table::new<u32, Entry>(ctx),\n        };\n        transfer::share_object(oracle_holder);\n    }\n\n    fun create_owner(owner_cap: OwnerCap, ctx: &mut tx_context::TxContext) {\n        transfer::transfer(owner_cap, tx_context::sender(ctx));\n    }\n\n    fun hash_min_batch(batch: &MinBatch): vector<u8> {\n        let data_prefix = b\"\";\n        let data = vector_flatten_concate(data_prefix, &batch.txn_hashes);\n        let protocol_data = batch.protocol;\n        let data_hash = hash::keccak256(&data);\n        vector::append(&mut protocol_data, &data_hash);\n        hash::keccak256(&protocol_data)\n    }\n\n    fun hash_min_txn(min_txn: &MinTxn): vector<u8> {\n        let data_prefix = b\"\".to_vec();\n        let cluster_hashes = min_txn.cluster_hashes.clone();\n        vector_flatten_concate(&mut data_prefix, &mut cluster_hashes);\n        vector::append(&mut data_prefix, min_txn.sender);\n        vector::append(&mut data_prefix, min_txn.protocol);\n        let tx_sub_type_vec = vector::empty<u8>();\n        vector::push_back(&mut tx_sub_type_vec, min_txn.tx_sub_type);\n        vector::append(&mut data_prefix, tx_sub_type_vec);\n        hash::keccak256(&data_prefix)\n    }\n\n    fun hash_scc(scc: &SignedCoherentCluster): vector<u8> {\n        let scc_bytes = bcs::to_bytes(scc);\n        hash::keccak256(&scc_bytes)\n    }\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let owner_cap = OwnerCap { id: object::new(ctx) };\n        create_oracle_holder(ctx, &owner_cap);\n        create_owner(owner_cap, ctx);\n    }\n\n    fun new_min_batch(\n        protocol: vector<u8>,\n        txn_hashes: vector<vector<u8>>\n    ): MinBatch {\n        MinBatch {\n            protocol,\n            txn_hashes\n        }\n    }\n\n    fun new_min_txn(\n        cluster_hashes: vector<vector<u8>>,\n        sender: vector<u8>,\n        protocol: vector<u8>,\n        tx_sub_type: u8\n    ): MinTxn {\n        MinTxn {\n            cluster_hashes,\n            sender,\n            protocol,\n            tx_sub_type\n        }\n    }\n\n    fun new_scc(\n        data_hash: vector<u8>,\n        pair: vector<u32>,\n        prices: vector<u128>,\n        timestamp: vector<u128>,\n        decimals: vector<u16>,\n        qc: vector<u8>,\n        round: u64,\n        id: vector<u8>,\n        member_index: u64,\n        committee_index: u64\n    ): SignedCoherentCluster {\n        let cc = CoherentCluster {\n            data_hash,\n            pair,\n            prices,\n            timestamp,\n            decimals,\n        };\n        let origin = Origin {\n            id,\n            member_index,\n            committee_index,\n        };\n        SignedCoherentCluster {\n            cc,\n            qc,\n            round,\n            origin,\n        }\n    }\n\n    fun new_vote(\n        round: vector<u8>,\n        timestamp: vector<u8>,\n        author: vector<u8>,\n        qc_hash: vector<u8>,\n        batch_hashes: vector<vector<u8>>,\n        round_number: u64\n    ): Vote {\n        let min_block = MinBlock {\n            round,\n            timestamp,\n            author,\n            qc_hash,\n            batch_hashes,\n        };\n        Vote {\n            smr_block: min_block,\n            round: round_number,\n        }\n    }\n\n    fun scc_verification(\n        scc: &SignedCoherentCluster,\n        signatures: &vector<vector<u8>>,\n        index: u64\n    ): bool {\n        let scc_hash = hash_scc(scc);\n        vector::borrow(signatures, index) == &scc_hash\n    }\n\n    fun smr_hash_vote(vote: &Vote): vector<u8> {\n        let data_prefix = b\"\";\n        let data = vector_flatten_concate(data_prefix, &vote.smr_block.batch_hashes);\n        let round_data = vote.smr_block.round;\n        vector::append(&mut round_data, &vote.smr_block.timestamp);\n        vector::append(&mut round_data, &vote.smr_block.author);\n        vector::append(&mut round_data, &vote.smr_block.qc_hash);\n        vector::append(&mut round_data, &hash::keccak256(&data));\n        let hash_data = hash::keccak256(&round_data);\n        vector::append(&mut hash_data, &bcs::to_bytes(&vote.round));\n        hash::keccak256(&hash_data)\n    }\n\n    fun transaction_verification(\n        min_txn: &MinTxn,\n        signatures: &vector<vector<u8>>,\n        index: u64\n    ): bool {\n        let txn_hash = hash_min_txn(min_txn);\n        vector::borrow(signatures, index) == &txn_hash\n    }\n\n    fun update_price(\n        oracleHolder: &mut OracleHolder,\n        signedCluster: SignedCoherentCluster\n    ) {\n        let cluster = signedCluster.cc;\n        let index = 0;\n        while (index < vector::length(&cluster.pair)) {\n            let pair_id = *vector::borrow(&cluster.pair, index);\n            let timestamp = *vector::borrow(&cluster.timestamp, index);\n            let entry = Entry {\n                value: *vector::borrow(&cluster.prices, index),\n                decimal: *vector::borrow(&cluster.decimals, index),\n                timestamp,\n                round: signedCluster.round,\n            };\n            if (table::contains(&oracleHolder.feeds, pair_id)) {\n                let current_entry = table::borrow_mut(&mut oracleHolder.feeds, pair_id);\n                if (current_entry.timestamp < timestamp) {\n                    *current_entry = entry;\n                };\n            } else {\n                table::add(&mut oracleHolder.feeds, pair_id, entry);\n            };\n            index = index + 1;\n        };\n    }\n\n    fun vector_flatten_concate<T: copy + drop>(\n        flat_vector: &mut vector<T>,\n        nested_vectors: vector<vector<T>>\n    ) {\n        let i = 0;\n        while (i < vector::length(&nested_vectors)) {\n            let nested_vector = vector::borrow(&nested_vectors, i);\n            vector::append(flat_vector, *nested_vector);\n            i = i + 1;\n        };\n    }\n\n    fun verify_signature(\n        public_key: vector<u8>,\n        message: vector<u8>,\n        signature: vector<u8>\n    ): bool {\n        bls12381::bls12381_min_sig_verify(&signature, &public_key, &message)\n    }\n\n    fun vote_verification(\n        public_key: vector<u8>,\n        vote: &Vote,\n        signature: vector<u8>\n    ): bool {\n        verify_signature(public_key, smr_hash_vote(vote), signature)\n    }\n\n    public fun get_price(\n        oracleHolder: &OracleHolder,\n        feed_id: u32\n    ): (u128, u16, u128, u64) {\n        assert!(oracleHolder.version == 1, 21);\n        if (!table::contains(&oracleHolder.feeds, feed_id)) {\n            abort 11\n        };\n        let entry = table::borrow(&oracleHolder.feeds, feed_id);\n        (entry.value, entry.decimal, entry.timestamp, entry.round)\n    }\n\n    public fun get_prices(\n        oracle_holder: &OracleHolder,\n        pairs: vector<u32>\n    ): vector<Price> {\n        assert!(oracle_holder.version == 1, 21);\n        let i = 0;\n        let prices = vector::empty<Price>();\n        while (i < vector::length(&pairs)) {\n            let pair_id = *vector::borrow(&pairs, i);\n            i = i + 1;\n            if (!table::contains(&oracle_holder.feeds, pair_id)) {\n                continue;\n            };\n            let entry = table::borrow(&oracle_holder.feeds, pair_id);\n            let price = Price {\n                pair: pair_id,\n                value: entry.value,\n                decimal: entry.decimal,\n                timestamp: entry.timestamp,\n                round: entry.round,\n            };\n            vector::push_back(&mut prices, price);\n        };\n        prices\n    }\n\n    public fun extract_price(price: &Price): (u32, u128, u16, u128, u64) {\n        (price.pair, price.value, price.decimal, price.timestamp, price.round)\n    }\n}"
}