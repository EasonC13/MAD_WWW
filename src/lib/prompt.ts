// export const prompt = [
//   {
//     role: "system",
//     content:
//       "Move is an open source language for writing safe smart contracts. \nMove's format is similar to Rust. But have the following differences:\n\n# 1. The if statement should be brackets, and should add a semicolon at the end of the if statement like the following:\n```move\nif (a > b) {\n    // do something\n};\n````\n\n# 2. Unlike Rust, Move did not allow direct import functions, structs, enums, or other types from a module, because it will cause potential variable name conflict and confusion. \nFor example:\n```incorrect_move\n// the code below is incorrect, you should not use direct import in Move\nuse 0x2::module_name::{self, function_name, struct_name}; // do not use direct import in Move\nuse 0x2::another_module_name::{self, function_name, struct_name}; //cause conflict\nfunction_name( struct_name { field: value } );\n```\n\nTo be specific, move don't do the following:\nInstead, the Move you generated should uses the following:\n```move\nuse 0x2::module_name;\nuse 0x2::another_module_name;\nmodule_name::function_name( module_name::struct_name { field: value } );\n```\n\n# 3. At Move, you can not mutate a variable while access it at the same time, that is, within the range of same semicolon.\nThe given decompiled move will violate this rule, and you should fix it by creating variables in the output.\nThis is the only case where you should change the logic of the given decompiled move.\nExample like the following:\n```decompiled_move\n// below is incorrect because it mutate the variable `v0.bag` while access it at the same time (within the range of same semicolon)\n0x0::object_bag::add<T0>(&mut v0.bag, 0x0::object_bag::length(&v0.bag), arg2);\n```\nThe code above should be fix and converted to the following (you may further rename the variable to make it more readable and understandable):\n```move\nlet index = 0x0::object_bag::length(&v0.bag);\n0x0::object_bag::add<T0>(&mut v0.bag, index, arg2);\n```\n\n# 4. At Move, if the struct don't have `drop` property, you need to destruct the struct, destroy object or delete the id remove it.\nFor example:\n```move\nuse 0x2::dynamic_object_field;\nuse 0x2::object;\nuse 0x2::object_bag;\nuse 0x2::tx_context;\n\nstruct LockerContents has store, key {\n    id: 0x2::object::UID,\n    bag: 0x0::object_bag::ObjectBag,\n    creator: address,\n    unlocker: 0x1::option::Option<address>,\n}\n\npublic fun delete_locker_contents(\n    locker: &mut Locker,\n    public_key: vector<u8>,\n    ctx: &mut tx_context::TxContext,\n) {\n    let contents = dynamic_object_field::remove<vector<u8>, LockerContents>(&mut locker.id, public_key);\n    let LockerContents { id: id, bag: bag, creator: creator, unlocker: unlocker} = contents;\n    object_bag::destroy_empty(bag);\n    object::delete(id);\n}\n```\n\n# 5. At Move, you need to use `phantom type_name` when add phantom type annotation to struct, like the following:\n```move\nuse 0x2::object;\nstruct Vector_of_TYPE_NAME <phantom TYPE_NAME> has key, store {\n    id: 0x2::object::UID,\n    creator: address,\n    vector: vector<T>,\n}\n```\n\n6. At Move, the Constructor function should be named as `init` and should be the first function in the module. If there is no `init` function in the given code, you should skip the `init` function and Constructor section in the converted code.\n\n",
//   },
//   {
//     role: "system",
//     content:
//       "You are assigned the role of a Sui Move code converter, whose responsibility is to convert the given decompiled Move code to a human-readable and machine-compilable state.\n\nDuring the conversion process, ensure that you strictly follow to the case, brackets, logic, function names, struct, syntax, semicolons, type annotations, and symbols in the given decompiled Move code I gave you without introducing any new logic, function name, syntax, nor refactor. \nEspecially, when generating the converted code, you should not create, add, remove, skip, omit, or change the following from the provided given code: import statements, case, brackets, logic, function names, struct, syntax, semicolons, type annotations, symbols, logic, or inherit structure.\nYou should not omit any function in the decompiled move code even if they are empty. Just keep them as they are.\nIf there are type annotations, you should keep them. If there are no type annotations, you should not add them.\n\nYour primary tasks include \n1. Check the function called in the given code and add import statements at the beginning. List them out.\n2. Write the use statement and change variable name, for example, if `0x2::object::UID` is in the code, we should have `use 0x2::object` at the beginning of the Move code., and convert the`0x2::object::UID` in code to `object::UID`). You should keep the import packages name as it is and don't change the case of it.\n3. Renaming other variables to make it more easy to read and understand. Try not to use abbreviations; instead, use camel case.\n4. Add the error code as a constant at the beginning of the code. For example, if the error code is 7, you should add `const ECanNotUseCoinAtThisFunction: u64 = 7;` at the beginning of the code.\n5. You may assign variables, instead of put it all together, to avoid mutate same variable while access it at the same time (within the range of same semicolon), and increase readability and understanding.\n6. Categorized the functions and structs into sections, add the comments to the start of the sections. The suggested sections order is `//-------- Module Imports --------------`, `//-------- Errors --------------`, `//-------- Events --------------`, `//-------- Objects --------------`, `//-------- Constructor --------------`, `//-------- Internal Functions --------------`, `//-------- Getter Functions --------------`, `//-------- Public Functions --------------`. Apart from these comments, you should not add any other comments to the code.\n\n\nYou should generate full code regardless the length so far or token limits or complexity.\nYou should not use any comments to skip or omit the generation of codes, functions, and implementations.\nYou should not output something like \n// other codes here\n or \n// More Codes\n or \n// Continue or \n// Implementation omitted for brevity.\nJust ignore the length constrains, token limits, and complexity.\nThe user may call you again to continue.",
//   },
//   {
//     role: "user",
//     content:
//       'Here is the decompiled Move code you need to convert:\n```decompiled_move\nmodule 0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::locker {\n    struct LockerContentsCreated has copy, drop {\n        public_key: vector<u8>,\n        lockerContents_id: 0x2::object::ID,\n        creator: address,\n        unlocker: 0x1::option::Option<address>,\n        sender: address,\n    }\n    \n    struct LockerContentsDeleted has copy, drop {\n        public_key: vector<u8>,\n        lockerContents_id: 0x2::object::ID,\n        creator: address,\n        unlocker: 0x1::option::Option<address>,\n        sender: address,\n    }\n    \n    struct LockerContentsUnlocked has copy, drop {\n        msg_vec: vector<u8>,\n        bls_signature: vector<u8>,\n        public_key: vector<u8>,\n        lockerContents_id: 0x2::object::ID,\n        creator: address,\n        unlocker: 0x1::option::Option<address>,\n        sender: address,\n    }\n    \n    struct AddObject has copy, drop {\n        public_key: vector<u8>,\n        lockerContents_id: 0x2::object::ID,\n        object_type: 0x1::ascii::String,\n        creator: address,\n        unlocker: 0x1::option::Option<address>,\n        sender: address,\n    }\n    \n    struct RemoveObject has copy, drop {\n        public_key: vector<u8>,\n        lockerContents_id: 0x2::object::ID,\n        object_type: 0x1::ascii::String,\n        creator: address,\n        unlocker: 0x1::option::Option<address>,\n        sender: address,\n    }\n    \n    struct Locker has key {\n        id: 0x2::object::UID,\n    }\n    \n    struct LockerContents has store, key {\n        id: 0x2::object::UID,\n        bag: 0x0::object_bag::ObjectBag,\n        creator: address,\n        unlocker: 0x1::option::Option<address>,\n    }\n    \n    public fun add_object<T0: store + key>(arg0: &mut Locker, arg1: vector<u8>, arg2: T0, arg3: &0x2::tx_context::TxContext) {\n        assert!(is_not_coin<T0>(), 7);\n        let v0 = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut arg0.id, arg1);\n        assert!(v0.creator == 0x2::tx_context::sender(arg3), 8);\n        let v1 = AddObject{\n            public_key        : arg1, \n            lockerContents_id : 0x2::object::id<LockerContents>(v0), \n            object_type       : 0x1::type_name::into_string(0x1::type_name::get<T0>()), \n            creator           : v0.creator, \n            unlocker          : v0.unlocker, \n            sender            : 0x2::tx_context::sender(arg3),\n        };\n        0x2::event::emit<AddObject>(v1);\n        0x0::object_bag::add<T0>(&mut v0.bag, 0x0::object_bag::length(&v0.bag), arg2);\n    }\n    \n    fun create_locker(arg0: &mut 0x2::tx_context::TxContext) {\n        let v0 = Locker{id: 0x2::object::new(arg0)};\n        0x2::transfer::share_object<Locker>(v0);\n    }\n    \n    public fun create_locker_contents(arg0: &mut Locker, arg1: address, arg2: 0x1::option::Option<address>, arg3: vector<u8>, arg4: &mut 0x2::tx_context::TxContext) {\n        let v0 = LockerContents{\n            id       : 0x2::object::new(arg4), \n            bag      : 0x0::object_bag::new(arg4), \n            creator  : arg1, \n            unlocker : arg2,\n        };\n        let v1 = LockerContentsCreated{\n            public_key        : arg3, \n            lockerContents_id : 0x2::object::id<LockerContents>(&v0), \n            creator           : arg1, \n            unlocker          : arg2, \n            sender            : 0x2::tx_context::sender(arg4),\n        };\n        0x2::event::emit<LockerContentsCreated>(v1);\n        0x2::dynamic_object_field::add<vector<u8>, LockerContents>(&mut arg0.id, arg3, v0);\n    }\n    \n    public fun delete_locker_contents(arg0: &mut Locker, arg1: vector<u8>, arg2: &mut 0x2::tx_context::TxContext) {\n        let LockerContents {\n            id       : v0,\n            bag      : v1,\n            creator  : v2,\n            unlocker : v3,\n        } = 0x2::dynamic_object_field::remove<vector<u8>, LockerContents>(&mut arg0.id, arg1);\n        let v4 = v3;\n        let v5 = v0;\n        assert!(v2 == 0x2::tx_context::sender(arg2) || *0x1::option::borrow<address>(&v4) == 0x2::tx_context::sender(arg2), 8);\n        let v6 = LockerContentsDeleted{\n            public_key        : arg1, \n            lockerContents_id : 0x2::object::uid_to_inner(&v5), \n            creator           : v2, \n            unlocker          : v4, \n            sender            : 0x2::tx_context::sender(arg2),\n        };\n        0x2::event::emit<LockerContentsDeleted>(v6);\n        0x0::object_bag::destroy_empty(v1);\n        0x2::object::delete(v5);\n    }\n    \n    fun init(arg0: &mut 0x2::tx_context::TxContext) {\n        create_locker(arg0);\n    }\n    \n    fun is_not_coin<T0>() : bool {\n        let v0 = 0x1::string::from_ascii(0x1::type_name::into_string(0x1::type_name::get<T0>()));\n        let v1 = 0x1::string::utf8(b"");\n        if (0x1::string::length(&v0) > 76) {\n            v1 = 0x1::string::sub_string(&v0, 0, 76);\n        };\n        !(v1 == 0x1::string::utf8(b"0000000000000000000000000000000000000000000000000000000000000002::coin::Coin"))\n    }\n    \n    public fun lock_exists(arg0: &Locker, arg1: vector<u8>) : bool {\n        0x2::dynamic_object_field::exists_with_type<vector<u8>, LockerContents>(&arg0.id, arg1)\n    }\n    \n    public fun remove_object<T0: store + key>(arg0: &mut Locker, arg1: vector<u8>, arg2: u64, arg3: &0x2::tx_context::TxContext) : T0 {\n        assert!(is_not_coin<T0>(), 7);\n        let v0 = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut arg0.id, arg1);\n        assert!(v0.creator == 0x2::tx_context::sender(arg3) || *0x1::option::borrow<address>(&v0.unlocker) == 0x2::tx_context::sender(arg3), 8);\n        let v1 = RemoveObject{\n            public_key        : arg1, \n            lockerContents_id : 0x2::object::id<LockerContents>(v0), \n            object_type       : 0x1::type_name::into_string(0x1::type_name::get<T0>()), \n            creator           : v0.creator, \n            unlocker          : v0.unlocker, \n            sender            : 0x2::tx_context::sender(arg3),\n        };\n        0x2::event::emit<RemoveObject>(v1);\n        0x0::object_bag::remove<T0>(&mut v0.bag, arg2)\n    }\n    \n    public fun unlock(arg0: &mut Locker, arg1: vector<u8>, arg2: vector<u8>, arg3: address, arg4: &mut 0x2::tx_context::TxContext) {\n        let v0 = 0x1::bcs::to_bytes<address>(&arg3);\n        assert!(0x2::bls12381::bls12381_min_pk_verify(&arg1, &arg2, &v0), 6);\n        let v1 = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut arg0.id, arg2);\n        v1.unlocker = 0x1::option::some<address>(arg3);\n        let v2 = LockerContentsUnlocked{\n            msg_vec           : v0, \n            bls_signature     : arg1, \n            public_key        : arg2, \n            lockerContents_id : 0x2::object::id<LockerContents>(v1), \n            creator           : v1.creator, \n            unlocker          : v1.unlocker, \n            sender            : 0x2::tx_context::sender(arg4),\n        };\n        0x2::event::emit<LockerContentsUnlocked>(v2);\n    }\n}\n```',
//   },
//   {
//     role: "assistant",
//     content:
//       '```move\nmodule 0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::locker {\n\n    //----------------- Module Imports -----------------\n\n    use 0x2::object;\n    use 0x2::transfer;\n    use 0x2::tx_context;\n    use 0x2::dynamic_object_field;\n    use 0x0::object_bag;\n    use 0x2::event;\n    use 0x1::ascii;\n    use 0x2::bls12381;\n    use 0x1::string;\n    use 0x1::type_name;\n    use 0x1::option;\n    use 0x1::bcs;\n\n    //-------- Errors --------------\n\n    const ENotAuthorized: u64 = 8;\n    const ECanNotUseCoinAtThisFunction: u64 = 7;\n    const EInvalidBlsSig: u64 = 6;\n\n    //-------- Events --------------\n\n    struct LockerContentsCreated has copy, drop {\n        public_key: vector<u8>,\n        lockerContents_id: object::ID,\n        creator: address,\n        unlocker: option::Option<address>,\n        sender: address,\n    }\n\n    struct LockerContentsDeleted has copy, drop {\n        public_key: vector<u8>,\n        lockerContents_id: object::ID,\n        creator: address,\n        unlocker: option::Option<address>,\n        sender: address,\n    }\n\n    struct LockerContentsUnlocked has copy, drop {\n        msg_vec: vector<u8>,\n        bls_signature: vector<u8>,\n        public_key: vector<u8>,\n        lockerContents_id: object::ID,\n        creator: address,\n        unlocker: option::Option<address>,\n        sender: address,\n    }\n\n    struct AddObject has copy, drop {\n        public_key: vector<u8>,\n        lockerContents_id: object::ID,\n        object_type: ascii::String,\n        creator: address,\n        unlocker: option::Option<address>,\n        sender: address,\n    } \n\n    struct RemoveObject has copy, drop {\n        public_key: vector<u8>,\n        lockerContents_id: object::ID,\n        object_type: ascii::String,\n        creator: address,\n        unlocker: option::Option<address>,\n        sender: address,\n    }\n\n    //-------- Objects --------------\n\n    struct Locker has key {\n        id: object::UID\n    }\n\n    struct LockerContents has key, store {\n        id: object::UID,\n        bag: object_bag::ObjectBag,\n        creator: address,\n        unlocker: option::Option<address>,\n    }\n\n    //-------- Constructor --------------\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        create_locker(ctx);: create_locker(ctx);}\n\n    //-------- Internal Functions --------------\n\n    fun create_locker(ctx: &mut tx_context::TxContext) {\n        transfer::share_object(Locker { id: object::new(ctx) })\n    }\n\n    fun is_not_coin<T>(): bool {\n        let type_string_ascii: ascii::String = type_name::into_string((type_name::get<T>()));\n        let type_string = string::from_ascii(type_string_ascii);\n        let type_substring = string::utf8(b"");\n        if(string::length(&type_string) > 76){\n            type_substring = string::sub_string(&type_string, 0: 0, 76);: 76);};\n        let isCoin = type_substring == string::utf8(\n            b"0000000000000000000000000000000000000000000000000000000000000002::coin::Coin"\n        );\n        !isCoin\n    }\n\n    //-------- Getter Functions --------------\n\n    public fun lock_exists(\n        locker: &Locker,\n        public_key: vector<u8>,\n    ): bool {\n        dynamic_object_field::exists_with_type<vector<u8>, LockerContents>(&locker.id: LockerContents>(&locker.id, public_key): public_key)}\n\n    //-------- Public Functions --------------\n\n    public fun create_locker_contents(\n        locker: &mut Locker,\n        creator: address,\n        unlocker: option::Option<address>,\n        public_key: vector<u8>,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let bag = object_bag::new(ctx);\n        let contents = LockerContents {\n            id: object::new(ctx),\n            bag: bag,\n            creator: creator,\n            unlocker: unlocker,\n        };\n\n        let lockerContents_id = object::id(&contents);\n        event::emit(LockerContentsCreated {\n            public_key: public_key,\n            lockerContents_id: lockerContents_id,\n            creator: creator,\n            unlocker: unlocker,\n            sender: tx_context::sender(ctx)\n        });\n\n        dynamic_object_field::add(&mut locker.id, public_key, contents);\n    }\n\n    public fun delete_locker_contents(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let contents = dynamic_object_field::remove<vector<u8>, LockerContents>(&mut locker.id, public_key);\n        let LockerContents { id: id, bag: bag, creator: creator, unlocker: unlocker} = contents;\n        assert!(\n            creator == tx_context::sender(ctx) || \n            *option::borrow(&unlocker) == tx_context::sender(ctx),\n            ENotAuthorized\n        );\n\n        let lockerContents_id = object::uid_to_inner(&id);\n        event::emit(LockerContentsDeleted {\n            public_key: public_key,\n            lockerContents_id: lockerContents_id,\n            creator: creator,\n            unlocker: unlocker,\n            sender: tx_context::sender(ctx),\n        });\n        \n        object_bag::destroy_empty(bag);\n        object::delete(id);\n    }\n\n    public fun unlock(\n        locker: &mut Locker,\n        bls_signature: vector<u8>,\n        public_key: vector<u8>,\n        unlocker: address,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let msg_vec = bcs::to_bytes(&unlocker);\n        assert!(\n            bls12381::bls12381_min_pk_verify(\n                &bls_signature, &public_key, &msg_vec,\n            ),\n            EInvalidBlsSig\n        );\n        let contents = dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut locker.id, public_key);\n        contents.unlocker = option::some(unlocker);\n\n        event::emit(LockerContentsUnlocked {\n            msg_vec: msg_vec,\n            bls_signature: bls_signature,\n            public_key: public_key,\n            lockerContents_id: object::id(contents),\n            creator: contents.creator,\n            unlocker: contents.unlocker,\n            sender: tx_context::sender(ctx),\n        });\n    }\n\n    public fun add_object<V: key + store>(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        v: V,\n        ctx: &tx_context::TxContext\n    ) {\n        assert!(is_not_coin<V>(), ECanNotUseCoinAtThisFunction);\n        let contents = dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(\n            &mut locker.id,\n            public_key\n        );\n        assert!(contents.creator == tx_context::sender(ctx), ENotAuthorized);\n\n        event::emit(AddObject {\n            public_key: public_key,\n            lockerContents_id: object::id(contents),\n            object_type: type_name::into_string((type_name::get<V>())),\n            creator: contents.creator,\n            unlocker: contents.unlocker,\n            sender: tx_context::sender(ctx),\n        });\n\n        let index = object_bag::length(&contents.bag);\n        object_bag::add(&mut contents.bag, index, v);\n    }\n\n    public fun remove_object<V: key + store>(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        k: u64,\n        ctx: &tx_context::TxContext\n    ): V {\n        assert!(is_not_coin<V>(), ECanNotUseCoinAtThisFunction);\n        let contents = dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut locker.id, public_key);\n        assert!(\n            contents.creator == tx_context::sender(ctx) || \n            *option::borrow(&contents.unlocker) == tx_context::sender(ctx),\n            ENotAuthorized\n        );\n\n        let object = object_bag::remove<V>(&mut contents.bag, k);\n\n        event::emit(RemoveObject {\n            public_key: public_key,\n            lockerContents_id: object::id(contents),\n            object_type: type_name::into_string((type_name::get<V>())),\n            creator: contents.creator,\n            unlocker: contents.unlocker,\n            sender: tx_context::sender(ctx),\n        });\n\n        object\n    }\n\n}\n```',
//   },
// ];
