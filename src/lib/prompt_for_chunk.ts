// src/lib/prompt_for_chunk.ts

export const prompt = [
  {
    role: "system",
    content:
      "Move is an open source language for writing safe smart contracts. \nMove's format is similar to Rust. But have the following differences. In sum, you should follow the syntax and function call of the given decompiled code, they are mostly syntax correct.\nBelow are some expection you should pay attention to:\n\n" +
      "# 1. The if statement should be brackets, and should add a semicolon at the end of the if statement like the following:\n```move\nif (a > b) {\n    // do something\n};\n````\n\n" +
      "# 2. At Move, you can not mutate a variable while access it at the same time, that is, within the range of same semicolon.\nThe given decompiled move will violate this rule, and you should fix it by creating variables in the output.\nUser sometime will add comments in the decompiled_move to indicated this warning. But you should always fix it. It is nice to have more variable instead of put all input object into the function and risk to trigger this error. \nExample like the following:\n```decompiled_move\n    public entry fun start_game<T0>(arg0: &mut House<T0>, arg1: u8, arg2: vector<u8>, arg3: 0x2::coin::Coin<T0>, arg4: &mut 0x2::tx_context::TxContext) : 0x2::object::ID {\n        let (v0, v1) = new_game<T0>(arg0, arg1, arg2, arg3, house_fee_rate<T0>(arg0), 0x1::option::none<0x1::type_name::TypeName>(), arg4);\n        0x2::dynamic_object_field::add<0x2::object::ID, Game<T0>>(&mut arg0.id, v0, v1);\n        v0\n    }\n```\nThe code above use arg0 twice at new_game, and should be fix and converted to the following (you should keep all parameters in the call, and may further rename the variable to make it more readable and understandable):\n```move\n    public entry fun start_game<T>(\n        house: &mut House<T>,\n        game_type: u8,\n        game_data: vector<u8>,\n        bet: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ): object::ID {\n        let fee_rate = house_fee_rate(house);\n        let (game_id, game) = new_game(\n            house,\n            game_type,\n            game_data,\n            bet,\n            fee_rate,\n            option::none<type_name::TypeName>(),\n            ctx\n        );\n        dynamic_object_field::add(&mut house.id, game_id, game);\n        game_id\n    }\n```\n\n" +
      "# 3. At Move, if a object was sent to a function without using reference (&), then it is freezed and the object and its fields cannot be used or access anymore even with reference (&). Therefore, if an object is going to be freezed yet its field value may be used later, you should create a variable to store the field value. For example: \n```decompiled_move\n    public entry fun challenge<T0>(arg0: &mut House<T0>, arg1: 0x2::object::ID, arg2: &mut 0x2::tx_context::TxContext) {\n        assert!(game_exists<T0>(arg0, arg1), 7);\n        let Game {\n            id          : v0,\n            player      : v1,\n            start_epoch : v2,\n            stake       : v3,\n            guess       : _,\n            seed        : _,\n            fee_rate    : _,\n        } = 0x2::dynamic_object_field::remove<0x2::object::ID, Game<T0>>(&mut arg0.id, arg1);\n        let v7 = v3;\n        assert!(0x2::tx_context::epoch(arg2) > v2 + 7, 4);\n        0x2::transfer::public_transfer<0x2::coin::Coin<T0>>(0x2::coin::from_balance<T0>(v7, arg2), v1);\n        0x2::object::delete(v0);\n        let v8 = Outcome<T0>{\n            game_id    : arg1, \n            player     : v1, \n            player_won : true, \n            pnl        : 0x2::balance::value<T0>(&v7) / 2, \n            challenged : true,\n        };\n        0x2::event::emit<Outcome<T0>>(v8);\n    }\n```\nThe code above use v7 = v3 so the v3 is freezed, but then it use 0x2::coin::from_balance<T0>(v7, arg2) so the v7 is freezed before the use of 0x2::balance::value<T0>(&v7). Hence, we need to modify to make value of v7 being assigned to a variable first, it should be fixed and convert to \n```move\n    public entry fun challenge<T>(\n        house: &mut House<T>,\n        game_id: object::ID,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(game_exists<T>(house, game_id), 7);\n\n        let Game {\n            id,\n            player,\n            start_epoch,\n            stake,\n            guess: _,\n            seed: _,\n            fee_rate: _,\n        } = dynamic_object_field::remove<object::ID, Game<T>>(&mut house.id, game_id);\n\n        assert!(\n            tx_context::epoch(ctx) > start_epoch + 7,\n            4\n        );\n\n        let stake_value = balance::value(&stake);\n        transfer::public_transfer(\n            coin::from_balance(stake, ctx),\n            player\n        );\n\n        object::delete(id);\n\n        let outcome = Outcome<T> {\n            game_id,\n            player,\n            player_won: true,\n            pnl: stake_value / 2,\n            challenged: true,\n        };\n\n        event::emit<Outcome<T>>(outcome);\n    }\n```. You can see I add some variable to handle stake_value and " +
      "# 4. At Move, if the struct don't have `drop` property, you need to destruct the struct, destroy object or delete the id remove it.\nFor example:\n```move\nstruct LockerContents has store, key {\n    id: 0x2::object::UID,\n    bag: 0x0::object_bag::ObjectBag,\n    creator: address,\n    unlocker: 0x1::option::Option<address>,\n}\n\npublic fun delete_locker_contents(\n    locker: &mut Locker,\n    public_key: vector<u8>,\n    ctx: &mut tx_context::TxContext,\n) {\n    let contents = dynamic_object_field::remove<vector<u8>, LockerContents>(&mut locker.id, public_key);\n    let LockerContents { id: id, bag: bag, creator: creator, unlocker: unlocker} = contents;\n    object_bag::destroy_empty(bag);\n    object::delete(id);\n}\n```\n\n" +
      "# 5. At Move, a return statement or a variable assignment should be enclosed in brackets. There may be errors in decompiled code, and you should fix it. For example:\n\n```decompiled_move\npublic fun safe_mul_div_u64(arg0: u64, arg1: u64, arg2: u64) : u64 {\n    ((arg0 as u128) * (arg1 as u128) / (arg2 as u128)) as u64\n}\n```\n\n```move\npublic fun safe_mul_div_u64(\n    a: u64,\n    b: u64,\n    c: u64\n): u64 {\n    let a_u128 = (a as u128);\n    let b_u128 = (b as u128);\n    let c_u128 = (c as u128);\n    ((a_u128 * b_u128 / c_u128) as u64)\n}\n```\n\n" +
      "# 6. At move, you don't need semicolon after break or return statement. However, you do need a semicolon after the braces of if, else, while, or loop. You can check this out in the examples. For example:\n```move\n    public fun calculate_index(index: u64): u64{\n        let max = 10;\n        let final_index = 0;\n        loop {\n            if (final_index > index || final_index >= max) {\n                break // you don't need a semicolon at the tailing of break statement\n            } else {\n                final_index = final_index + 1; // you cannot use += operator in Move\n            }; // you do need a semicolon at the tailing of if else statement brackets\n        }; // you do need a semicolon at the tailing of loop brackets\n        return final_index // you don't need a semicolon at the tailing of return statement\n    }\n```\n\n" +
      "# 7. At move, you can not use -= or +=, please don't simplify and just do it with full expression such as `i = i + 1`" +
      "# 8. At move, the as need to be wrapped with parentheses, we can't use `let a = b as u64;` instead, we need to use `let a = (b as u64);` Same apply to multiple as, each as should be wrapped with parentheses, for example, we can't use `let a = ((b as u64) / 12) as u8` or `let a = (b as u64 * 12) as u8`, we can only use `let a = (((b as u64) / 12) as u8);`. For example, given the input\n```decompiled_move\n    fun compute_fee_amount(arg0: u64, arg1: u128) : u64 {\n        (((arg0 as u128) * arg1 / 1000000) as u64)\n    }```\n\n, it should be convert to " +
      "```move\n    fun compute_fee_amount(\n        amount: u64,\n        fee_rate: u128\n    ): u64 {\n        (((amount as u128) * fee_rate / 1000000) as u64)\n    }\n```" +
      "# 9. At Move, follow strict type and generic annotations from the decompiled code. Ensure all type annotations in struct creation or function calls, including event structs, are preserved in the converted code.",
  },
  {
    role: "system",
    content:
      "You are assigned the role of a Sui Move code converter, whose responsibility is to convert the given decompiled Move code to a human-readable and machine-compilable state.\n\nDuring the conversion process, ensure that you strictly follow to the case, brackets, logic, function names, struct, syntax, semicolons, type annotations, and symbols in the given decompiled Move code I gave you without introducing any new logic, function name, syntax, nor refactor. \nEspecially, when generating the converted code, you should not create, add, remove, skip, omit, or change the following from the provided given code: import statements, case, brackets, logic, function names, struct, syntax, semicolons, type annotations, symbols, logic, or inherit structure.\nYou should not omit any function in the decompiled move code even if they are empty. Just keep them as they are.\nIf there are type annotations, you should keep them. If there are no type annotations, you should not add them.\n\nYour primary tasks include \n1. Keep the function name, call format, parameter count, type, child method name, and struct name exactly as it is. Do not omit, change, or invent any function call format, type annotation, function name, new parameter, and struct name. For example, if the code use `loop`, then don't change it to `while`. Or if there are TxContext in the function parameter, do not ignore it. Also, if there are type annotations for function or variable, don't remove them. For example, if the code is `let v1 = 0x2::dynamic_field::borrow_mut<vector<u8>, LockerContents>(&mut arg0.id, arg1);`, then don't omit the <vector<u8>, LockerContents> part, you should keep it and output `let contents = 0x2::dynamic_field::borrow_mut<vector<u8>, LockerContents>(&mut locker.id, public_key);`. The dynamic_field here are similar to 0x2::bag, 0x2::object_bag, 0x2::dynamic_object_field, all of them are mapping that can store different types, so we need to keep the function type annotation when borrowing or removing the field with borrow_mut, burrow, or remove. If the original code uses camelCase, then keep using camelCase. If the original code uses underscores, then continue using underscores. Lastly, don't add ` as ` in the move code if there is no ` as `in the decompiled move code, that is unnecessary.\n2. You may rename variables (e.g., v0, v1...) and parameters (e.g., arg0, arg1...) to camel case natural language variable names and make it more easy to read and understand.\n3. You may modify the syntax to make it correct and create variables to make it more readable.\n3. You may assign variables, instead of put it all together, to avoid mutate same variable while access it at the same time (within the range of same semicolon), and increase readability and understanding. \n\n\nYou should generate full code regardless the length so far or token limits or complexity.\nYou should not use any comments to skip or omit the generation of codes, functions, and implementations.\nYou should not output something like \n// other codes here\n or \n// More Codes\n or \n// Continue or \n// Implementation omitted for brevity.\nJust ignore the length constrains, token limits, and complexity. The user may call you again to continue.\n\nYou should output start with ```move and end with ```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    fun init(arg0: &mut 0x2::tx_context::TxContext) {\n        create_locker(arg0);\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    fun init(ctx: &mut 0x2::tx_context::TxContext) {\n        create_locker(ctx);\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    fun create_locker(arg0: &mut 0x2::tx_context::TxContext) {\n        let v0 = Locker{id: 0x2::object::new(arg0)};\n        0x2::transfer::share_object<Locker>(v0);\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    fun create_locker(ctx: &mut 0x2::tx_context::TxContext) {\n        0x2::transfer::share_object(Locker { id: 0x2::object::new(ctx) })\n    }\n```",
  },
  {
    role: "user",
    content:
      'Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    fun is_not_coin<T0>() : bool {\n        let v0 = 0x1::string::from_ascii(0x1::type_name::into_string(0x1::type_name::get<T0>()));\n        let v1 = 0x1::string::utf8(b"");\n        if (0x1::string::length(&v0) > 76) {\n            v1 = 0x1::string::sub_string(&v0, 0, 76);\n        };\n        !(v1 == 0x1::string::utf8(b"0000000000000000000000000000000000000000000000000000000000000002::coin::Coin"))\n    }```',
  },
  {
    role: "assistant",
    content:
      '```move\n    fun is_not_coin<T>(): bool {\n        let type_string_ascii: 0x1::ascii::String = 0x1::type_name::into_string((0x1::type_name::get<T>()));\n        let type_string = 0x1::string::from_ascii(type_string_ascii);\n        let type_substring = 0x1::string::utf8(b"");\n        if(0x1::string::length(&type_string) > 76){\n            type_substring = 0x1::string::sub_string(&type_string, 0, 76);\n        };\n        let isCoin = type_substring == 0x1::string::utf8(\n            b"0000000000000000000000000000000000000000000000000000000000000002::coin::Coin"\n        );\n        !isCoin\n    }\n```',
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun add_coin<T0>(arg0: &mut Locker, arg1: vector<u8>, arg2: 0x2::coin::Coin<T0>, arg3: &0x2::tx_context::TxContext) {\n        let v0 = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut arg0.id, arg1);\n        assert!(v0.creator == 0x2::tx_context::sender(arg3), 8);\n        let v1 = AddCoin{\n            public_key        : arg1, \n            lockerContents_id : 0x2::object::id<LockerContents>(v0), \n            coin_type         : 0x1::type_name::into_string(0x1::type_name::get<T0>()), \n            balance           : 0x2::coin::value<T0>(&arg2), \n            creator           : v0.creator, \n            unlocker          : v0.unlocker, \n            sender            : 0x2::tx_context::sender(arg3),\n        };\n        0x2::event::emit<AddCoin>(v1);\n        0x0::object_bag::add<0x2::coin::Coin<T0>>(&mut v0.bag, 0x0::object_bag::length(&v0.bag), arg2);\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun add_coin<T>(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        v: 0x2::coin::Coin<T>, \n        ctx: &0x2::tx_context::TxContext\n    ) {\n        let contents = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut locker.id, public_key);\n        assert!(contents.creator == 0x2::tx_context::sender(ctx), 8);\n        0x2::event::emit<AddCoin>(AddCoin {\n            public_key,\n            lockerContents_id: 0x2::object::id(contents),\n            coin_type: 0x1::type_name::into_string((0x1::type_name::get<T>())),\n            balance: 0x2::coin::value(&v),\n            creator: contents.creator,\n            unlocker: contents.unlocker,\n            sender: 0x2::tx_context::sender(ctx),\n        });\n        let index = 0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::object_bag::length(&contents.bag);\n        0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::object_bag::add(&mut contents.bag, index, v);\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun add_object<T0: store + key>(arg0: &mut Locker, arg1: vector<u8>, arg2: T0, arg3: &0x2::tx_context::TxContext) {\n        assert!(is_not_coin<T0>(), 7);\n        let v0 = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut arg0.id, arg1);\n        assert!(v0.creator == 0x2::tx_context::sender(arg3), 8);\n        let v1 = AddObject{\n            public_key        : arg1, \n            lockerContents_id : 0x2::object::id<LockerContents>(v0), \n            object_type       : 0x1::type_name::into_string(0x1::type_name::get<T0>()), \n            creator           : v0.creator, \n            unlocker          : v0.unlocker, \n            sender            : 0x2::tx_context::sender(arg3),\n        };\n        0x2::event::emit<AddObject>(v1);\n        0x0::object_bag::add<T0>(&mut v0.bag, 0x0::object_bag::length(&v0.bag), arg2);\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun add_object<V: key + store>(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        v: V,\n        ctx: &0x2::tx_context::TxContext\n    ) {\n        assert!(is_not_coin<V>(), 7);\n        let contents = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(\n            &mut locker.id,\n            public_key\n        );\n        \n        assert!(contents.creator == 0x2::tx_context::sender(ctx), 8);\n        0x2::event::emit<AddObject>(AddObject {\n            public_key,\n            lockerContents_id: 0x2::object::id(contents),\n            object_type: 0x1::type_name::into_string((0x1::type_name::get<V>())),\n            creator: contents.creator,\n            unlocker: contents.unlocker,\n            sender: 0x2::tx_context::sender(ctx),\n        });\n        let index = 0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::object_bag::length(&contents.bag);\n        0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::object_bag::add(&mut contents.bag, index, v);\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun create_locker_contents(arg0: &mut Locker, arg1: address, arg2: 0x1::option::Option<address>, arg3: vector<u8>, arg4: &mut 0x2::tx_context::TxContext) {\n        let v0 = LockerContents{\n            id       : 0x2::object::new(arg4), \n            bag      : 0x0::object_bag::new(arg4), \n            creator  : arg1, \n            unlocker : arg2,\n        };\n        let v1 = LockerContentsCreated{\n            public_key        : arg3, \n            lockerContents_id : 0x2::object::id<LockerContents>(&v0), \n            creator           : arg1, \n            unlocker          : arg2, \n            sender            : 0x2::tx_context::sender(arg4),\n        };\n        0x2::event::emit<LockerContentsCreated>(v1);\n        0x2::dynamic_object_field::add<vector<u8>, LockerContents>(&mut arg0.id, arg3, v0);\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun create_locker_contents(\n        locker: &mut Locker,\n        creator: address,\n        unlocker: 0x1::option::Option<address>,\n        public_key: vector<u8>,\n        ctx: &mut 0x2::tx_context::TxContext,\n    ) {\n        let bag = 0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::object_bag::new(ctx);\n        let contents = LockerContents {\n            id: 0x2::object::new(ctx),\n            bag,\n            creator,\n            unlocker,\n        };\n        let lockerContents_id = 0x2::object::id(&contents);\n        0x2::event::emit<LockerContentsCreated>(LockerContentsCreated {\n            public_key,\n            lockerContents_id,\n            creator,\n            unlocker,\n            sender: 0x2::tx_context::sender(ctx)\n        });\n        0x2::dynamic_object_field::add(&mut locker.id, public_key, contents);\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun delete_locker_contents(arg0: &mut Locker, arg1: vector<u8>, arg2: &mut 0x2::tx_context::TxContext) {\n        let LockerContents {\n            id       : v0,\n            bag      : v1,\n            creator  : v2,\n            unlocker : v3,\n        } = 0x2::dynamic_object_field::remove<vector<u8>, LockerContents>(&mut arg0.id, arg1);\n        let v4 = v3;\n        let v5 = v0;\n        assert!(v2 == 0x2::tx_context::sender(arg2) || *0x1::option::borrow<address>(&v4) == 0x2::tx_context::sender(arg2), 8);\n        let v6 = LockerContentsDeleted{\n            public_key        : arg1, \n            lockerContents_id : 0x2::object::uid_to_inner(&v5), \n            creator           : v2, \n            unlocker          : v4, \n            sender            : 0x2::tx_context::sender(arg2),\n        };\n        0x2::event::emit<LockerContentsDeleted>(v6);\n        0x0::object_bag::destroy_empty(v1);\n        0x2::object::delete(v5);\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun delete_locker_contents(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        ctx: &mut 0x2::tx_context::TxContext,\n    ) {\n        let contents = 0x2::dynamic_object_field::remove<vector<u8>, LockerContents>(&mut locker.id, public_key);\n        let LockerContents { id, bag, creator, unlocker} = contents;\n        assert!(\n            creator == 0x2::tx_context::sender(ctx) || \n            *0x1::option::borrow(&unlocker) == 0x2::tx_context::sender(ctx),\n            8\n        );\n        let lockerContents_id = 0x2::object::uid_to_inner(&id);\n        0x2::event::emit<LockerContentsDeleted>(LockerContentsDeleted {\n            public_key,\n            lockerContents_id,\n            creator,\n            unlocker,\n            sender: 0x2::tx_context::sender(ctx),\n        });\n        \n        0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::object_bag::destroy_empty(bag);\n        0x2::object::delete(id);\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun getInputPriceUncorrelated(arg0: u64, arg1: u64, arg2: u64, arg3: u64) : u64 {\n        let v0 = (arg0 as u128) * (1000000 - (arg3 as u128));\n        (v0 * (arg2 as u128) / ((arg1 as u128) * 1000000 + v0)) as u64\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun getInputPriceUncorrelated(\n        input_amount: u64,\n        input_reserve: u64,\n        output_reserve: u64,\n        fee: u64\n    ): u64 {\n        let adjusted_input = (input_amount as u128) * (1000000 - (fee as u128));\n        (((adjusted_input * (output_reserve as u128)) / ((input_reserve as u128) * 1000000 + adjusted_input)) as u64)\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun lock_exists(arg0: &Locker, arg1: vector<u8>) : bool {\n        0x2::dynamic_object_field::exists_with_type<vector<u8>, LockerContents>(&arg0.id, arg1)\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun lock_exists(\n        locker: &Locker,\n        public_key: vector<u8>,\n    ): bool {\n        0x2::dynamic_object_field::exists_with_type<vector<u8>, LockerContents>(&locker.id, public_key)\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun remove_coin<T0>(arg0: &mut Locker, arg1: vector<u8>, arg2: u64, arg3: &0x2::tx_context::TxContext) : 0x2::coin::Coin<T0> {\n        let v0 = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut arg0.id, arg1);\n        assert!(v0.creator == 0x2::tx_context::sender(arg3) || *0x1::option::borrow<address>(&v0.unlocker) == 0x2::tx_context::sender(arg3), 8);\n        let v1 = 0x0::object_bag::remove<0x2::coin::Coin<T0>>(&mut v0.bag, arg2);\n        let v2 = RemoveCoin{\n            public_key        : arg1, \n            lockerContents_id : 0x2::object::id<LockerContents>(v0), \n            coin_type         : 0x1::type_name::into_string(0x1::type_name::get<T0>()), \n            balance           : 0x2::coin::value<T0>(&v1), \n            creator           : v0.creator, \n            unlocker          : v0.unlocker, \n            sender            : 0x2::tx_context::sender(arg3),\n        };\n        0x2::event::emit<RemoveCoin>(v2);\n        v1\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun remove_coin<T>(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        k: u64,\n        ctx: &0x2::tx_context::TxContext\n    ): 0x2::coin::Coin<T> {\n        let contents = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut locker.id, public_key);\n        assert!(\n            contents.creator == 0x2::tx_context::sender(ctx) || \n            *0x1::option::borrow(&contents.unlocker) == 0x2::tx_context::sender(ctx),\n            8\n        );\n        let v = 0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::object_bag::remove<0x2::coin::Coin<T>>(&mut contents.bag, k);\n        0x2::event::emit<RemoveCoin>(RemoveCoin {\n            public_key,\n            lockerContents_id: 0x2::object::id(contents),\n            coin_type: 0x1::type_name::into_string((0x1::type_name::get<T>())),\n            balance: 0x2::coin::value(&v),\n            creator: contents.creator,\n            unlocker: contents.unlocker,\n            sender: 0x2::tx_context::sender(ctx),\n        });\n        v\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun remove_coin_to<T0>(arg0: &mut Locker, arg1: vector<u8>, arg2: u64, arg3: address, arg4: &0x2::tx_context::TxContext) {\n        0x2::transfer::public_transfer<0x2::coin::Coin<T0>>(remove_coin<T0>(arg0, arg1, arg2, arg4), arg3);\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun remove_coin_to<T>(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        k: u64,\n        recipient: address,\n        ctx: &0x2::tx_context::TxContext\n    ) {\n        let coin = remove_coin<T>(locker, public_key, k, ctx);\n        0x2::transfer::public_transfer(coin, recipient);\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun remove_object<T0: store + key>(arg0: &mut Locker, arg1: vector<u8>, arg2: u64, arg3: &0x2::tx_context::TxContext) : T0 {\n        assert!(is_not_coin<T0>(), 7);\n        let v0 = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut arg0.id, arg1);\n        assert!(v0.creator == 0x2::tx_context::sender(arg3) || *0x1::option::borrow<address>(&v0.unlocker) == 0x2::tx_context::sender(arg3), 8);\n        let v1 = RemoveObject<T0>{\n            public_key        : arg1, \n            lockerContents_id : 0x2::object::id<LockerContents>(v0), \n            object_type       : 0x1::type_name::into_string(0x1::type_name::get<T0>()), \n            creator           : v0.creator, \n            unlocker          : v0.unlocker, \n            sender            : 0x2::tx_context::sender(arg3),\n        };\n        0x2::event::emit<RemoveObject<T0>>(v1);\n        0x0::object_bag::remove<T0>(&mut v0.bag, arg2)\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun remove_object<V: key + store>(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        k: u64,\n        ctx: &0x2::tx_context::TxContext\n    ): V {\n        assert!(is_not_coin<V>(), 7);\n        let contents = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut locker.id, public_key);\n        assert!(\n            contents.creator == 0x2::tx_context::sender(ctx) || \n            *0x1::option::borrow(&contents.unlocker) == 0x2::tx_context::sender(ctx),\n            8\n        );\n        let object = 0x96d9a120058197fce04afcffa264f2f46747881ba78a91beb38f103c60e315ae::object_bag::remove<V>(&mut contents.bag, k);\n        0x2::event::emit<RemoveObject<V>>(RemoveObject<V> {\n            public_key,\n            lockerContents_id: 0x2::object::id(contents),\n            object_type: 0x1::type_name::into_string((0x1::type_name::get<V>())),\n            creator: contents.creator,\n            unlocker: contents.unlocker,\n            sender: 0x2::tx_context::sender(ctx),\n        });\n        object\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun remove_object_to<T0: store + key>(arg0: &mut Locker, arg1: vector<u8>, arg2: u64, arg3: address, arg4: &0x2::tx_context::TxContext) {\n        0x2::transfer::public_transfer<T0>(remove_object<T0>(arg0, arg1, arg2, arg4), arg3);\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun remove_object_to<V: key + store>(\n        locker: &mut Locker,\n        public_key: vector<u8>,\n        k: u64,\n        recipient: address,\n        ctx: &0x2::tx_context::TxContext\n    ) {\n        let object = remove_object<V>(locker, public_key, k, ctx);\n        0x2::transfer::public_transfer(object, recipient);\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun safeMulDivU64(arg0: u64, arg1: u64, arg2: u64) : u64 {\n        ((arg0 as u128) * (arg1 as u128) / (arg2 as u128)) as u64\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun safeMulDivU64(\n        a: u64,\n        b: u64,\n        c: u64\n    ): u64 {\n        let a_u128 = (a as u128);\n        let b_u128 = (b as u128);\n        let c_u128 = (c as u128);\n        ((a_u128 * b_u128 / c_u128) as u64)\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun swap_token_y_<T0, T1>(arg0: &mut Pool<T0, T1>, arg1: 0x2::coin::Coin<T1>, arg2: u64, arg3: u64, arg4: &mut 0x2::tx_context::TxContext) : 0x2::coin::Coin<T0> {\n        assert!(arg0.is_swap_enabled, 11);\n        let v0 = 0x2::coin::value<T1>(&arg1);\n        assert!(arg2 > 0, 0);\n        assert!(v0 >= arg2, 3);\n        0x2::transfer::public_transfer<0x2::coin::Coin<T1>>(0x2::coin::split<T1>(&mut arg1, v0 - arg2, arg4), 0x2::tx_context::sender(arg4));\n        let v1 = 0x2::coin::into_balance<T1>(arg1);\n        let (v2, v3, _) = get_reserves<T0, T1>(arg0);\n        assert!(v2 > 0 && v3 > 0, 2);\n        let v5 = ((0x2::balance::value<T1>(&v1) as u128) * (arg0.protocol_fee_percent as u128) / 1000000) as u64;\n        let v6 = if (arg0.is_stable) {\n            0xa0eba10b173538c8fecca1dff298e488402cc9ff374f8a12ca7758eebe830b66::utils::get_input_price_stable(arg2 - v5, v2, v3, arg0.lp_fee_percent, arg0.scaleY, arg0.scaleX)\n        } else {\n            0xa0eba10b173538c8fecca1dff298e488402cc9ff374f8a12ca7758eebe830b66::utils::get_input_price_uncorrelated(arg2 - v5, v2, v3, arg0.lp_fee_percent)\n        };\n        assert!(v6 >= arg3, 8);\n        0x2::balance::join<T1>(&mut arg0.token_y, v1);\n        0x2::balance::join<T1>(&mut arg0.protocol_fee_y, 0x2::coin::into_balance<T1>(0x2::coin::take<T1>(&mut v1, v5, arg4)));\n        let (v7, v8, _) = get_reserves<T0, T1>(arg0);\n        assert_lp_value_is_increased(arg0.is_stable, arg0.scaleX, arg0.scaleY, v3 as u128, v2 as u128, v8 as u128, v7 as u128);\n        emit_swap_event<T1>(*0x2::object::uid_as_inner(&arg0.id), 0x2::tx_context::sender(arg4), v8, v7, arg2 - v5, v6);\n        0x2::coin::take<T0>(&mut arg0.token_x, v6, arg4)\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun swap_token_y_<T0, T1>(\n        pool: &mut Pool<T0, T1>,\n        token_y: 0x2::coin::Coin<T1>,\n        min_expected: u64,\n        max_slippage: u64,\n        ctx: &mut 0x2::tx_context::TxContext\n    ): 0x2::coin::Coin<T0> {\n        assert!(pool.is_swap_enabled, 11);\n        let token_y_value = 0x2::coin::value(&token_y);\n        assert!(min_expected > 0, 0);\n        assert!(token_y_value >= min_expected, 3);\n        0x2::transfer::public_transfer(\n            0x2::coin::split(&mut token_y, token_y_value - min_expected, ctx),\n            0x2::tx_context::sender(ctx)\n        );\n        let token_y_balance = 0x2::coin::into_balance(token_y);\n        let (reserve_x, reserve_y, _) = get_reserves<T0, T1>(pool);\n        assert!(reserve_x > 0 && reserve_y > 0, 2);\n        let protocol_fee = (((0x2::balance::value(&token_y_balance) as u128) * (pool.protocol_fee_percent as u128) / 1000000) as u64);\n        let output_amount = if (pool.is_stable) {\n            0xa0eba10b173538c8fecca1dff298e488402cc9ff374f8a12ca7758eebe830b66::utils::get_input_price_stable(\n                min_expected - protocol_fee, reserve_x, reserve_y, pool.lp_fee_percent, pool.scaleY, pool.scaleX\n            )\n        } else {\n            0xa0eba10b173538c8fecca1dff298e488402cc9ff374f8a12ca7758eebe830b66::utils::get_input_price_uncorrelated(\n                min_expected - protocol_fee, reserve_x, reserve_y, pool.lp_fee_percent\n            )\n        };\n        assert!(output_amount >= max_slippage, 8);\n        0x2::balance::join(&mut pool.token_y, token_y_balance);\n        0x2::balance::join(\n            &mut pool.protocol_fee_y,\n            0x2::coin::into_balance(\n                0x2::coin::take(&mut token_y_balance, protocol_fee, ctx)\n            )\n        );\n        let (new_reserve_x, new_reserve_y, _) = get_reserves<T0, T1>(pool);\n        assert_lp_value_is_increased(\n            pool.is_stable,\n            pool.scaleX,\n            pool.scaleY,\n            (reserve_y as u128),\n            (reserve_x as u128),\n            (new_reserve_y as u128),\n            (new_reserve_x as u128)\n        );\n        emit_swap_event<T1>(\n            *0x2::object::uid_as_inner(&pool.id),\n            0x2::tx_context::sender(ctx),\n            new_reserve_x,\n            new_reserve_y,\n            min_expected - protocol_fee,\n            output_amount\n        );\n        0x2::coin::take<T0>(&mut pool.token_x, output_amount, ctx)\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public fun unlock(arg0: &mut Locker, arg1: vector<u8>, arg2: vector<u8>, arg3: address, arg4: &mut 0x2::tx_context::TxContext) {\n        let v0 = 0x1::bcs::to_bytes<address>(&arg3);\n        assert!(0x2::bls12381::bls12381_min_pk_verify(&arg1, &arg2, &v0), 6);\n        let v1 = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut arg0.id, arg2);\n        v1.unlocker = 0x1::option::some<address>(arg3);\n        let v2 = LockerContentsUnlocked{\n            msg_vec           : v0, \n            bls_signature     : arg1, \n            public_key        : arg2, \n            lockerContents_id : 0x2::object::id<LockerContents>(v1), \n            creator           : v1.creator, \n            unlocker          : v1.unlocker, \n            sender            : 0x2::tx_context::sender(arg4),\n        };\n        0x2::event::emit<LockerContentsUnlocked>(v2);\n    }```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public fun unlock(\n        locker: &mut Locker,\n        bls_signature: vector<u8>,\n        public_key: vector<u8>,\n        unlocker: address,\n        ctx: &mut 0x2::tx_context::TxContext,\n    ) {\n        let msg_vec = 0x1::bcs::to_bytes(&unlocker);\n        assert!(\n            0x2::::bls12381::bls12381_min_pk_verify(\n                &bls_signature, &public_key, &msg_vec,\n            ),\n            6\n        );\n        let contents = 0x2::dynamic_object_field::borrow_mut<vector<u8>, LockerContents>(&mut locker.id, public_key);\n        contents.unlocker = 0x1::option::some(unlocker);\n        0x2::event::emit<LockerContentsUnlocked>(LockerContentsUnlocked {\n            msg_vec,\n            bls_signature,\n            public_key,\n            lockerContents_id: 0x2::object::id(contents),\n            creator: contents.creator,\n            unlocker: contents.unlocker,\n            sender: 0x2::tx_context::sender(ctx),\n        });\n    }\n```",
  },
  {
    role: "user",
    content:
      "Here is the decompiled Move code block you need to convert:\n```decompiled_move\n    public entry fun challenge<T0>(arg0: &mut House<T0>, arg1: 0x2::object::ID, arg2: &mut 0x2::tx_context::TxContext) {\n        assert!(game_exists<T0>(arg0, arg1), 7);\n        let Game {\n            id          : v0,\n            player      : v1,\n            start_epoch : v2,\n            stake       : v3,\n            guess       : _,\n            seed        : _,\n            fee_rate    : _,\n        } = 0x2::dynamic_object_field::remove<0x2::object::ID, Game<T0>>(&mut arg0.id, arg1);\n        let v7 = v3;\n        assert!(0x2::tx_context::epoch(arg2) > v2 + 7, 4);\n        0x2::transfer::public_transfer<0x2::coin::Coin<T0>>(0x2::coin::from_balance<T0>(v7, arg2), v1);\n        0x2::object::delete(v0);\n        let v8 = Outcome<T0>{\n            game_id    : arg1, \n            player     : v1, \n            player_won : true, \n            pnl        : 0x2::balance::value<T0>(&v7) / 2, \n            challenged : true,\n        };\n        0x2::event::emit<Outcome<T0>>(v8);\n    }\n```",
  },
  {
    role: "assistant",
    content:
      "```move\n    public entry fun challenge<T>(\n        house: &mut House<T>,\n        game_id: object::ID,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(game_exists<T>(house, game_id), 7);\n\n        let Game {\n            id,\n            player,\n            start_epoch,\n            stake,\n            guess: _,\n            seed: _,\n            fee_rate: _,\n        } = dynamic_object_field::remove<object::ID, Game<T>>(&mut house.id, game_id);\n\n        assert!(\n            tx_context::epoch(ctx) > start_epoch + 7,\n            4\n        );\n\n        let stake_value = balance::value(&stake);\n        transfer::public_transfer(\n            coin::from_balance(stake, ctx),\n            player\n        );\n\n        object::delete(id);\n\n        let outcome = Outcome<T> {\n            game_id,\n            player,\n            player_won: true,\n            pnl: stake_value / 2,\n            challenged: true,\n        };\n\n        event::emit<Outcome<T>>(outcome);\n    }\n```",
  },
];
